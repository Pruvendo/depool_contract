Definition StakingContract_Ф__addNewRoundAndUpdateRounds : StakingContract True := 
 { 
 _addNewPoolingRound (( _setAndGetNextElectAt () , _getFreezingPeriod () )) >> 
 	 
 Ift ( _getRoundsCount () > 4 ) { Round removingRound =11 _removeOldestRound () >> 
 	 delete m_requests [ removingRound ^^ id ] >> 
 	 
 Ift ( removingRound ^^ step == STEP_WAITING_ELECTION_RESULTS ) { _addPendingRound (( removingRound )) >> 
 	 _recoverPendingRoundStakes (( removingRound ^^ id )) >> 
 	 
 } 
 
 } 
 
 Ift ( _getRoundsCount () > 1 ) { _setPenultimateRound (( _requestStakesSigning (( _getPenultimateRound () )) )) >> 
 	 
 } 
 
 } 
 .
Definition StakingContract_Ф__checkPenultimateRound : StakingContract XBool := 
 { 
 Round lb1Round =11 _getPenultimateRound () >> 
 	 
 Ift ( now > lb1Round ^^ id ) { 
 Ift ( lb1Round ^^ step < STEP_ELECTIONS ) { _setPenultimateRound (( _completeRoundAndSetCompletionStatus (( lb1Round , ROUND_MISSED_ELECTIONS )) )) >> 
 	 return true >> 
 	 
 } 
 
 Ift ( lb1Round ^^ step < STEP_WAITING_ELECTION_RESULTS ) { _recoverStakes () >> 
 	 lb1Round ^^ step =31 STEP_WAITING_ELECTION_RESULTS >> 
 	 _setPenultimateRound (( lb1Round )) >> 
 	 return true >> 
 	 
 } 
 
 } 
 return false >> 
 	 
 } 
 .
Definition StakingContract_Ф__checkOldestRound : StakingContract XBool := 
 { 
 Round oldestRound =11 _getOldestRound () >> 
 	 
 Ift ( _isRoundUnfrozen (( oldestRound ^^ id )) ) { 
 Ift ( oldestRound ^^ step == STEP_WAITING_ELECTION_RESULTS ) { _recoverStakeRewards () >> 
 	 oldestRound ^^ step =31 STEP_WAITING_UNFREEZE >> 
 	 _setOldestRound (( oldestRound )) >> 
 	 return true >> 
 	 
 } 
 
 } 
 return false >> 
 	 
 } 
 .
Definition StakingContract_Ф__returnGrams : StakingContract True := 
 { 
 msg ^^ sender . transfer (( 0 , true , 64 )) >> 
 	 
 } 
 .
Definition StakingContract_Ф__calcLastRoundInterest ( totalStake : XInteger64 )( rewards : XInteger64 ) : StakingContract XInteger64 := 
 { 
 return (( totalStake ! =10 0 )) ? uint64 (( (( rewards * 100 * 1e9 )) / totalStake )) : 0 >> 
 	 
 } 
 .
Definition StakingContract_Ф__returnAnswer ( errcode : XInteger32 )( amount : XInteger64 )( comment : XInteger64 ) : StakingContract True := 
 { 
 IParticipant (( msg ^^ sender )) . receiveAnswer 
 { 
 value:amount , flag: (( amount == 0 ? 64 : 3 )) 
 } 
 (( errcode , comment )) >> 
 	 
 } 
 .
Definition StakingContract_Ф__returnError ( errcode : XInteger32 )( comment : XInteger64 ) : StakingContract True := 
 { 
 _returnAnswer (( errcode , 0 , comment )) >> 
 	 
 } 
 .
Definition StakingContract_Ф__returnConfirmation ( fee : XInteger64 ) : StakingContract True := 
 { 
 _returnAnswer (( STATUS_SUCCESS , ANSWER_MSG_FEE , fee )) >> 
 	 
 } 
 .
Definition StakingContract_Ф__investStake ( addr : XAddress )( unusedStake : XInteger64 )( newStake : XInteger64 )( reinvest : XBool ) : StakingContract XBool := 
 { 
 Stakeholder stakeholder =11 _getStakeholder (( addr )) >> 
 	 unusedStake =13 tvm ^^ min (( unusedStake , stakeholder ^^ unusedStake )) >> 
 	 uint64 investStake =11 unusedStake + newStake >> 
 	 Round round =11 _getLastRound () >> 
 	 
 Ift ( round ^^ stake + investStake > m_maxRoundStake ) { return false >> 
 	 
 } 
 _setLastRound (( _roundAddStakeAndVesting (( round , addr , investStake , 0 )) )) >> 
 	 stakeholder =_stakeholderDecreaseUnusedStake (( stakeholder , unusedStake )) >> 
 	 
 Ife ( newStake > 0 ) { stakeholder =11 _stakeholderUpdateStake2 (( stakeholder , newStake , reinvest )) >> 
 	 
 } 
 else 
 { 
 stakeholder =11 _stakeholderSetReinvest2 (( stakeholder , reinvest )) >> 
 	 
 } 
 _setOrDeleteStakeholder (( addr , stakeholder )) >> 
 	 return true >> 
 	 
 } 
 .
Definition StakingContract_Ф__requestStakesSigning ( round : ι_Round ) : StakingContract ι_Round := 
 { 
 uint64 roundStake =13 round ^^ stake >> 
 	 uint32 currentElectAt =13 round ^^ id >> 
 	 bool roundStakeCheck =11 roundStake >= m_minRoundStake >> 
 	 bool nodeStakeCheck =11 getTotalStake (( round ^^ stakes [ wallet ] )) >= (( m_minRoundStake * NODE_WALLET_MIN_STAKE )) / 100 >> 
 	 bool canParticipate =11 ! _isElectionOver (( currentElectAt )) && roundStakeCheck && nodeStakeCheck >> 
 	 
 Ife ( canParticipate ) { stake =11 roundStake >> 
 	 emit stakeSigningRequested (( currentElectAt )) >> 
 	 (( bool exists , Request request )) =11 fetch (( currentElectAt )) >> 
 	 
 Ife ( exists ) { round ^^ step =31 STEP_ELECTIONS >> 
 	 _runForElection (( request , roundStake )) >> 
 	 
 } 
 else 
 { 
 round ^^ step =31 STEP_WAITING_REQUESTS >> 
 	 
 } 
 
 } 
 else 
 { 
 uint8 completionStatus =11 ! roundStakeCheck ? ROUND_NOT_ENOUGH_TOTAL_STAKE : ROUND_NODE_STAKE_TOO_SMALL >> 
 	 round =11 _completeRoundAndSetCompletionStatus (( round , completionStatus )) >> 
 	 
 } 
 return round >> 
 	 
 } 
 .
Definition StakingContract_Ф__addRequest ( stakeAt : XInteger32 )( request : ι_Request ) : StakingContract True := 
 { 
 require (( ! exists (( stakeAt )) , 112 )) >> 
 	 m_requests [ stakeAt ] =51 request >> 
 	 
 } 
 .
Definition StakingContract_Ф__acceptPendingRoundStake ( pendingId : XInteger32 ) : StakingContract True := 
 { 
 (( bool exists , Round round )) =11 _removePendingRound (( pendingId )) >> 
 	 
 Ift ( exists ) { _completeRoundAndSetCompletionStatus (( round , ROUND_RECEIVED_REWARD )) >> 
 	 
 } 
 
 } 
 .
Definition StakingContract_Ф__acceptUnusedStake : StakingContract True := 
 { 
 Round lb1round =11 _getPenultimateRound () >> 
 	 
 Ife ( msg ^^ value >= lb1round ^^ stake ) { _setPenultimateRound (( _completeRoundAndSetCompletionStatus (( lb1round , ROUND_LOST_ELECTIONS )) )) >> 
 	 m_minRoundStake + =12 m_minRoundStake / 4 >> 
 	 
 } 
 else 
 { 
 lb1round ^^ unused =31 uint64 (( msg ^^ value )) >> 
 	 m_minRoundStake =23 lb1round ^^ stake - lb1round ^^ unused + ROUND_UP_VALUE >> 
 	 
 } 
 
 } 
 .
Definition StakingContract_Ф__acceptRewardStake : StakingContract True := 
 { 
 Round oldestRound =11 _getOldestRound () >> 
 	 uint64 roundStake =13 oldestRound ^^ stake - oldestRound ^^ unused >> 
 	 uint64 totalReward =10 0 >> 
 	 
 Ift ( uint64 (( msg ^^ value )) >= roundStake ) { totalReward =11 uint64 (( msg ^^ value )) - roundStake >> 
 	 
 } 
 uint64 roundReward =11 uint64 (( (( totalReward * NOM_FRACTION )) / 100 )) >> 
 	 uint64 ownerReward =11 uint64 (( (( totalReward * NODE_FRACTION )) / 100 )) >> 
 	 _increaseOwnerReward (( ownerReward )) >> 
 	 oldestRound ^^ rewards =31 roundReward >> 
 	 m_lastRoundInterest =21 _calcLastRoundInterest (( roundStake , roundReward )) >> 
 	 _setOldestRound (( _completeRoundAndSetCompletionStatus (( oldestRound , ROUND_RECEIVED_REWARD )) )) >> 
 	 
 } 
 .
Definition StakingContract_Ф__completeRound ( completedRound : ι_Round )( chunkSize : XInteger8 ) : StakingContract ι_Round := 
 { 
 completedRound ^^ step =31 STEP_COMPLETING >> 
 	 completedRound ^^ end =31 uint32 (( now )) >> 
 	 _setOrDeletePendingRound (( completedRound )) >> 
 	 tvm ^^ accept () >> 
 	 tvm ^^ commit () >> 
 	 completedRound =11 _completePendingRound (( completedRound , chunkSize )) >> 
 	 _setOrDeletePendingRound (( completedRound )) >> 
 	 delete completedRound ^^ stakes >> 
 	 return completedRound >> 
 	 
 } 
 .
Definition StakingContract_Ф__completePendingRound ( pendingRound : ι_Round )( chunkSize : XInteger8 ) : StakingContract ι_Round := 
 { 
 
 Ife ( pendingRound ^^ participantQty > chunkSize ) { for (( uint i =10 0 >> 
 	 i < pendingRound ^^ participantQty >> 
 	 i + =11 chunkSize ) { this ^^ completePendingRoundChunk . value (( 1e7 )) (( pendingRound ^^ id , chunkSize )) >> 
 	 
 } 
 
 } 
 else 
 { 
 pendingRound =11 _returnOrReinvest (( pendingRound , chunkSize )) >> 
 	 
 } 
 return pendingRound >> 
 	 
 } 
 .
Definition StakingContract_Ф__completeRoundAndSetCompletionStatus ( round : ι_Round )( completionStatus : XInteger8 ) : StakingContract ι_Round := 
 { 
 round ^^ completionStatus =31 completionStatus >> 
 	 return _completeRound (( round , MAX_MSGS_PER_TR )) >> 
 	 
 } 
 .
Definition StakingContract_Ф__getStakeAndFeeAndUpdateMinStakeIfNeeded ( stake : XInteger64 )( reward : XInteger64 )( roundStake : XInteger64 )( roundRewards : XInteger64 ) : StakingContract ( XInteger64 # XInteger64 ) := 
 { 
 
 Ife ( NOTIFY_FEE < stake + reward ) { 
 Ift ( reward ! =10 0 && NOTIFY_FEE > reward ) { m_minStake =21 uint64 (( (( roundStake * NOTIFY_FEE )) / roundRewards )) >> 
 	 
 } 
 return (( stake + reward - NOTIFY_FEE , NOTIFY_FEE )) >> 
 	 
 } 
 else 
 { 
 return (( 0 , stake + reward )) >> 
 	 
 } 
 
 } 
 .
Definition StakingContract_Ф_getNewStakeAndFees ( roundRewards : XInteger64 )( roundStake : XInteger64 )( stake : XInteger64 ) : StakingContract ( XInteger64 # XInteger64 # XInteger64 ) := 
 { 
 
 Ift ( stake == 0 ) { return (( 0 , 0 , 0 )) >> 
 	 
 } 
 uint64 reward =11 (( roundStake ! =10 0 )) ? uint64 (( roundRewards * stake / roundStake )) : 0 >> 
 	 (( uint64 stakeAndReward , uint64 fee )) =11 _getStakeAndFeeAndUpdateMinStakeIfNeeded (( stake , reward , roundStake , roundRewards )) >> 
 	 return (( reward , stakeAndReward , fee )) >> 
 	 
 } 
 .
Definition StakingContract_Ф__returnOrReinvestForStakeholder ( completedRound : ι_Round )( lastRound : ι_Round )( addr : XAddress )( stake : ι_StakeValue ) : StakingContract ι_Round := 
 { 
 uint64 roundRewards =13 completedRound ^^ rewards >> 
 	 uint64 roundStake =13 completedRound ^^ stake >> 
 	 Stakeholder stakeholder =11 _getStakeholder (( addr )) >> 
 	 bool reinvest =13 stakeholder ^^ reinvest >> 
 	 (( uint64 stakeReward , uint64 newStake , uint64 stakeFee )) =11 getNewStakeAndFees (( roundRewards , roundStake , stake ^^ simple )) >> 
 	 (( uint64 vestingReward , uint64 vestingAndReward , uint64 vestingFee )) =11 getNewStakeAndFees (( roundRewards , roundStake , stake ^^ vesting )) >> 
 	 uint64 pureVestingReward =11 vestingAndReward >= stake ^^ vesting? vestingAndReward - stake ^^ vesting : 0 >> 
 	 uint64 newVesting =13 tvm ^^ min (( vestingAndReward - pureVestingReward , stake ^^ vesting )) >> 
 	 stakeholder =11 _stakeholderUpdateGrossReward (( stakeholder , stakeReward + vestingReward )) >> 
 	 stakeholder =11 _stakeholderUpdateTotalStake (( stakeholder , newStake + vestingAndReward , stake ^^ simple + stake ^^ vesting )) >> 
 	 uint64 withdrawalVesting =10 0 >> 
 	 // Amount of locked vesting that can be unlocked ^^ if (( stake ^^ vesting ! =10 0 ) { uint64 periodQty =11 (( uint64 (( now )) - stakeholder ^^ lastPaymentUnixTime )) / stakeholder ^^ withdrawalPeriod >> 
 	 withdrawalVesting =13 tvm ^^ min (( periodQty * stakeholder ^^ periodPayment , newVesting )) >> 
 	 newVesting -= withdrawalVesting >> 
 	 stakeholder =11 _stakeholderUpdateLastPaymentTime (( stakeholder , periodQty )) >> 
 	 
 Ift ( newVesting < m_minStake ) { stakeholder =11 _stakeholderIncreaseUnusedStake (( stakeholder , newVesting )) >> 
 	 stakeholder =11 _stakeholderResetVesting (( stakeholder )) >> 
 	 newVesting =10 0 >> 
 	 
 } 
 
 } 
 newStake + =11 withdrawalVesting + pureVestingReward >> 
 	 uint64 attachedValue >> 
 	 
 Ife ( m_poolClosed ) { attachedValue =11 newStake + stakeholder ^^ unusedStake >> 
 	 stakeholder =11 _stakeholderDecreaseTotalAndUnused (( stakeholder , newStake + newVesting + stakeholder ^^ unusedStake , stakeholder ^^ unusedStake )) >> 
 	 
 Ift ( newVesting ! =10 0 && stakeholder ^^ vestingOwner ! =11 address (( 0 )) ) { stakeholder ^^ vestingOwner . transfer (( 
 { 
 value: newVesting , flag: 3 
 } 
 )) >> 
 	 
 } 
 stakeholder =11 _stakeholderResetVesting (( stakeholder )) >> 
 	 
 } 
 else 
 { 
 attachedValue =10 1 >> 
 	 
 Ife ( reinvest ) { lastRound =11 _roundAddStakeAndVesting (( lastRound , addr , newStake , newVesting )) >> 
 	 
 } 
 else 
 { 
 stakeholder =11 _stakeholderIncreaseUnusedStake (( stakeholder , newStake )) >> 
 	 lastRound =11 _roundAddStakeAndVesting (( lastRound , addr , 0 , newVesting )) >> 
 	 
 } 
 
 } 
 _setOrDeleteStakeholder (( addr , stakeholder )) >> 
 	 IParticipant (( addr )) . receiveRewardStake 
 { 
 value: attachedValue , flag: 3 
 } 
 (( completedRound ^^ id , stakeReward + vestingReward , newStake + newVesting , // TODO new stake // TODO add vesting params separate reinvest , stakeFee + vestingFee , completedRound ^^ completionStatus )) >> 
 	 return lastRound >> 
 	 
 } 
 .
Definition StakingContract_Ф__returnOrReinvest ( completedRound : ι_Round )( chunkSize : XInteger8 ) : StakingContract ι_Round := 
 { 
 mapping (( address => StakeValue )) stakes =13 completedRound ^^ stakes >> 
 	 Round lastRound =11 _getLastRound () >> 
 	 uint sentMsgs =10 0 >> 
 	 while (( ! stakes ^^ empty () && sentMsgs < chunkSize ) { sentMsgs + + >> 
 	 (( address addr , StakeValue stake )) =13 stakes ^^ delMin () >> 
 	 lastRound =11 _returnOrReinvestForStakeholder (( completedRound , lastRound , addr , stake )) >> 
 	 
 } 
 
 Ift ( completedRound ^^ id ! =13 lastRound ^^ id ) { _setLastRound (( lastRound )) >> 
 	 
 } 
 completedRound ^^ step =33 stakes ^^ empty () ? STEP_COMPLETED : STEP_COMPLETING >> 
 	 completedRound ^^ stakes =31 stakes >> 
 	 return completedRound >> 
 	 
 } 
 .
Definition StakingContract_Ф__getStakeAndSendErrorIfNeeded : StakingContract ( XInteger64 # XBool ) := 
 { 
 ok =11 true >> 
 	 uint64 msgValue =11 uint64 (( msg ^^ value )) >> 
 	 uint64 minRequiredValue =12 m_minStake + ADD_STAKE_FEE >> 
 	 
 Ift ( msgValue < minRequiredValue ) { _returnError (( STATUS_STAKE_TOO_SMALL , minRequiredValue )) >> 
 	 return (( 0 , false )) >> 
 	 
 } 
 
 Ift ( m_poolClosed ) { _returnError (( STATUS_POOL_CLOSED , 0 )) >> 
 	 return (( 0 , false )) >> 
 	 
 } 
 
 Ift ( _getRoundsCount () == 0 ) { _returnError (( STATUS_NO_ACTIVE_ROUNDS , 0 )) >> 
 	 return (( 0 , false )) >> 
 	 
 } 
 return (( msgValue - ADD_STAKE_FEE , true )) >> 
 	 
 } 
 .
Definition StakingContract_Ф_addStake ( reinvest : XBool ) : StakingContract True := 
 { 
 (( uint64 stake , bool ok )) =11 _getStakeAndSendErrorIfNeeded () >> 
 	 
 Ift ( ! ok ) { return >> 
 	 
 } 
 
 Ift ( ! _investStake (( msg ^^ sender , reinvest? MAX_MONEY_VALUE : 0 , stake , reinvest )) ) { Round round =11 _getLastRound () >> 
 	 return _returnError (( STATUS_ROUND_STAKE_LIMIT , m_maxRoundStake - round ^^ stake )) >> 
 	 
 } 
 _returnConfirmation (( ADD_STAKE_FEE )) >> 
 	 
 } 
 .
Definition StakingContract_Ф_addVesting ( dest : XAddress )( withdrawalPeriod : XInteger32 )( totalPeriod : XInteger32 ) : StakingContract True := 
 { 
 require (( dest ^^ isStdAddrWithoutAnyCast () , 119 )) >> 
 	 
 Ift ( dest == address (( 0 )) ) { dest =13 msg ^^ sender >> 
 	 
 } 
 (( uint64 stake , bool ok )) =11 _getStakeAndSendErrorIfNeeded () >> 
 	 
 Ift ( ! ok ) { return >> 
 	 
 } 
 Round round =11 _getLastRound () >> 
 	 
 Ift ( round ^^ stake + stake > m_maxRoundStake ) { return _returnError (( STATUS_ROUND_STAKE_LIMIT , m_maxRoundStake - round ^^ stake )) >> 
 	 
 } 
 
 Ift ( withdrawalPeriod > totalPeriod ) { return _returnError (( STATUS_WITHDRAWAL_PERIOD_GREATER_TOTAL_PERIOD , 0 )) >> 
 	 
 } 
 
 Ift ( totalPeriod >= 100 * (( 365 days )) ) { // 100 years return _returnError (( STATUS_TOTAL_PERIOD_MORE_100YEARS , 0 )) >> 
 	 
 } 
 
 Ift ( withdrawalPeriod == 0 ) { return _returnError (( STATUS_WITHDRAWAL_PERIOD_IS_ZERO , 0 )) >> 
 	 
 } 
 
 Ift ( totalPeriod % withdrawalPeriod ! =10 0 ) { return _returnError (( STATUS_TOTAL_PERIOD_IS_NOT_DIVED_BY_WITHDRAWAL_PERIOD , 0 )) >> 
 	 
 } 
 Stakeholder stakeholder =11 _getStakeholder (( dest )) >> 
 	 
 Ift ( _haveVesting (( stakeholder )) ) { return _returnError (( STATUS_STAKEHOLDER_HAVE_ALREADY_VESTING , 0 )) >> 
 	 
 } 
 uint64 periodPayment =11 uint64 (( uint (( stake )) * withdrawalPeriod / totalPeriod )) >> 
 	 
 Ift ( periodPayment == 0 ) { return _returnError (( STATUS_PERIOD_PAYMENT_IS_ZERO , 0 )) >> 
 	 
 } 
 stakeholder =11 _stakeholderSetVesting (( stakeholder , stake , withdrawalPeriod , periodPayment , msg ^^ sender )) >> 
 	 _setOrDeleteStakeholder (( dest , stakeholder )) >> 
 	 _setLastRound (( _roundAddStakeAndVesting (( round , dest , 0 , stake )) )) >> 
 	 _returnConfirmation (( ADD_STAKE_FEE )) >> 
 	 
 } 
 .
Definition StakingContract_Ф_removeStake ( stake : XInteger64 ) : StakingContract True := 
 { 
 
 Ift ( msg ^^ value < REMOVE_STAKE_FEE ) { _returnError (( STATUS_MSG_VAL_TOO_SMALL , REMOVE_STAKE_FEE )) >> 
 	 return >> 
 	 
 } 
 Stakeholder member =11 _getStakeholder (( msg ^^ sender )) >> 
 	 uint64 removedStake =13 tvm ^^ min (( stake , member ^^ unusedStake )) >> 
 	 _stakeholderRemoveStake (( msg ^^ sender , removedStake , removedStake )) >> 
 	 msg ^^ sender . transfer (( removedStake , true , 3 )) >> 
 	 
 } 
 .
Definition StakingContract_Ф_continueStake ( amount : XInteger64 )( reinvest : XBool ) : StakingContract True := 
 { 
 
 Ift ( msg ^^ value < CONTINUE_STAKE_FEE ) { return _returnError (( STATUS_MSG_VAL_TOO_SMALL , CONTINUE_STAKE_FEE )) >> 
 	 
 } 
 
 Ift ( ! _stakeholderExists (( msg ^^ sender )) ) { return _returnError (( STATUS_NO_STAKE , 0 )) >> 
 	 
 } 
 
 Ift ( ! _investStake (( msg ^^ sender , amount == 0? MAX_MONEY_VALUE : amount , 0 , reinvest )) ) { Round round =11 _getLastRound () >> 
 	 return _returnError (( STATUS_ROUND_STAKE_LIMIT , m_maxRoundStake - round ^^ stake )) >> 
 	 
 } 
 _returnConfirmation (( CONTINUE_STAKE_FEE )) >> 
 	 
 } 
 .
Definition StakingContract_Ф_setReinvest ( flag : XBool ) : StakingContract True := 
 { 
 address sender =13 msg ^^ sender >> 
 	 require (( _stakeholderExists (( sender )) , 101 )) >> 
 	 _stakeholderSetReinvest (( sender , flag )) >> 
 	 
 } 
 .
Definition StakingContract_Ф_transferStake ( destination : XAddress )( amount : XInteger64 ) : StakingContract True := 
 { 
 address sender =13 msg ^^ sender >> 
 	 (( bool exists , Stakeholder donor )) =11 _stakeholderFetch (( sender )) >> 
 	 require (( exists , 101 )) >> 
 	 require (( destination ^^ isStdAddrWithoutAnyCast () && ! destination ^^ isStdZero () , 119 )) >> 
 	 
 Ift ( msg ^^ value < TRANSFER_STAKE_FEE ) { return _returnError (( STATUS_MSG_VAL_TOO_SMALL , TRANSFER_STAKE_FEE )) >> 
 	 
 } 
 
 Ift ( ! arePendingRoundsEmpty () ) { return _returnError (( STATUS_NO_TRANSFER_WHILE_PENDING_ROUND , 0 )) >> 
 	 
 } 
 
 Ift ( m_poolClosed ) { return _returnError (( STATUS_POOL_CLOSED , 0 )) >> 
 	 
 } 
 
 Ift ( amount == 0 ) { amount =11 MAX_MONEY_VALUE >> 
 	 
 } 
 Stakeholder receiver =11 _getStakeholder (( destination )) >> 
 	 uint64 transferredStake =11 _roundMoveStakes (( sender , destination , amount )) >> 
 	 uint64 transferredUnused =13 tvm ^^ min (( amount - transferredStake , donor ^^ unusedStake )) >> 
 	 uint64 transferred =11 transferredStake + transferredUnused >> 
 	 donor =11 _stakeholderDecreaseTotalAndUnused (( donor , transferred , transferredUnused )) >> 
 	 receiver =11 _stakeholderIncreaseTotalAndUnused (( receiver , transferred , transferredUnused )) >> 
 	 _setOrDeleteStakeholder (( sender , donor )) >> 
 	 _setOrDeleteStakeholder (( destination , receiver )) >> 
 	 _returnConfirmation (( TRANSFER_STAKE_FEE )) >> 
 	 
 } 
 .
Definition StakingContract_Ф_processNewStake ( queryId : XInteger64 )( validatorKey : XInteger256 )( stakeAt : XInteger32 )( maxFactor : XInteger32 )( adnlAddr : XInteger256 )( signature : XInteger8 ) : StakingContract True := 
 { 
 require (( wallet == msg ^^ sender , 113 )) >> 
 	 Request request =11 Request (( queryId , validatorKey , stakeAt , maxFactor , adnlAddr , signature )) >> 
 	 _addRequest (( stakeAt , request )) >> 
 	 
 Ife ( stakeAt == _getElectAt () ) { 
 } 
 else 
 { 
 require (( _getRoundsCount () >= 2 , 111 )) >> 
 	 Round round =11 _getPenultimateRound () >> 
 	 require (( round ^^ step == STEP_WAITING_REQUESTS , 118 )) >> 
 	 require (( stakeAt == round ^^ id , 111 )) >> 
 	 _runForElection (( request , stake )) >> 
 	 round ^^ step =31 STEP_ELECTIONS >> 
 	 _setPenultimateRound (( round )) >> 
 	 
 } 
 _returnGrams () >> 
 	 
 } 
 .
Definition StakingContract_Ф_ticktock : StakingContract True := 
 { 
 bool electionsStarted =11 now >= _getElectionsStart () >> 
 	 
 Ife ( electionsStarted ) { _addNewRoundAndUpdateRounds () >> 
 	 
 } 
 else 
 Ife ( _getRoundsCount () < 2 ) { // electionsStarted == false 
 Ife ( _getRoundsCount () == 0 )) _addNewRoundAndUpdateRounds () >> 
 	 
 } 
 else 
 Ife ( _checkPenultimateRound () ) { 
 } 
 else 
 Ift ( _checkOldestRound () ) { 
 } 
 _returnGrams () >> 
 	 
 } 
 .
Definition StakingContract_Ф_forceCompletePendingRound ( doCompleteOneChunk : XBool )( chunkSize : XInteger8 ) : StakingContract True := 
 { 
 (( , Round round , bool ok )) =11 _fetchOldestPendingRound () >> 
 	 require (( ok , 121 )) >> 
 	 // at least one pending round must exists require (( round ^^ end + 1 hours < now , 122 )) >> 
 	 tvm ^^ accept () >> 
 	 
 Ife ( doCompleteOneChunk ) { round =11 _returnOrReinvest (( round , chunkSize )) >> 
 	 
 } 
 else 
 { 
 round =11 _completePendingRound (( round , chunkSize )) >> 
 	 
 } 
 _setOrDeletePendingRound (( round )) >> 
 	 
 } 
 .
Definition StakingContract_Ф_completePendingRoundChunk ( roundId : XInteger32 )( chunkSize : XInteger8 ) : StakingContract True := 
 { 
 require (( msg ^^ sender == address (( this )) , 120 )) >> 
 	 (( bool exists , Round round )) =11 _roundFetchPendingRound (( roundId )) >> 
 	 
 Ift ( exists ) { tvm ^^ accept () >> 
 	 _setOrDeletePendingRound (( _returnOrReinvest (( round , chunkSize )) )) >> 
 	 
 } 
 
 } 
 .
Definition StakingContract_Ф_receiveConfirmation ( queryId : XInteger64 )( comment : XInteger32 ) : StakingContract True := 
 { 
 require (( comment == 0 , 110 )) >> 
 	 require (( queryId >= 0 , 110 )) >> 
 	 
 } 
 .
Definition StakingContract_Ф_receiveReturnedStake ( queryId : XInteger64 )( comment : XInteger32 ) : StakingContract ( XInteger64 # XInteger32 ) := 
 { 
 Round round =11 _getPenultimateRound () >> 
 	 round ^^ completionStatus =31 ROUND_STAKE_REJECTED >> 
 	 _setPenultimateRound (( _completeRound (( _getPenultimateRound () , MAX_MSGS_PER_TR )) )) >> 
 	 return (( queryId , comment )) >> 
 	 
 } 
 .
Definition StakingContract_Ф_acceptRecoveredStake ( queryId : XInteger64 ) : StakingContract True := 
 { 
 
 Ife ( queryId == 0 ) { _acceptUnusedStake () >> 
 	 
 } 
 else 
 Ife ( queryId == 1 ) { _acceptRewardStake () >> 
 	 
 } 
 else 
 { 
 _acceptPendingRoundStake (( uint32 (( queryId )) )) >> 
 	 
 } 
 
 } 
 .
Definition StakingContract_Ф_terminator ( chunkSize : XInteger8 ) : StakingContract True := 
 { 
 require (( ! m_poolClosed , 114 )) >> 
 	 m_poolClosed =21 true >> 
 	 tvm ^^ accept () >> 
 	 
 Ift ( _getRoundsCount () ! =10 0 ) { Round lastRound =11 _getLastRound () >> 
 	 lastRound ^^ completionStatus =31 ROUND_POOL_CLOSED >> 
 	 _setLastRound (( _completeRound (( lastRound , chunkSize )) )) >> 
 	 
 } 
 emit stakingPoolClosed () >> 
 	 
 } 
 .
Definition DePool_Ф_getOwnerReward : DePool XInteger64 := 
 { 
 reward =11 reward >> 
 	 
 } 
 .
Definition DePool_Ф_getRounds : DePool ( XInteger32 # XInteger32 # ) := 
 { 
 infos =11 _getRoundsInfo () >> 
 	 count =11 _getRoundsCount () >> 
 	 lastRound =11 _getElectAt () >> 
 	 
 } 
 .
Definition DePool_Ф_getStakeholderInfo ( addr : XAddress ) : DePool ( XInteger64 # XInteger64 # XInteger64 # XBool # XInteger64 # ) := 
 { 
 require (( _stakeholderExists (( addr )) , 116 )) >> 
 	 Stakeholder stakeholder =11 _getStakeholder (( addr )) >> 
 	 reinvest =13 stakeholder ^^ reinvest >> 
 	 total =13 stakeholder ^^ totalStake >> 
 	 reward =13 stakeholder ^^ grossReward >> 
 	 available =13 stakeholder ^^ unusedStake >> 
 	 invested =11 total - available >> 
 	 uint64 invested2 =10 0 >> 
 	 // This for debugging (( uint64 index , Round round , bool ok )) =11 min () >> 
 	 while (( ok ) { 
 Ife ( round ^^ step < STEP_COMPLETED ) { (( bool presents , StakeValue value )) =13 round ^^ stakes . fetch (( addr )) >> 
 	 
 Ift ( presents ) { stakes ^^ push (( StakeInfo (( round ^^ id , value ^^ simple , value ^^ vesting )) )) >> 
 	 invested2 + =13 value ^^ simple + value ^^ vesting >> 
 	 
 } 
 
 } 
 else 
 { 
 (( bool presents , StakeValue value )) =13 round ^^ stakes . fetch (( addr )) >> 
 	 
 Ift ( presents ) { invested2 + =13 value ^^ simple + value ^^ vesting >> 
 	 
 } 
 
 } 
 (( index , round , ok )) =11 next (( index )) >> 
 	 
 } 
 (( index , round , ok )) =11 min () >> 
 	 while (( ok ) { (( bool presents , StakeValue value )) =13 round ^^ stakes . fetch (( addr )) >> 
 	 
 Ift ( presents ) { invested2 + =13 value ^^ simple + value ^^ vesting >> 
 	 
 } 
 (( index , round , ok )) =11 next (( uint32 (( index )) )) >> 
 	 
 } 
 
 } 
 .
Definition DePool_Ф_getMinStake : DePool XInteger64 := 
 { 
 minStake =12 m_minStake >> 
 	 
 } 
 .
Definition DePool_Ф_getStakingInfo : DePool ( XInteger64 # XInteger64 # XInteger64 # XInteger64 # XInteger32 # XInteger64 # XInteger64 # XInteger64 # XInteger64 # XInteger64 # XInteger64 # XInteger64 ) := 
 { 
 minStake =12 m_minStake >> 
 	 minRoundStake =12 m_minRoundStake >> 
 	 maxRoundStake =12 m_maxRoundStake >> 
 	 stakingPeriod =11 _getStakingPeriod () >> 
 	 interest =12 m_lastRoundInterest >> 
 	 notifyFee =11 NOTIFY_FEE >> 
 	 addFee =11 ADD_STAKE_FEE >> 
 	 removeFee =11 REMOVE_STAKE_FEE >> 
 	 pauseFee =11 PAUSE_STAKE_FEE >> 
 	 continueFee =11 CONTINUE_STAKE_FEE >> 
 	 setReinvestFee =11 SET_REINVEST_FEE >> 
 	 minNodeStake =11 (( m_minRoundStake * NODE_WALLET_MIN_STAKE )) / 100 >> 
 	 
 } 
 .
Definition DePool_Ф_getValidator : DePool ι_Node := 
 { 
 validator =12 m_node >> 
 	 
 } 
 .
Definition DePool_Ф_getPendingRounds : DePool True := 
 { 
 infos =11 _getPendingRoundsInfo () >> 
 	 
 } 
 .
