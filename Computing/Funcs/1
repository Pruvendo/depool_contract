all.v:Definition Participant_Ф_receiveRewardStake ( $ Л_roundId : XInteger32 )( $ Л_reward : XInteger64 )( $ Л_stake : XInteger64 )( $ Л_reinvest : XBool )( $ Л_fee : XInteger64 )( $ Л_reason : XInteger8 ) : ParticipantT True 
all.v:Definition Participant_Ф_receiveAnswer ( $ Л_errcode : XInteger32 )( $ Л_comment : XInteger64 ) : ParticipantT True 
all.v:Definition Participant_Ф_receiveRewardStake ( $ Л_roundId : XInteger32 )( $ Л_reward : XInteger64 )( $ Л_stake : XInteger64 )( $ Л_reinvest : XBool )( $ Л_fee : XInteger64 )( $ Л_reason : XInteger8 ) : ParticipantT True 
all.v:Definition Participant_Ф_receiveAnswer ( $ Л_errcode : XInteger32 )( $ Л_comment : XInteger64 ) : ParticipantT True 
all.v:Definition StakingProxyContract_Ф_process_new_stake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_validatorKey : XInteger256 )( $ Л_stakeAt : XInteger32 )( $ Л_maxFactor : XInteger32 )( $ Л_adnlAddr : XInteger256 )( $ Л_signature : XInteger8 ) : StakingProxyContractT := 
all.v: 	 IElector (( ElectorBase_ι_m_elector )) . _Ф_elector_process_new_stake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId , $ Л_validatorKey , $ Л_stakeAt , $ Л_maxFactor , $ Л_adnlAddr , $ Л_signature )) ) >> 
all.v:Definition StakingProxyContract_Ф_recover_stake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 ) : StakingProxyContractT := 
all.v: 	 IElector (( ElectorBase_ι_m_elector )) . _Ф_elector_recover_stake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId )) ) >> 
all.v:Definition StakingContract_Ф_receiveConfirmation ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_comment : XInteger32 ) : StakingContractT := 
all.v: 	 require (( $ Л_comment ?== $ xInt0 , $ xInt110 )) ) >> 
all.v: 	 require (( $ Л_queryId ?>= $ xInt0 , $ xInt110 )) ) >> 
all.v:Definition StakingContract_Ф_receiveReturnedStake ( $ Л_queryId : XInteger64 )( $ Л_comment : XInteger32 ) : StakingContractT XInteger64 # XInteger32 := 
all.v: ( d0! Л_round := RoundsBase_Ф__getPenultimateRound () ) >> 
all.v: 	 ( d2! Л_round ^^ RoundsBase_ι_Round_ι_completionStatus := RoundsBase_ι_ROUND_STAKE_REJECTED ) >> 
all.v: 	 return (( $ Л_queryId , $ Л_comment )) ) >> 
all.v:Definition StakingContract_Ф_acceptRecoveredStake ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 ) : StakingContractT := 
all.v: Ife ( $ Л_queryId ?== $ xInt0 ) { StakingContract_Ф__acceptUnusedStake () ) >> 
all.v: Ife ( $ Л_queryId ?== $ xInt1 ) { StakingContract_Ф__acceptRewardStake () ) >> 
all.v: StakingContract_Ф__acceptPendingRoundStake (( uint32 (( $ Л_queryId )) )) ) >> 
all.v: 	 ( d0! Л_electionsStarted := now ?>= ElectionParams_Ф__getElectionsStart () ) >> 
all.v: Ife ( $ Л_electionsStarted ) { StakingContract_Ф__addNewRoundAndUpdateRounds () ) >> 
all.v:Definition Stakeholder_Ф_sendTransaction ( $ Л_dest : XAddress )( $ Л_value : XInteger64 )( $ Л_bounce : XBool )( $ Л_flags : XInteger16 )( $ Л_payload : TvmCell ) : StakeholderT := 
all.v: 	 $ Л_dest ^^ transfer (( $ Л_value , $ Л_bounce , $ Л_flags , $ Л_payload )) ) >> 
all.v:Definition OwnerBase_Ф_Constructor2 ( $ Л_poolOwnerAddr : XAddress ) : OwnerBaseT := 
all.v: ( d1! OwnerBase_ι_m_owner := OwnerBase_ι_Owner (( $ Л_poolOwnerAddr , $ xInt0 )) ) >> 
all.v:Definition OwnerBase_Ф_withdrawOwnerReward ( msg_sender : XInteger ) ( $ Л_amount : XInteger64 ) : OwnerBaseT := 
all.v: 	 require (( $ Л_amount ?<= OwnerBase_ι_Owner_ι_reward , $ xInt105 )) ) >> 
all.v: 	 ( d1! OwnerBase_ι_Owner_ι_reward -= $ Л_amount ) >> 
all.v: 	 OwnerBase_ι_Owner_ι_addr . transfer (( $ Л_amount , $ xBoolTrue , $ xInt3 )) ) >> 
all.v:Definition OwnerBase_Ф__increaseOwnerReward ( $ Л_ownerReward : XInteger64 ) : OwnerBaseT := 
all.v: ( d1! OwnerBase_ι_Owner_ι_reward += $ Л_ownerReward ) >> 
all.v:Definition ElectorBase_Ф_Constructor3 ( $ Л_electorAddr : XAddress ) : ElectorBaseT := 
all.v: ( d1! ElectorBase_ι_m_elector := $ Л_electorAddr ) >> 
all.v: (( _ , , $ Л_utime_until , _ , , _ , , $ Л_ok )) := tvm_configParam (( $ xInt34 )) ) >> 
all.v: Ift ( ! $ Л_ok ) { ( d0! Л_offset := (( (( uint32 (( now )) - (( ElectionParams_ι_m_electAt - ElectionParams_ι_m_beginBefore )) )) / ElectionParams_ι_m_electedFor + $ xInt1 )) * ElectionParams_ι_m_electedFor ) >> 
all.v: 	 ( d0! Л_utime_until := ElectionParams_ι_m_electAt + $ Л_offset ) >> 
all.v: return $ Л_utime_until ) >> 
all.v:Definition ElectionParams_Ф__isElectionOver ( $ Л_currentElectAt : XInteger32 ) : ElectionParamsT XBool := 
all.v: return now ?>= (( $ Л_currentElectAt - ElectionParams_ι_m_endBefore )) ) >> 
all.v:Definition StakeholderBase_Ф__haveVesting ( $ Л_stakeholder : ι_Stakeholder ) : StakeholderBaseT XBool := 
all.v: return $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_periodPayment ?!= $ xInt0 ) >> 
all.v:Definition StakeholderBase_Ф__stakeholderSetVesting ( $ Л_stakeholder : ι_Stakeholder )( $ Л_stake : XInteger64 )( $ Л_withdrawalPeriod : XInteger32 )( $ Л_periodPayment : XInteger64 )( $ Л_vestingOwner : XAddress ) : StakeholderBaseT ι_Stakeholder := 
all.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake += $ Л_stake ) >> 
all.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_lastPaymentUnixTime := uint64 (( now )) ) >> 
all.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_withdrawalPeriod := $ Л_withdrawalPeriod ) >> 
all.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_periodPayment := $ Л_periodPayment ) >> 
all.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_vestingOwner := $ Л_vestingOwner ) >> 
all.v: 	 return $ Л_stakeholder ) >> 
all.v:Definition StakeholderBase_Ф__stakeholderExists ( $ Л_addr : XAddress ) : StakeholderBaseT XBool := 
all.v: return exists (( $ Л_addr )) ) >> 
all.v:Definition StakeholderBase_Ф__getStakeholder ( $ Л_addr : XAddress ) : StakeholderBaseT ι_Stakeholder := 
all.v: return StakeholderBase_ι_m_stakeholders [ $ Л_addr ] ) >> 
all.v:Definition StakeholderBase_Ф__stakeholderFetch ( $ Л_addr : XAddress ) : StakeholderBaseT XBool # ι_Stakeholder := 
all.v: return fetch (( $ Л_addr )) ) >> 
all.v:Definition StakeholderBase_Ф__setOrDeleteStakeholder ( $ Л_addr : XAddress )( $ Л_stakeholder : ι_Stakeholder ) : StakeholderBaseT := 
all.v: Ift ( $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake ?== $ xInt0 )) delete StakeholderBase_ι_m_stakeholders [ $ Л_addr ] ) >> 
all.v: 	 else ( d4! StakeholderBase_ι_m_stakeholders [ Л_addr ] := $ Л_stakeholder ) >> 
all.v:Definition StakeholderBase_Ф__stakeholderUpdateStake ( $ Л_addr : XAddress )( $ Л_totalStake : XInteger64 )( $ Л_reinvest : XBool ) : StakeholderBaseT := 
all.v: ( d0! Л_user := StakeholderBase_ι_m_stakeholders [ $ Л_addr ] ) >> 
all.v: 	 ( d2! Л_user ^^ StakeholderBase_ι_Stakeholder_ι_reinvest := $ Л_reinvest ) >> 
all.v: 	 ( d2! Л_user ^^ StakeholderBase_ι_Stakeholder_ι_totalStake += $ Л_totalStake ) >> 
all.v: 	 ( d4! StakeholderBase_ι_m_stakeholders [ Л_addr ] := $ Л_user ) >> 
all.v:Definition StakeholderBase_Ф__stakeholderUpdateStake2 ( $ Л_stakeholder : ι_Stakeholder )( $ Л_totalStake : XInteger64 )( $ Л_reinvest : XBool ) : StakeholderBaseT ι_Stakeholder := 
all.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_reinvest := $ Л_reinvest ) >> 
all.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake += $ Л_totalStake ) >> 
all.v: 	 return $ Л_stakeholder ) >> 
all.v:Definition StakeholderBase_Ф__stakeholderRemoveStake ( $ Л_addr : XAddress )( $ Л_removedStake : XInteger64 )( $ Л_unusedStake : XInteger64 ) : StakeholderBaseT := 
all.v: ( d0! Л_stakeholder := StakeholderBase_ι_m_stakeholders [ $ Л_addr ] ) >> 
all.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake -= $ Л_removedStake ) >> 
all.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake -= $ Л_unusedStake ) >> 
all.v: Ife ( $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake ?== $ xInt0 ) { delete StakeholderBase_ι_m_stakeholders [ $ Л_addr ] ) >> 
all.v: ( d4! StakeholderBase_ι_m_stakeholders [ Л_addr ] := $ Л_stakeholder ) >> 
all.v:Definition StakeholderBase_Ф__stakeholderIncreaseTotalAndUnused ( $ Л_stakeholder : ι_Stakeholder )( $ Л_deltaTotal : XInteger64 )( $ Л_deltaUnused : XInteger64 ) : StakeholderBaseT ι_Stakeholder := 
all.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake += $ Л_deltaTotal ) >> 
all.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake += $ Л_deltaUnused ) >> 
all.v: 	 return $ Л_stakeholder ) >> 
all.v:Definition StakeholderBase_Ф__stakeholderDecreaseTotalAndUnused ( $ Л_stakeholder : ι_Stakeholder )( $ Л_deltaTotal : XInteger64 )( $ Л_deltaUnused : XInteger64 ) : StakeholderBaseT ι_Stakeholder := 
all.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake -= $ Л_deltaTotal ) >> 
all.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake -= $ Л_deltaUnused ) >> 
all.v: 	 return $ Л_stakeholder ) >> 
all.v:Definition StakeholderBase_Ф__stakeholderSetReinvest ( $ Л_addr : XAddress )( $ Л_flag : XBool ) : StakeholderBaseT := 
all.v: StakeholderBase_ι_m_stakeholders [ $ Л_addr ( d2! ] ^^ StakeholderBase_ι_Stakeholder_ι_reinvest := $ Л_flag ) >> 
all.v:Definition StakeholderBase_Ф__stakeholderSetReinvest2 ( $ Л_stakeholder : ι_Stakeholder )( $ Л_flag : XBool ) : StakeholderBaseT ι_Stakeholder := 
all.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_reinvest := $ Л_flag ) >> 
all.v: 	 return $ Л_stakeholder ) >> 
all.v:Definition StakeholderBase_Ф__stakeholderUpdateGrossReward ( $ Л_stakeholder : ι_Stakeholder )( $ Л_reward : XInteger64 ) : StakeholderBaseT ι_Stakeholder := 
all.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_grossReward += $ Л_reward ) >> 
all.v: 	 return $ Л_stakeholder ) >> 
all.v:Definition StakeholderBase_Ф__stakeholderUpdateTotalStake ( $ Л_stakeholder : ι_Stakeholder )( $ Л_newStake : XInteger64 )( $ Л_oldStake : XInteger64 ) : StakeholderBaseT ι_Stakeholder := 
all.v: Ift ( $ Л_newStake ?>= $ Л_oldStake )) ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake += $ Л_newStake - $ Л_oldStake ) >> 
all.v: 	 else ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake -= $ Л_oldStake - $ Л_newStake ) >> 
all.v: 	 return $ Л_stakeholder ) >> 
all.v:Definition StakeholderBase_Ф__stakeholderUpdateUnusedStake ( $ Л_addr : XAddress )( $ Л_add : XInteger64 )( $ Л_remove : XInteger64 ) : StakeholderBaseT := 
all.v: StakeholderBase_ι_m_stakeholders [ $ Л_addr ( d2! ] ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake := (( StakeholderBase_ι_m_stakeholders [ $ Л_addr ] ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake + $ Л_add )) - $ Л_remove ) >> 
all.v:Definition StakeholderBase_Ф__stakeholderIncreaseUnusedStake ( $ Л_stakeholder : ι_Stakeholder )( $ Л_delta : XInteger64 ) : StakeholderBaseT ι_Stakeholder := 
all.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake += $ Л_delta ) >> 
all.v: 	 return $ Л_stakeholder ) >> 
all.v:Definition StakeholderBase_Ф__stakeholderDecreaseUnusedStake ( $ Л_stakeholder : ι_Stakeholder )( $ Л_delta : XInteger64 ) : StakeholderBaseT ι_Stakeholder := 
all.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake -= $ Л_delta ) >> 
all.v: 	 return $ Л_stakeholder ) >> 
all.v:Definition StakeholderBase_Ф__stakeholderResetVesting ( $ Л_stakeholder : ι_Stakeholder ) : StakeholderBaseT ι_Stakeholder := 
all.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_lastPaymentUnixTime := $ xInt0 ) >> 
all.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_withdrawalPeriod := $ xInt0 ) >> 
all.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_periodPayment := $ xInt0 ) >> 
all.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_vestingOwner := xInt0 ) >> 
all.v: 	 return $ Л_stakeholder ) >> 
all.v:Definition StakeholderBase_Ф__stakeholderUpdateLastPaymentTime ( $ Л_stakeholder : ι_Stakeholder )( $ Л_periodQty : XInteger64 ) : StakeholderBaseT ι_Stakeholder := 
all.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_lastPaymentUnixTime += $ Л_periodQty * $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_withdrawalPeriod ) >> 
all.v: 	 return $ Л_stakeholder ) >> 
all.v:Definition StakingOwner_Ф_Constructor5 ( $ Л_pool : XAddress ) : StakingOwnerT := 
all.v: 	 ( d1! StakingOwner_ι_m_stakingPool := $ Л_pool ) >> 
all.v:Definition StakingOwner_Ф_updateStakingPoolAddress ( $ Л_addr : XAddress ) : StakingOwnerT := 
all.v: 	 ( d1! StakingOwner_ι_m_stakingPool := $ Л_addr ) >> 
all.v:Definition StakingProxyContract_Ф_Constructor6 ( $ Л_staking : XAddress )( $ Л_elector : XAddress ) : StakingProxyContractT := 
all.v: 	 ( d1! StakingProxyContract_ι_m_staking := $ Л_staking ) >> 
all.v: 	 ( d1! ElectorBase_ι_m_elector := $ Л_elector ) >> 
all.v: (( $ Л_index , $ Л_round , $ Л_ok )) := min () ) >> 
all.v: 	 while (( $ Л_ok ) { infos ^^ push (( RoundsBase_ι_RoundInfo (( $ Л_round ^^ RoundsBase_ι_Round_ι_id , $ Л_round ^^ RoundsBase_ι_Round_ι_start , $ Л_round ^^ RoundsBase_ι_Round_ι_end , $ Л_round ^^ RoundsBase_ι_Round_ι_step , $ Л_round ^^ RoundsBase_ι_Round_ι_completionStatus , $ Л_round ^^ RoundsBase_ι_Round_ι_stake , $ Л_round ^^ RoundsBase_ι_Round_ι_participantQty , $ Л_round ^^ RoundsBase_ι_Round_ι_rewards )) )) ) >> 
all.v: 	 (( $ Л_index , $ Л_round , $ Л_ok )) := next (( $ Л_index )) ) >> 
all.v: (( $ Л_key , $ Л_round , $ Л_ok )) := min () ) >> 
all.v: 	 while (( $ Л_ok ) { infos ^^ push (( RoundsBase_ι_RoundInfo (( $ Л_round ^^ RoundsBase_ι_Round_ι_id , $ Л_round ^^ RoundsBase_ι_Round_ι_start , $ Л_round ^^ RoundsBase_ι_Round_ι_end , $ Л_round ^^ RoundsBase_ι_Round_ι_step , $ Л_round ^^ RoundsBase_ι_Round_ι_completionStatus , $ Л_round ^^ RoundsBase_ι_Round_ι_stake , $ Л_round ^^ RoundsBase_ι_Round_ι_participantQty , $ Л_round ^^ RoundsBase_ι_Round_ι_rewards )) )) ) >> 
all.v: 	 (( $ Л_key , $ Л_round , $ Л_ok )) := next (( $ Л_key )) ) >> 
all.v:Definition RoundsBase_Ф__addNewPoolingRound ( $ Л_validationStart : XInteger32 )( $ Л_validationPeriod : XInteger32 ) : RoundsBaseT := 
all.v: RoundsBase_ι_Round_ι_id : $ Л_validationStart , RoundsBase_ι_Round_ι_step : RoundsBase_ι_STEP_POOLING , RoundsBase_ι_Round_ι_participantQty : $ xInt0 , RoundsBase_ι_Round_ι_stake : $ xInt0 , RoundsBase_ι_Round_ι_rewards : $ xInt0 , RoundsBase_ι_Round_ι_unused : $ xInt0 , RoundsBase_ι_Round_ι_completionStatus : RoundsBase_ι_ROUND_UNDEFINED , RoundsBase_ι_Round_ι_start : uint32 (( now )) , RoundsBase_ι_Round_ι_end : $ Л_validationStart + $ Л_validationPeriod 
all.v: (( _ , $ Л_round )) := delMin () ) >> 
all.v: 	 return $ Л_round ) >> 
all.v:Definition RoundsBase_Ф__setOldestRound ( $ Л_round : ι_Round ) : RoundsBaseT := 
all.v: ( d4! RoundsBase_ι_m_rounds [ RoundsBase_ι_m_startIdx ] := $ Л_round ) >> 
all.v:Definition RoundsBase_Ф__roundAddStakeAndVesting ( $ Л_round : ι_Round )( $ Л_addr : XAddress )( $ Л_stake : XInteger64 )( $ Л_vestingStake : XInteger64 ) : RoundsBaseT ι_Round := 
all.v: ( d0! Л_totalStake := $ Л_stake + $ Л_vestingStake ) >> 
all.v: Ift ( $ Л_totalStake ?== $ xInt0 )) return $ Л_round ) >> 
all.v: Ift ( ! $ Л_round ^^ RoundsBase_ι_Round_ι_stakes . exists (( $ Л_addr )) ) { $ Л_round ^^ RoundsBase_ι_Round_ι_participantQty ++ ) >> 
all.v: ( d2! Л_round ^^ RoundsBase_ι_Round_ι_stake += $ Л_totalStake ) >> 
all.v: 	 ( d0! Л_sv := $ Л_round ^^ RoundsBase_ι_Round_ι_stakes [ $ Л_addr ] ) >> 
all.v: 	 ( d2! Л_sv ^^ RoundsBase_ι_StakeValue_ι_simple += $ Л_stake ) >> 
all.v: 	 ( d2! Л_sv ^^ RoundsBase_ι_StakeValue_ι_vesting += $ Л_vestingStake ) >> 
all.v: 	 ( d3! Л_round ^^ RoundsBase_ι_Round_ι_stakes [ Л_addr ] := $ Л_sv ) >> 
all.v: 	 return $ Л_round ) >> 
all.v:Definition RoundsBase_Ф__roundMoveStake ( $ Л_round : ι_Round )( $ Л_source : XAddress )( $ Л_destination : XAddress )( $ Л_amount : XInteger64 ) : RoundsBaseT ι_Round # XInteger64 := 
all.v: (( $ Л_exists , $ Л_sourceStake )) := $ Л_round ^^ RoundsBase_ι_Round_ι_stakes . fetch (( $ Л_source )) ) >> 
all.v: Ife ( ! $ Л_exists )) return (( $ Л_round , $ xInt0 )) ) >> 
all.v: Ife ( $ Л_sourceStake ^^ RoundsBase_ι_StakeValue_ι_simple ?>= $ Л_amount ) { ( d0! Л_newSourceStake := $ Л_sourceStake ^^ RoundsBase_ι_StakeValue_ι_simple - $ Л_amount ) >> 
all.v: 	 ( d0! Л_deltaDestinationStake := $ Л_amount ) >> 
all.v: ( d0! Л_newSourceStake := $ xInt0 ) >> 
all.v: 	 ( d0! Л_deltaDestinationStake := $ Л_sourceStake ^^ RoundsBase_ι_StakeValue_ι_simple ) >> 
all.v: Ife ( $ Л_newSourceStake ?== $ xInt0 && $ Л_round ^^ RoundsBase_ι_Round_ι_stakes [ $ Л_source ] ^^ RoundsBase_ι_StakeValue_ι_vesting ?== $ xInt0 ) { -- $ Л_round ^^ RoundsBase_ι_Round_ι_participantQty ) >> 
all.v: 	 delete $ Л_round ^^ RoundsBase_ι_Round_ι_stakes [ $ Л_source ] ) >> 
all.v: $ Л_round ^^ RoundsBase_ι_Round_ι_stakes [ $ Л_source ( d2! ] ^^ RoundsBase_ι_StakeValue_ι_simple := $ Л_newSourceStake ) >> 
all.v: Ift ( ! $ Л_round ^^ RoundsBase_ι_Round_ι_stakes . exists (( $ Л_destination )) )) $ Л_round ^^ RoundsBase_ι_Round_ι_participantQty ++ ) >> 
all.v: 	 $ Л_round ^^ RoundsBase_ι_Round_ι_stakes [ $ Л_destination ( d2! ] ^^ RoundsBase_ι_StakeValue_ι_simple += $ Л_deltaDestinationStake ) >> 
all.v: 	 return (( $ Л_round , $ Л_deltaDestinationStake )) ) >> 
all.v:Definition RoundsBase_Ф__addPendingRound ( $ Л_round : ι_Round ) : RoundsBaseT := 
all.v: RoundsBase_ι_m_pendingRounds [ $ Л_round ^^ RoundsBase_ι_Round_ι_id $ Л_round ) >> 
all.v:Definition RoundsBase_Ф__removePendingRound ( $ Л_pendingId : XInteger32 ) : RoundsBaseT XBool # ι_Round := 
all.v: (( exists , round )) := fetch (( $ Л_pendingId )) ) >> 
all.v: Ift ( exists ) { delete RoundsBase_ι_m_pendingRounds [ $ Л_pendingId ] ) >> 
all.v:Definition RoundsBase_Ф__roundFetchPendingRound ( $ Л_pendingId : XInteger32 ) : RoundsBaseT XBool # ι_Round := 
all.v: return fetch (( $ Л_pendingId )) ) >> 
all.v:Definition RoundsBase_Ф__setOrDeletePendingRound ( $ Л_round : ι_Round ) : RoundsBaseT := 
all.v: Ife ( $ Л_round ^^ RoundsBase_ι_Round_ι_step ?== RoundsBase_ι_STEP_COMPLETED ) { delete RoundsBase_ι_m_pendingRounds [ $ Л_round ^^ RoundsBase_ι_Round_ι_id ] ) >> 
all.v: RoundsBase_ι_m_pendingRounds [ $ Л_round ^^ RoundsBase_ι_Round_ι_id $ Л_round ) >> 
all.v:Definition RoundsBase_Ф__deletePendingRound ( $ Л_id : XInteger32 ) : RoundsBaseT := 
all.v: delete RoundsBase_ι_m_pendingRounds [ $ Л_id ] ) >> 
all.v:Definition RoundsBase_Ф_getTotalStake ( $ Л_stakes : ι_StakeValue ) : RoundsBaseT XInteger64 := 
all.v: return $ Л_stakes ^^ RoundsBase_ι_StakeValue_ι_simple + $ Л_stakes ^^ RoundsBase_ι_StakeValue_ι_vesting ) >> 
all.v:Definition StakingContract_Ф__calcLastRoundInterest ( $ Л_totalStake : XInteger64 )( $ Л_rewards : XInteger64 ) : StakingContractT XInteger64 := 
all.v: return (( $ Л_totalStake ?!= $ xInt0 )) ? uint64 (( (( $ Л_rewards * $ xInt100 * 1e9 )) / $ Л_totalStake ) : $ xInt0 ) >> 
all.v:Definition StakingContract_Ф__addRequest ( $ Л_stakeAt : XInteger32 )( $ Л_request : ι_Request ) : StakingContractT := 
all.v: require (( ! exists (( $ Л_stakeAt )) , $ xInt112 )) ) >> 
all.v: 	 ( d4! StakingContract_ι_m_requests [ Л_stakeAt ] := $ Л_request ) >> 
all.v:Definition StakingContract_Ф__getStakeAndFeeAndUpdateMinStakeIfNeeded ( $ Л_stake : XInteger64 )( $ Л_reward : XInteger64 )( $ Л_roundStake : XInteger64 )( $ Л_roundRewards : XInteger64 ) : StakingContractT XInteger64 # XInteger64 := 
all.v: Ife ( StakingContract_ι_NOTIFY_FEE ?< $ Л_stake + $ Л_reward ) { 
all.v: Ift ( $ Л_reward ?!= $ xInt0 && StakingContract_ι_NOTIFY_FEE ?> $ Л_reward ) { ( d1! StakingContract_ι_m_minStake := uint64 (( (( $ Л_roundStake * StakingContract_ι_NOTIFY_FEE )) / $ Л_roundRewards )) ) >> 
all.v: return (( $ Л_stake + $ Л_reward - StakingContract_ι_NOTIFY_FEE , StakingContract_ι_NOTIFY_FEE )) ) >> 
all.v: return (( $ xInt0 , $ Л_stake + $ Л_reward )) ) >> 
all.v:Definition StakingContract_Ф_Constructor7 ( $ Л_electorAddr : XAddress )( $ Л_poolOwnerAddr : XAddress )( $ Л_electionId : XInteger32 )( $ Л_nodeWallet : XAddress )( $ Л_beginBefore : XInteger32 )( $ Л_endBefore : XInteger32 )( $ Л_heldFor : XInteger32 )( $ Л_electedFor : XInteger32 )( $ Л_minStake : XInteger64 )( $ Л_minRoundStake : XInteger64 )( $ Л_maxRoundStake : XInteger64 ) : StakingContractT := 
all.v: ( d1! StakingContract_ι_m_minStake := $ Л_minStake ) >> 
all.v: 	 ( d1! StakingContract_ι_m_minRoundStake := $ Л_minRoundStake ) >> 
all.v: 	 ( d1! StakingContract_ι_m_maxRoundStake := $ Л_maxRoundStake ) >> 
all.v: 	 ( d1! StakingContract_ι_m_node := StakingContract_ι_Node (( $ Л_nodeWallet , $ xInt3 * $ xInt65536 , $ xInt0 )) ) >> 
all.v:Definition StakingContract_Ф_receiveConfirmation ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_comment : XInteger32 ) : StakingContractT := 
all.v: 	 require (( $ Л_comment ?== $ xInt0 , $ xInt110 )) ) >> 
all.v: 	 require (( $ Л_queryId ?>= $ xInt0 , $ xInt110 )) ) >> 
all.v:Definition DePool_Ф_Constructor8 ( $ Л_electorAddr : XAddress )( $ Л_poolOwnerAddr : XAddress )( $ Л_electionId : XInteger32 )( $ Л_nodeWallet : XAddress )( $ Л_beginBefore : XInteger32 )( $ Л_endBefore : XInteger32 )( $ Л_heldFor : XInteger32 )( $ Л_electedFor : XInteger32 )( $ Л_minStake : XInteger64 )( $ Л_minRoundStake : XInteger64 )( $ Л_maxRoundStake : XInteger64 ) : DePoolT True 
all.v:Definition StakingContract_Ф_receiveConfirmation ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_comment : XInteger32 ) : StakingContractT := 
all.v: 	 require (( $ Л_comment ?== $ xInt0 , $ xInt110 )) ) >> 
all.v: 	 require (( $ Л_queryId ?>= $ xInt0 , $ xInt110 )) ) >> 
all.v:Definition StakingContract_Ф_acceptRecoveredStake ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 ) : StakingContractT := 
all.v: Ife ( $ Л_queryId ?== $ xInt0 ) { StakingContract_Ф__acceptUnusedStake () ) >> 
all.v: Ife ( $ Л_queryId ?== $ xInt1 ) { StakingContract_Ф__acceptRewardStake () ) >> 
all.v: StakingContract_Ф__acceptPendingRoundStake (( uint32 (( $ Л_queryId )) )) ) >> 
all.v:Definition TestElector_Ф_Constructor9 ( $ Л_offset : XInteger32 ) : TestElectorT := 
all.v: ( d1! TestElector_ι_electAt := uint32 (( now )) + $ Л_offset ) >> 
all.v:Definition ElectorBase_Ф__recoverPendingRoundStakes ( $ Л_pendingId : XInteger32 ) : ElectorBaseT := 
all.v: IProxy (( ElectorBase_ι_m_elector )) . Participant_Ф_recover_stake ^^ value (( ElectorBase_ι_RECOVER_STAKE_MSG_VALUE )) (( $ Л_pendingId )) ) >> 
all.v:Definition ElectorBase_Ф__runForElection ( $ Л_req : ι_Request )( $ Л_nodeStake : XInteger64 ) : ElectorBaseT := 
all.v: IProxy (( ElectorBase_ι_m_elector )) . Participant_Ф_process_new_stake ^^ value (( $ Л_nodeStake + 1e9 + 2*1e7 )) (( $ Л_req ^^ ElectorBase_ι_Request_ι_queryId , $ Л_req ^^ ElectorBase_ι_Request_ι_validatorKey , $ Л_req ^^ ElectorBase_ι_Request_ι_stakeAt , $ Л_req ^^ ElectorBase_ι_Request_ι_maxFactor , $ Л_req ^^ ElectorBase_ι_Request_ι_adnlAddr , $ Л_req ^^ ElectorBase_ι_Request_ι_signature )) ) >> 
all.v:Definition ElectionParams_Ф__isRoundUnfrozen ( $ Л_electAt : XInteger32 ) : ElectionParamsT XBool := 
all.v: return now ?> (( $ Л_electAt + ElectionParams_Ф__getFreezingPeriod () )) ) >> 
all.v: ( d0! Л_nextElectAt := ElectionParams_Ф__getNextElectionId () ) >> 
all.v: Ift ( now ?>= $ Л_nextElectAt - ElectionParams_ι_m_beginBefore ) { ( d0! Л_nextElectAt += ElectionParams_ι_m_electedFor ) >> 
all.v: ( d1! ElectionParams_ι_m_electAt := $ Л_nextElectAt ) >> 
all.v: 	 return $ Л_nextElectAt ) >> 
all.v:Definition StakingOwner_Ф__settimer ( $ Л_timer : XAddress )( $ Л_period : XInteger ) : StakingOwnerT := 
all.v: ITimer (( $ Л_timer )) . StakeholderBase_Ф_setTimer ^^ value (( StakingOwner_ι_TIMER_FEE )) (( $ Л_period )) ) >> 
all.v: ( d0! Л_timer := StakingOwner_ι_m_timer ) >> 
all.v: 	 ( d0! Л_period := StakingOwner_ι_m_timeout ) >> 
all.v: Ift ( $ msg_sender ?== $ Л_timer && $ Л_period ?> $ xInt0 ) { IStaking (( StakingOwner_ι_m_stakingPool )) . Participant_Ф_ticktock ^^ value (( StakingOwner_ι_TICKTOCK_FEE )) () ) >> 
all.v: 	 StakingOwner_Ф__settimer (( $ Л_timer , $ Л_period )) ) >> 
all.v:Definition StakingProxyContract_Ф_process_new_stake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_validatorKey : XInteger256 )( $ Л_stakeAt : XInteger32 )( $ Л_maxFactor : XInteger32 )( $ Л_adnlAddr : XInteger256 )( $ Л_signature : XInteger8 ) : StakingProxyContractT := 
all.v: 	 IElector (( ElectorBase_ι_m_elector )) . _Ф_elector_process_new_stake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId , $ Л_validatorKey , $ Л_stakeAt , $ Л_maxFactor , $ Л_adnlAddr , $ Л_signature )) ) >> 
all.v:Definition StakingProxyContract_Ф_recover_stake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 ) : StakingProxyContractT := 
all.v: 	 IElector (( ElectorBase_ι_m_elector )) . _Ф_elector_recover_stake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId )) ) >> 
all.v:Definition StakingProxyContract_Ф_receive_confirmation ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_comment : XInteger32 ) : StakingProxyContractT := 
all.v: 	 IStaking (( StakingProxyContract_ι_m_staking )) . Participant_Ф_receiveConfirmation ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId , $ Л_comment )) ) >> 
all.v:Definition StakingProxyContract_Ф_receive_returned_stake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_comment : XInteger32 ) : StakingProxyContractT := 
all.v: 	 IStaking (( StakingProxyContract_ι_m_staking )) . Participant_Ф_receiveReturnedStake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId , $ Л_comment )) ) >> 
all.v:Definition StakingProxyContract_Ф_accept_recovered_stake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 ) : StakingProxyContractT := 
all.v: 	 IStaking (( StakingProxyContract_ι_m_staking )) . Participant_Ф_acceptRecoveredStake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId )) ) >> 
all.v: (( $ Л_exists , $ Л_round )) := fetch (( RoundsBase_Ф__getLastRoundIdx () )) ) >> 
all.v: 	 require (( $ Л_exists , $ xInt200 )) ) >> 
all.v: 	 return $ Л_round ) >> 
all.v:Definition RoundsBase_Ф__setLastRound ( $ Л_round : ι_Round ) : RoundsBaseT := 
all.v: RoundsBase_ι_m_rounds [ RoundsBase_Ф__getLastRoundIdx () $ Л_round ) >> 
all.v:Definition RoundsBase_Ф__setPenultimateRound ( $ Л_round : ι_Round ) : RoundsBaseT := 
all.v: RoundsBase_ι_m_rounds [ RoundsBase_Ф__getLastRoundIdx () - $ xInt1 $ Л_round ) >> 
all.v: Ift ( RoundsBase_Ф__getRoundsCount () ?> $ xInt4 ) { ( d0! Л_removingRound := RoundsBase_Ф__removeOldestRound () ) >> 
all.v: 	 delete StakingContract_ι_m_requests [ $ Л_removingRound ^^ RoundsBase_ι_Round_ι_id ] ) >> 
all.v: Ift ( $ Л_removingRound ^^ RoundsBase_ι_Round_ι_step ?== RoundsBase_ι_STEP_WAITING_ELECTION_RESULTS ) { RoundsBase_Ф__addPendingRound (( $ Л_removingRound )) ) >> 
all.v: 	 ElectorBase_Ф__recoverPendingRoundStakes (( $ Л_removingRound ^^ RoundsBase_ι_Round_ι_id )) ) >> 
all.v: ( d0! Л_lb1Round := RoundsBase_Ф__getPenultimateRound () ) >> 
all.v: Ift ( now ?> $ Л_lb1Round ^^ RoundsBase_ι_Round_ι_id ) { 
all.v: Ift ( $ Л_lb1Round ^^ RoundsBase_ι_Round_ι_step ?< RoundsBase_ι_STEP_ELECTIONS ) { RoundsBase_Ф__setPenultimateRound (( StakingContract_Ф__completeRoundAndSetCompletionStatus (( $ Л_lb1Round , RoundsBase_ι_ROUND_MISSED_ELECTIONS )) )) ) >> 
all.v: Ift ( $ Л_lb1Round ^^ RoundsBase_ι_Round_ι_step ?< RoundsBase_ι_STEP_WAITING_ELECTION_RESULTS ) { ElectorBase_Ф__recoverStakes () ) >> 
all.v: 	 ( d2! Л_lb1Round ^^ RoundsBase_ι_Round_ι_step := RoundsBase_ι_STEP_WAITING_ELECTION_RESULTS ) >> 
all.v: 	 RoundsBase_Ф__setPenultimateRound (( $ Л_lb1Round )) ) >> 
all.v: ( d0! Л_oldestRound := RoundsBase_Ф__getOldestRound () ) >> 
all.v: Ift ( ElectionParams_Ф__isRoundUnfrozen (( $ Л_oldestRound ^^ RoundsBase_ι_Round_ι_id )) ) { 
all.v: Ift ( $ Л_oldestRound ^^ RoundsBase_ι_Round_ι_step ?== RoundsBase_ι_STEP_WAITING_ELECTION_RESULTS ) { ElectorBase_Ф__recoverStakeRewards () ) >> 
all.v: 	 ( d2! Л_oldestRound ^^ RoundsBase_ι_Round_ι_step := RoundsBase_ι_STEP_WAITING_UNFREEZE ) >> 
all.v: 	 RoundsBase_Ф__setOldestRound (( $ Л_oldestRound )) ) >> 
all.v:Definition StakingContract_Ф__returnAnswer ( msg_sender : XInteger ) ( $ Л_errcode : XInteger32 )( $ Л_amount : XInteger64 )( $ Л_comment : XInteger64 ) : StakingContractT := 
all.v: value : $ Л_amount , flag : (( $ Л_amount ?== $ xInt0 ? $ xInt64 : $ xInt3 )) 
all.v: (( $ Л_errcode , $ Л_comment )) ) >> 
all.v:Definition StakingContract_Ф__returnError ( $ Л_errcode : XInteger32 )( $ Л_comment : XInteger64 ) : StakingContractT := 
all.v: StakingContract_Ф__returnAnswer (( $ Л_errcode , $ xInt0 , $ Л_comment )) ) >> 
all.v:Definition StakingContract_Ф__returnConfirmation ( $ Л_fee : XInteger64 ) : StakingContractT := 
all.v: StakingContract_Ф__returnAnswer (( StakingContract_ι_STATUS_SUCCESS , StakingContract_ι_ANSWER_MSG_FEE , $ Л_fee )) ) >> 
all.v:Definition StakingContract_Ф__investStake ( $ Л_addr : XAddress )( $ Л_unusedStake : XInteger64 )( $ Л_newStake : XInteger64 )( $ Л_reinvest : XBool ) : StakingContractT XBool := 
all.v: ( d0! Л_stakeholder := StakeholderBase_Ф__getStakeholder (( $ Л_addr )) ) >> 
all.v: 	 ( d0! Л_unusedStake := tvm_min (( $ Л_unusedStake , $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake )) ) >> 
all.v: 	 ( d0! Л_investStake := $ Л_unusedStake + $ Л_newStake ) >> 
all.v: 	 ( d0! Л_round := RoundsBase_Ф__getLastRound () ) >> 
all.v: Ift ( $ Л_round ^^ RoundsBase_ι_Round_ι_stake + $ Л_investStake ?> StakingContract_ι_m_maxRoundStake ) { return $ xBoolFalse ) >> 
all.v: RoundsBase_Ф__setLastRound (( RoundsBase_Ф__roundAddStakeAndVesting (( $ Л_round , $ Л_addr , $ Л_investStake , $ xInt0 )) )) ) >> 
all.v: 	 $ Л_stakeholder $ Л_=_stakeholderDecreaseUnusedStake (( $ Л_stakeholder , $ Л_unusedStake )) ) >> 
all.v: Ife ( $ Л_newStake ?> $ xInt0 ) { ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderUpdateStake2 (( $ Л_stakeholder , $ Л_newStake , $ Л_reinvest )) ) >> 
all.v: ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderSetReinvest2 (( $ Л_stakeholder , $ Л_reinvest )) ) >> 
all.v: StakeholderBase_Ф__setOrDeleteStakeholder (( $ Л_addr , $ Л_stakeholder )) ) >> 
all.v:Definition StakingContract_Ф__requestStakesSigning ( $ Л_round : ι_Round ) : StakingContractT ι_Round := 
all.v: ( d0! Л_roundStake := $ Л_round ^^ RoundsBase_ι_Round_ι_stake ) >> 
all.v: 	 ( d0! Л_currentElectAt := $ Л_round ^^ RoundsBase_ι_Round_ι_id ) >> 
all.v: 	 ( d0! Л_roundStakeCheck := $ Л_roundStake ?>= StakingContract_ι_m_minRoundStake ) >> 
all.v: 	 ( d0! Л_nodeStakeCheck := RoundsBase_Ф_getTotalStake (( $ Л_round ^^ RoundsBase_ι_Round_ι_stakes [ StakingContract_ι_Node_ι_wallet ] )) ?>= (( StakingContract_ι_m_minRoundStake * StakingContract_ι_NODE_WALLET_MIN_STAKE )) / $ xInt100 ) >> 
all.v: 	 ( d0! Л_canParticipate := ! ElectionParams_Ф__isElectionOver (( $ Л_currentElectAt )) && $ Л_roundStakeCheck && $ Л_nodeStakeCheck ) >> 
all.v: Ife ( $ Л_canParticipate ) { ( d1! RoundsBase_ι_Round_ι_stake := $ Л_roundStake ) >> 
all.v: 	 emit $ Л_stakeSigningRequested (( $ Л_currentElectAt )) ) >> 
all.v: 	 (( $ Л_exists , $ Л_request )) := fetch (( $ Л_currentElectAt )) ) >> 
all.v: Ife ( $ Л_exists ) { ( d2! Л_round ^^ RoundsBase_ι_Round_ι_step := RoundsBase_ι_STEP_ELECTIONS ) >> 
all.v: 	 ElectorBase_Ф__runForElection (( $ Л_request , $ Л_roundStake )) ) >> 
all.v: ( d2! Л_round ^^ RoundsBase_ι_Round_ι_step := RoundsBase_ι_STEP_WAITING_REQUESTS ) >> 
all.v: ( d0! Л_completionStatus := ! $ Л_roundStakeCheck ? RoundsBase_ι_ROUND_NOT_ENOUGH_TOTAL_STAKE : RoundsBase_ι_ROUND_NODE_STAKE_TOO_SMALL ) >> 
all.v: 	 ( d0! Л_round := StakingContract_Ф__completeRoundAndSetCompletionStatus (( $ Л_round , $ Л_completionStatus )) ) >> 
all.v: return $ Л_round ) >> 
all.v:Definition StakingContract_Ф__acceptPendingRoundStake ( $ Л_pendingId : XInteger32 ) : StakingContractT := 
all.v: (( $ Л_exists , $ Л_round )) := RoundsBase_Ф__removePendingRound (( $ Л_pendingId )) ) >> 
all.v: Ift ( $ Л_exists ) { StakingContract_Ф__completeRoundAndSetCompletionStatus (( $ Л_round , RoundsBase_ι_ROUND_RECEIVED_REWARD )) ) >> 
all.v: ( d0! Л_lb1round := RoundsBase_Ф__getPenultimateRound () ) >> 
all.v: Ife ( $ msg_value ?>= $ Л_lb1round ^^ RoundsBase_ι_Round_ι_stake ) { RoundsBase_Ф__setPenultimateRound (( StakingContract_Ф__completeRoundAndSetCompletionStatus (( $ Л_lb1round , RoundsBase_ι_ROUND_LOST_ELECTIONS )) )) ) >> 
all.v: ( d2! Л_lb1round ^^ RoundsBase_ι_Round_ι_unused := uint64 (( $ msg_value )) ) >> 
all.v: 	 ( d1! StakingContract_ι_m_minRoundStake := $ Л_lb1round ^^ RoundsBase_ι_Round_ι_stake - $ Л_lb1round ^^ RoundsBase_ι_Round_ι_unused + StakingContract_ι_ROUND_UP_VALUE ) >> 
all.v: ( d0! Л_oldestRound := RoundsBase_Ф__getOldestRound () ) >> 
all.v: 	 ( d0! Л_roundStake := $ Л_oldestRound ^^ RoundsBase_ι_Round_ι_stake - $ Л_oldestRound ^^ RoundsBase_ι_Round_ι_unused ) >> 
all.v: 	 ( d0! Л_totalReward := $ xInt0 ) >> 
all.v: Ift ( uint64 (( $ msg_value )) ?>= $ Л_roundStake ) { ( d0! Л_totalReward := uint64 (( $ msg_value )) - $ Л_roundStake ) >> 
all.v: ( d0! Л_roundReward := uint64 (( (( $ Л_totalReward * StakingContract_ι_NOM_FRACTION )) / $ xInt100 )) ) >> 
all.v: 	 ( d0! Л_ownerReward := uint64 (( (( $ Л_totalReward * StakingContract_ι_NODE_FRACTION )) / $ xInt100 )) ) >> 
all.v: 	 OwnerBase_Ф__increaseOwnerReward (( $ Л_ownerReward )) ) >> 
all.v: 	 ( d2! Л_oldestRound ^^ RoundsBase_ι_Round_ι_rewards := $ Л_roundReward ) >> 
all.v: 	 ( d1! StakingContract_ι_m_lastRoundInterest := StakingContract_Ф__calcLastRoundInterest (( $ Л_roundStake , $ Л_roundReward )) ) >> 
all.v: 	 RoundsBase_Ф__setOldestRound (( StakingContract_Ф__completeRoundAndSetCompletionStatus (( $ Л_oldestRound , RoundsBase_ι_ROUND_RECEIVED_REWARD )) )) ) >> 
all.v:Definition StakingContract_Ф__completeRound ( $ Л_completedRound : ι_Round )( $ Л_chunkSize : XInteger8 ) : StakingContractT ι_Round := 
all.v: ( d2! Л_completedRound ^^ RoundsBase_ι_Round_ι_step := RoundsBase_ι_STEP_COMPLETING ) >> 
all.v: 	 ( d2! Л_completedRound ^^ RoundsBase_ι_Round_ι_end := uint32 (( now )) ) >> 
all.v: 	 RoundsBase_Ф__setOrDeletePendingRound (( $ Л_completedRound )) ) >> 
all.v: 	 ( d0! Л_completedRound := StakingContract_Ф__completePendingRound (( $ Л_completedRound , $ Л_chunkSize )) ) >> 
all.v: 	 RoundsBase_Ф__setOrDeletePendingRound (( $ Л_completedRound )) ) >> 
all.v: 	 delete $ Л_completedRound ^^ RoundsBase_ι_Round_ι_stakes ) >> 
all.v: 	 return $ Л_completedRound ) >> 
all.v:Definition StakingContract_Ф__completeRoundAndSetCompletionStatus ( $ Л_round : ι_Round )( $ Л_completionStatus : XInteger8 ) : StakingContractT ι_Round := 
all.v: ( d2! Л_round ^^ RoundsBase_ι_Round_ι_completionStatus := $ Л_completionStatus ) >> 
all.v: 	 return StakingContract_Ф__completeRound (( $ Л_round , StakingContract_ι_MAX_MSGS_PER_TR )) ) >> 
all.v:Definition StakingContract_Ф_getNewStakeAndFees ( $ Л_roundRewards : XInteger64 )( $ Л_roundStake : XInteger64 )( $ Л_stake : XInteger64 ) : StakingContractT XInteger64 # XInteger64 # XInteger64 := 
all.v: Ift ( $ Л_stake ?== $ xInt0 ) { return (( $ xInt0 , $ xInt0 , $ xInt0 )) ) >> 
all.v: ( d0! Л_reward := (( $ Л_roundStake ?!= $ xInt0 )) ? uint64 (( $ Л_roundRewards * $ Л_stake / $ Л_roundStake ) : $ xInt0 ) >> 
all.v: 	 (( $ Л_stakeAndReward , $ Л_fee )) := StakingContract_Ф__getStakeAndFeeAndUpdateMinStakeIfNeeded (( $ Л_stake , $ Л_reward , $ Л_roundStake , $ Л_roundRewards )) ) >> 
all.v: 	 return (( $ Л_reward , $ Л_stakeAndReward , $ Л_fee )) ) >> 
all.v:Definition StakingContract_Ф__returnOrReinvestForStakeholder ( $ Л_completedRound : ι_Round )( $ Л_lastRound : ι_Round )( $ Л_addr : XAddress )( $ Л_stake : ι_StakeValue ) : StakingContractT ι_Round := 
all.v: ( d0! Л_roundRewards := $ Л_completedRound ^^ RoundsBase_ι_Round_ι_rewards ) >> 
all.v: 	 ( d0! Л_roundStake := $ Л_completedRound ^^ RoundsBase_ι_Round_ι_stake ) >> 
all.v: 	 ( d0! Л_stakeholder := StakeholderBase_Ф__getStakeholder (( $ Л_addr )) ) >> 
all.v: 	 ( d0! Л_reinvest := $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_reinvest ) >> 
all.v: 	 (( $ Л_stakeReward , $ Л_newStake , $ Л_stakeFee )) := StakingContract_Ф_getNewStakeAndFees (( $ Л_roundRewards , $ Л_roundStake , $ Л_stake ^^ RoundsBase_ι_StakeValue_ι_simple )) ) >> 
all.v: 	 (( $ Л_vestingReward , $ Л_vestingAndReward , $ Л_vestingFee )) := StakingContract_Ф_getNewStakeAndFees (( $ Л_roundRewards , $ Л_roundStake , $ Л_stake ^^ RoundsBase_ι_StakeValue_ι_vesting )) ) >> 
all.v: 	 ( d0! Л_pureVestingReward := $ Л_vestingAndReward ?>= $ Л_stake ^^ vesting? $ Л_vestingAndReward - $ Л_stake ^^ RoundsBase_ι_StakeValue_ι_vesting : $ xInt0 ) >> 
all.v: 	 ( d0! Л_newVesting := tvm_min (( $ Л_vestingAndReward - $ Л_pureVestingReward , $ Л_stake ^^ RoundsBase_ι_StakeValue_ι_vesting )) ) >> 
all.v: 	 ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderUpdateGrossReward (( $ Л_stakeholder , $ Л_stakeReward + $ Л_vestingReward )) ) >> 
all.v: 	 ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderUpdateTotalStake (( $ Л_stakeholder , $ Л_newStake + $ Л_vestingAndReward , $ Л_stake ^^ RoundsBase_ι_StakeValue_ι_simple + $ Л_stake ^^ RoundsBase_ι_StakeValue_ι_vesting )) ) >> 
all.v: 	 ( d0! Л_withdrawalVesting := $ xInt0 ) >> 
all.v: Ift ( $ Л_stake ^^ RoundsBase_ι_StakeValue_ι_vesting ?!= $ xInt0 ) { ( d0! Л_periodQty := (( uint64 (( now )) - $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_lastPaymentUnixTime )) / $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_withdrawalPeriod ) >> 
all.v: 	 ( d0! Л_withdrawalVesting := tvm_min (( $ Л_periodQty * $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_periodPayment , $ Л_newVesting )) ) >> 
all.v: 	 ( d0! Л_newVesting -= $ Л_withdrawalVesting ) >> 
all.v: 	 ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderUpdateLastPaymentTime (( $ Л_stakeholder , $ Л_periodQty )) ) >> 
all.v: Ift ( $ Л_newVesting ?< StakingContract_ι_m_minStake ) { ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderIncreaseUnusedStake (( $ Л_stakeholder , $ Л_newVesting )) ) >> 
all.v: 	 ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderResetVesting (( $ Л_stakeholder )) ) >> 
all.v: 	 ( d0! Л_newVesting := $ xInt0 ) >> 
all.v: ( d0! Л_newStake += $ Л_withdrawalVesting + $ Л_pureVestingReward ) >> 
all.v: Ife ( StakingContract_ι_m_poolClosed ) { ( d0! Л_attachedValue := $ Л_newStake + $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake ) >> 
all.v: 	 ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderDecreaseTotalAndUnused (( $ Л_stakeholder , $ Л_newStake + $ Л_newVesting + $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake , $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake )) ) >> 
all.v: Ift ( $ Л_newVesting ?!= $ xInt0 && $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_vestingOwner ?!= xInt0 ) { $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_vestingOwner . transfer (( 
all.v: value : $ Л_newVesting , flag : $ xInt3 
all.v: ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderResetVesting (( $ Л_stakeholder )) ) >> 
all.v: ( d0! Л_attachedValue := $ xInt1 ) >> 
all.v: Ife ( $ Л_reinvest ) { ( d0! Л_lastRound := RoundsBase_Ф__roundAddStakeAndVesting (( $ Л_lastRound , $ Л_addr , $ Л_newStake , $ Л_newVesting )) ) >> 
all.v: ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderIncreaseUnusedStake (( $ Л_stakeholder , $ Л_newStake )) ) >> 
all.v: 	 ( d0! Л_lastRound := RoundsBase_Ф__roundAddStakeAndVesting (( $ Л_lastRound , $ Л_addr , $ xInt0 , $ Л_newVesting )) ) >> 
all.v: StakeholderBase_Ф__setOrDeleteStakeholder (( $ Л_addr , $ Л_stakeholder )) ) >> 
all.v: 	 IParticipant (( $ Л_addr )) . _Ф_receiveRewardStake 
all.v: value : $ Л_attachedValue , flag : $ xInt3 
all.v: (( $ Л_completedRound ^^ RoundsBase_ι_Round_ι_id , $ Л_stakeReward + $ Л_vestingReward , $ Л_newStake + $ Л_newVesting , $ Л_reinvest , $ Л_stakeFee + $ Л_vestingFee , $ Л_completedRound ^^ RoundsBase_ι_Round_ι_completionStatus )) ) >> 
all.v: 	 return $ Л_lastRound ) >> 
all.v:Definition StakingContract_Ф__returnOrReinvest ( $ Л_completedRound : ι_Round )( $ Л_chunkSize : XInteger8 ) : StakingContractT ι_Round := 
all.v: ( d1! RoundsBase_ι_Round_ι_stakes := $ Л_completedRound ^^ RoundsBase_ι_Round_ι_stakes ) >> 
all.v: 	 ( d0! Л_lastRound := RoundsBase_Ф__getLastRound () ) >> 
all.v: 	 ( d0! Л_sentMsgs := $ xInt0 ) >> 
all.v: 	 while (( ! empty () && $ Л_sentMsgs ?< $ Л_chunkSize ) { $ Л_sentMsgs ++ ) >> 
all.v: 	 (( $ Л_addr , $ Л_stake )) := delMin () ) >> 
all.v: 	 ( d0! Л_lastRound := StakingContract_Ф__returnOrReinvestForStakeholder (( $ Л_completedRound , $ Л_lastRound , $ Л_addr , $ Л_stake )) ) >> 
all.v: Ift ( $ Л_completedRound ^^ RoundsBase_ι_Round_ι_id ?!= $ Л_lastRound ^^ RoundsBase_ι_Round_ι_id ) { RoundsBase_Ф__setLastRound (( $ Л_lastRound )) ) >> 
all.v: ( d2! Л_completedRound ^^ RoundsBase_ι_Round_ι_step := empty () ? RoundsBase_ι_STEP_COMPLETED : RoundsBase_ι_STEP_COMPLETING ) >> 
all.v: 	 ( d2! Л_completedRound ^^ RoundsBase_ι_Round_ι_stakes := RoundsBase_ι_Round_ι_stakes ) >> 
all.v: 	 return $ Л_completedRound ) >> 
all.v: 	 ( d0! Л_msgValue := uint64 (( $ msg_value )) ) >> 
all.v: 	 ( d0! Л_minRequiredValue := StakingContract_ι_m_minStake + StakingContract_ι_ADD_STAKE_FEE ) >> 
all.v: Ift ( $ Л_msgValue ?< $ Л_minRequiredValue ) { StakingContract_Ф__returnError (( StakingContract_ι_STATUS_STAKE_TOO_SMALL , $ Л_minRequiredValue )) ) >> 
all.v: return (( $ Л_msgValue - StakingContract_ι_ADD_STAKE_FEE , $ xBoolTrue )) ) >> 
all.v:Definition StakingContract_Ф_addStake ( msg_sender : XInteger ) ( $ Л_reinvest : XBool ) : StakingContractT := 
all.v: 	 (( $ Л_stake , $ Л_ok )) := StakingContract_Ф__getStakeAndSendErrorIfNeeded () ) >> 
all.v: Ift ( ! $ Л_ok ) { return ) >> 
all.v: Ift ( ! StakingContract_Ф__investStake (( $ msg_sender , reinvest? $ Л_MAX_MONEY_VALUE : $ xInt0 , $ Л_stake , $ Л_reinvest )) ) { ( d0! Л_round := RoundsBase_Ф__getLastRound () ) >> 
all.v: 	 return StakingContract_Ф__returnError (( StakingContract_ι_STATUS_ROUND_STAKE_LIMIT , StakingContract_ι_m_maxRoundStake - $ Л_round ^^ RoundsBase_ι_Round_ι_stake )) ) >> 
all.v:Definition StakingContract_Ф_addVesting ( msg_sender : XInteger ) ( $ Л_dest : XAddress )( $ Л_withdrawalPeriod : XInteger32 )( $ Л_totalPeriod : XInteger32 ) : StakingContractT := 
all.v: require (( $ Л_dest ^^ isStdAddrWithoutAnyCast () , $ xInt119 )) ) >> 
all.v: Ift ( $ Л_dest ?== xInt0 ) { ( d0! Л_dest := $ msg_sender ) >> 
all.v: (( $ Л_stake , $ Л_ok )) := StakingContract_Ф__getStakeAndSendErrorIfNeeded () ) >> 
all.v: Ift ( ! $ Л_ok ) { return ) >> 
all.v: ( d0! Л_round := RoundsBase_Ф__getLastRound () ) >> 
all.v: Ift ( $ Л_round ^^ RoundsBase_ι_Round_ι_stake + $ Л_stake ?> StakingContract_ι_m_maxRoundStake ) { return StakingContract_Ф__returnError (( StakingContract_ι_STATUS_ROUND_STAKE_LIMIT , StakingContract_ι_m_maxRoundStake - $ Л_round ^^ RoundsBase_ι_Round_ι_stake )) ) >> 
all.v: Ift ( $ Л_withdrawalPeriod ?> $ Л_totalPeriod ) { return StakingContract_Ф__returnError (( StakingContract_ι_STATUS_WITHDRAWAL_PERIOD_GREATER_TOTAL_PERIOD , $ xInt0 )) ) >> 
all.v: Ift ( $ Л_totalPeriod ?>= $ xInt100 * (( $ Л_days )) ) { return StakingContract_Ф__returnError (( StakingContract_ι_STATUS_TOTAL_PERIOD_MORE_100YEARS , $ xInt0 )) ) >> 
all.v: Ift ( $ Л_withdrawalPeriod ?== $ xInt0 ) { return StakingContract_Ф__returnError (( StakingContract_ι_STATUS_WITHDRAWAL_PERIOD_IS_ZERO , $ xInt0 )) ) >> 
all.v: Ift ( $ Л_totalPeriod $ Л_% $ Л_withdrawalPeriod ?!= $ xInt0 ) { return StakingContract_Ф__returnError (( StakingContract_ι_STATUS_TOTAL_PERIOD_IS_NOT_DIVED_BY_WITHDRAWAL_PERIOD , $ xInt0 )) ) >> 
all.v: ( d0! Л_stakeholder := StakeholderBase_Ф__getStakeholder (( $ Л_dest )) ) >> 
all.v: Ift ( StakeholderBase_Ф__haveVesting (( $ Л_stakeholder )) ) { return StakingContract_Ф__returnError (( StakingContract_ι_STATUS_STAKEHOLDER_HAVE_ALREADY_VESTING , $ xInt0 )) ) >> 
all.v: ( d0! Л_periodPayment := uint64 (( uint (( $ Л_stake )) * $ Л_withdrawalPeriod / $ Л_totalPeriod )) ) >> 
all.v: Ift ( $ Л_periodPayment ?== $ xInt0 ) { return StakingContract_Ф__returnError (( StakingContract_ι_STATUS_PERIOD_PAYMENT_IS_ZERO , $ xInt0 )) ) >> 
all.v: ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderSetVesting (( $ Л_stakeholder , $ Л_stake , $ Л_withdrawalPeriod , $ Л_periodPayment , $ msg_sender )) ) >> 
all.v: 	 StakeholderBase_Ф__setOrDeleteStakeholder (( $ Л_dest , $ Л_stakeholder )) ) >> 
all.v: 	 RoundsBase_Ф__setLastRound (( RoundsBase_Ф__roundAddStakeAndVesting (( $ Л_round , $ Л_dest , $ xInt0 , $ Л_stake )) )) ) >> 
all.v:Definition StakingContract_Ф_removeStake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_stake : XInteger64 ) : StakingContractT := 
all.v: ( d0! Л_member := StakeholderBase_Ф__getStakeholder (( $ msg_sender )) ) >> 
all.v: 	 ( d0! Л_removedStake := tvm_min (( $ Л_stake , $ Л_member ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake )) ) >> 
all.v: 	 StakeholderBase_Ф__stakeholderRemoveStake (( $ msg_sender , $ Л_removedStake , $ Л_removedStake )) ) >> 
all.v: 	 $ msg_sender ^^ transfer (( $ Л_removedStake , $ xBoolTrue , $ xInt3 )) ) >> 
all.v:Definition StakingContract_Ф_continueStake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_amount : XInteger64 )( $ Л_reinvest : XBool ) : StakingContractT := 
all.v: Ift ( ! StakingContract_Ф__investStake (( $ msg_sender , $ Л_amount ?== 0? $ Л_MAX_MONEY_VALUE : $ Л_amount , $ xInt0 , $ Л_reinvest )) ) { ( d0! Л_round := RoundsBase_Ф__getLastRound () ) >> 
all.v: 	 return StakingContract_Ф__returnError (( StakingContract_ι_STATUS_ROUND_STAKE_LIMIT , StakingContract_ι_m_maxRoundStake - $ Л_round ^^ RoundsBase_ι_Round_ι_stake )) ) >> 
all.v:Definition StakingContract_Ф_setReinvest ( msg_sender : XInteger ) ( $ Л_flag : XBool ) : StakingContractT := 
all.v: 	 ( d0! Л_sender := $ msg_sender ) >> 
all.v: 	 require (( StakeholderBase_Ф__stakeholderExists (( $ Л_sender )) , $ xInt101 )) ) >> 
all.v: 	 StakeholderBase_Ф__stakeholderSetReinvest (( $ Л_sender , $ Л_flag )) ) >> 
all.v:Definition StakingContract_Ф_transferStake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_destination : XAddress )( $ Л_amount : XInteger64 ) : StakingContractT := 
all.v: 	 ( d0! Л_sender := $ msg_sender ) >> 
all.v: 	 (( $ Л_exists , $ Л_donor )) := StakeholderBase_Ф__stakeholderFetch (( $ Л_sender )) ) >> 
all.v: 	 require (( $ Л_exists , $ xInt101 )) ) >> 
all.v: 	 require (( $ Л_destination ^^ isStdAddrWithoutAnyCast () && ! $ Л_destination ^^ isStdZero () , $ xInt119 )) ) >> 
all.v: Ift ( $ Л_amount ?== $ xInt0 ) { ( d0! Л_amount := StakingContract_ι_MAX_MONEY_VALUE ) >> 
all.v: ( d0! Л_receiver := StakeholderBase_Ф__getStakeholder (( $ Л_destination )) ) >> 
all.v: 	 ( d0! Л_transferredStake := RoundsBase_Ф__roundMoveStakes (( $ Л_sender , $ Л_destination , $ Л_amount )) ) >> 
all.v: 	 ( d0! Л_transferredUnused := tvm_min (( $ Л_amount - $ Л_transferredStake , $ Л_donor ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake )) ) >> 
all.v: 	 ( d0! Л_transferred := $ Л_transferredStake + $ Л_transferredUnused ) >> 
all.v: 	 ( d0! Л_donor := StakeholderBase_Ф__stakeholderDecreaseTotalAndUnused (( $ Л_donor , $ Л_transferred , $ Л_transferredUnused )) ) >> 
all.v: 	 ( d0! Л_receiver := StakeholderBase_Ф__stakeholderIncreaseTotalAndUnused (( $ Л_receiver , $ Л_transferred , $ Л_transferredUnused )) ) >> 
all.v: 	 StakeholderBase_Ф__setOrDeleteStakeholder (( $ Л_sender , $ Л_donor )) ) >> 
all.v: 	 StakeholderBase_Ф__setOrDeleteStakeholder (( $ Л_destination , $ Л_receiver )) ) >> 
all.v:Definition StakingContract_Ф_processNewStake ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_validatorKey : XInteger256 )( $ Л_stakeAt : XInteger32 )( $ Л_maxFactor : XInteger32 )( $ Л_adnlAddr : XInteger256 )( $ Л_signature : XInteger8 ) : StakingContractT := 
all.v: 	 ( d0! Л_request := ElectorBase_ι_Request (( $ Л_queryId , $ Л_validatorKey , $ Л_stakeAt , $ Л_maxFactor , $ Л_adnlAddr , $ Л_signature )) ) >> 
all.v: 	 StakingContract_Ф__addRequest (( $ Л_stakeAt , $ Л_request )) ) >> 
all.v: Ife ( $ Л_stakeAt ?== ElectionParams_Ф__getElectAt () ) { 
all.v: 	 ( d0! Л_round := RoundsBase_Ф__getPenultimateRound () ) >> 
all.v: 	 require (( $ Л_round ^^ RoundsBase_ι_Round_ι_step ?== RoundsBase_ι_STEP_WAITING_REQUESTS , $ xInt118 )) ) >> 
all.v: 	 require (( $ Л_stakeAt ?== $ Л_round ^^ RoundsBase_ι_Round_ι_id , $ xInt111 )) ) >> 
all.v: 	 ElectorBase_Ф__runForElection (( $ Л_request , RoundsBase_ι_Round_ι_stake )) ) >> 
all.v: 	 ( d2! Л_round ^^ RoundsBase_ι_Round_ι_step := RoundsBase_ι_STEP_ELECTIONS ) >> 
all.v: 	 RoundsBase_Ф__setPenultimateRound (( $ Л_round )) ) >> 
all.v: 	 ( d0! Л_electionsStarted := now ?>= ElectionParams_Ф__getElectionsStart () ) >> 
all.v: Ife ( $ Л_electionsStarted ) { StakingContract_Ф__addNewRoundAndUpdateRounds () ) >> 
all.v:Definition StakingContract_Ф_forceCompletePendingRound ( msg_sender : XInteger ) ( $ Л_doCompleteOneChunk : XBool )( $ Л_chunkSize : XInteger8 ) : StakingContractT := 
all.v: 	 (( _ , $ Л_round , $ Л_ok )) := RoundsBase_Ф__fetchOldestPendingRound () ) >> 
all.v: 	 require (( $ Л_ok , $ xInt121 )) ) >> 
all.v: 	 require (( $ Л_round ^^ RoundsBase_ι_Round_ι_end + $ xInt1 $ Л_hours ?< now , $ xInt122 )) ) >> 
all.v: Ife ( $ Л_doCompleteOneChunk ) { ( d0! Л_round := StakingContract_Ф__returnOrReinvest (( $ Л_round , $ Л_chunkSize )) ) >> 
all.v: ( d0! Л_round := StakingContract_Ф__completePendingRound (( $ Л_round , $ Л_chunkSize )) ) >> 
all.v: RoundsBase_Ф__setOrDeletePendingRound (( $ Л_round )) ) >> 
all.v:Definition StakingContract_Ф_completePendingRoundChunk ( msg_sender : XInteger ) ( $ Л_roundId : XInteger32 )( $ Л_chunkSize : XInteger8 ) : StakingContractT := 
all.v: 	 (( $ Л_exists , $ Л_round )) := RoundsBase_Ф__roundFetchPendingRound (( $ Л_roundId )) ) >> 
all.v: Ift ( $ Л_exists ) { tvm_accept () ) >> 
all.v: 	 RoundsBase_Ф__setOrDeletePendingRound (( StakingContract_Ф__returnOrReinvest (( $ Л_round , $ Л_chunkSize )) )) ) >> 
all.v:Definition StakingContract_Ф_receiveReturnedStake ( $ Л_queryId : XInteger64 )( $ Л_comment : XInteger32 ) : StakingContractT XInteger64 # XInteger32 := 
all.v: ( d0! Л_round := RoundsBase_Ф__getPenultimateRound () ) >> 
all.v: 	 ( d2! Л_round ^^ RoundsBase_ι_Round_ι_completionStatus := RoundsBase_ι_ROUND_STAKE_REJECTED ) >> 
all.v: 	 return (( $ Л_queryId , $ Л_comment )) ) >> 
all.v:Definition StakingContract_Ф_acceptRecoveredStake ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 ) : StakingContractT := 
all.v: Ife ( $ Л_queryId ?== $ xInt0 ) { StakingContract_Ф__acceptUnusedStake () ) >> 
all.v: Ife ( $ Л_queryId ?== $ xInt1 ) { StakingContract_Ф__acceptRewardStake () ) >> 
all.v: StakingContract_Ф__acceptPendingRoundStake (( uint32 (( $ Л_queryId )) )) ) >> 
all.v:Definition StakingContract_Ф_terminator ( $ Л_chunkSize : XInteger8 ) : StakingContractT := 
all.v: Ift ( RoundsBase_Ф__getRoundsCount () ?!= $ xInt0 ) { ( d0! Л_lastRound := RoundsBase_Ф__getLastRound () ) >> 
all.v: 	 ( d2! Л_lastRound ^^ RoundsBase_ι_Round_ι_completionStatus := RoundsBase_ι_ROUND_POOL_CLOSED ) >> 
all.v: 	 RoundsBase_Ф__setLastRound (( StakingContract_Ф__completeRound (( $ Л_lastRound , $ Л_chunkSize )) )) ) >> 
all.v: emit $ Л_stakingPoolClosed () ) >> 
all.v:Definition DePool_Ф_getStakeholderInfo ( $ Л_addr : XAddress ) : DePoolT XInteger64 # XInteger64 # XInteger64 # XBool # XInteger64 # ι_М_StakeInfo := 
all.v: require (( StakeholderBase_Ф__stakeholderExists (( $ Л_addr )) , $ xInt116 )) ) >> 
all.v: 	 ( d0! Л_stakeholder := StakeholderBase_Ф__getStakeholder (( $ Л_addr )) ) >> 
all.v: 	 ( d1! StakeholderBase_ι_Stakeholder_ι_reinvest := $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_reinvest ) >> 
all.v: 	 $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake ) >> 
all.v: 	 ( d1! OwnerBase_ι_Owner_ι_reward := $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_grossReward ) >> 
all.v: 	 $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake ) >> 
all.v: 	 ( d0! Л_invested2 := $ xInt0 ) >> 
all.v: 	 (( $ Л_index , $ Л_round , $ Л_ok )) := min () ) >> 
all.v: 	 while (( $ Л_ok ) { 
all.v: Ife ( $ Л_round ^^ RoundsBase_ι_Round_ι_step ?< RoundsBase_ι_STEP_COMPLETED ) { (( $ Л_presents , $ Л_value )) := $ Л_round ^^ RoundsBase_ι_Round_ι_stakes . fetch (( $ Л_addr )) ) >> 
all.v: Ift ( $ Л_presents ) { push (( DePool_ι_StakeInfo (( $ Л_round ^^ RoundsBase_ι_Round_ι_id , $ Л_value ^^ RoundsBase_ι_StakeValue_ι_simple , $ Л_value ^^ RoundsBase_ι_StakeValue_ι_vesting )) )) ) >> 
all.v: 	 ( d0! Л_invested2 += $ Л_value ^^ RoundsBase_ι_StakeValue_ι_simple + $ Л_value ^^ RoundsBase_ι_StakeValue_ι_vesting ) >> 
all.v: (( $ Л_presents , $ Л_value )) := $ Л_round ^^ RoundsBase_ι_Round_ι_stakes . fetch (( $ Л_addr )) ) >> 
all.v: Ift ( $ Л_presents ) { ( d0! Л_invested2 += $ Л_value ^^ RoundsBase_ι_StakeValue_ι_simple + $ Л_value ^^ RoundsBase_ι_StakeValue_ι_vesting ) >> 
all.v: (( $ Л_index , $ Л_round , $ Л_ok )) := next (( $ Л_index )) ) >> 
all.v: (( $ Л_index , $ Л_round , $ Л_ok )) := min () ) >> 
all.v: 	 while (( $ Л_ok ) { (( $ Л_presents , $ Л_value )) := $ Л_round ^^ RoundsBase_ι_Round_ι_stakes . fetch (( $ Л_addr )) ) >> 
all.v: Ift ( $ Л_presents ) { ( d0! Л_invested2 += $ Л_value ^^ RoundsBase_ι_StakeValue_ι_simple + $ Л_value ^^ RoundsBase_ι_StakeValue_ι_vesting ) >> 
all.v: (( $ Л_index , $ Л_round , $ Л_ok )) := next (( uint32 (( $ Л_index )) )) ) >> 
all.v:Definition StakingProxyContract_Ф_process_new_stake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_validatorKey : XInteger256 )( $ Л_stakeAt : XInteger32 )( $ Л_maxFactor : XInteger32 )( $ Л_adnlAddr : XInteger256 )( $ Л_signature : XInteger8 ) : StakingProxyContractT := 
all.v: 	 IElector (( ElectorBase_ι_m_elector )) . _Ф_elector_process_new_stake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId , $ Л_validatorKey , $ Л_stakeAt , $ Л_maxFactor , $ Л_adnlAddr , $ Л_signature )) ) >> 
all.v:Definition ElectionParams_Ф_Constructor4 ( $ Л_electionId : XInteger32 )( $ Л_beginBefore : XInteger32 )( $ Л_endBefore : XInteger32 )( $ Л_heldFor : XInteger32 )( $ Л_electedFor : XInteger32 ) : ElectionParamsT := 
all.v: Ife ( $ Л_electionId ?!= $ xInt0 ) { ( d1! ElectionParams_ι_m_electAt := $ Л_electionId ) >> 
all.v: (( ElectionParams_ι_m_electedFor , ElectionParams_ι_m_beginBefore , ElectionParams_ι_m_endBefore , ElectionParams_ι_m_heldFor , $ Л_ok )) := tvm_configParam (( $ xInt15 )) ) >> 
all.v: Ift ( ! $ Л_ok ) { ( d1! ElectionParams_ι_m_beginBefore := $ Л_beginBefore ) >> 
all.v: 	 ( d1! ElectionParams_ι_m_endBefore := $ Л_endBefore ) >> 
all.v: 	 ( d1! ElectionParams_ι_m_electedFor := $ Л_electedFor ) >> 
all.v: 	 ( d1! ElectionParams_ι_m_heldFor := $ Л_heldFor ) >> 
all.v:Definition StakingOwner_Ф_initTimer ( $ Л_timer : XAddress )( $ Л_period : XInteger ) : StakingOwnerT := 
all.v: 	 ( d1! StakingOwner_ι_m_timer := $ Л_timer ) >> 
all.v: 	 ( d1! StakingOwner_ι_m_timeout := $ Л_period ) >> 
all.v: 	 StakingOwner_Ф__settimer (( $ Л_timer , $ Л_period )) ) >> 
all.v:Definition StakingOwner_Ф_upgrade ( $ Л_newcode : TvmCell ) : StakingOwnerT := 
all.v: 	 tvm_setcode (( $ Л_newcode )) ) >> 
all.v: 	 tvm_setCurrentCode (( $ Л_newcode )) ) >> 
all.v:Definition RoundsBase_Ф__roundMoveStakes ( $ Л_source : XAddress )( $ Л_destination : XAddress )( $ Л_targetAmount : XInteger64 ) : RoundsBaseT XInteger64 := 
all.v: (( $ Л_roundId , $ Л_round , $ Л_ok )) := min () ) >> 
all.v: 	 ( d0! Л_transferred := $ xInt0 ) >> 
all.v: 	 while (( $ Л_ok && $ Л_targetAmount ?!= $ xInt0 ) { 
all.v: Ift ( $ Л_round ^^ RoundsBase_ι_Round_ι_step ?!= RoundsBase_ι_STEP_COMPLETED && $ Л_round ^^ RoundsBase_ι_Round_ι_step ?!= RoundsBase_ι_STEP_COMPLETING ) { (( RoundsBase_ι_m_rounds [ $ Л_roundId ] , $ Л_currentTransferred )) := RoundsBase_Ф__roundMoveStake (( $ Л_round , $ Л_source , $ Л_destination , $ Л_targetAmount )) ) >> 
all.v: 	 ( d0! Л_targetAmount -= $ Л_currentTransferred ) >> 
all.v: 	 ( d0! Л_transferred += $ Л_currentTransferred ) >> 
all.v: (( $ Л_roundId , $ Л_round , $ Л_ok )) := next (( $ Л_roundId )) ) >> 
all.v: return $ Л_transferred ) >> 
all.v:Definition StakingContract_Ф__completePendingRound ( $ Л_pendingRound : ι_Round )( $ Л_chunkSize : XInteger8 ) : StakingContractT ι_Round := 
all.v: Ife ( $ Л_pendingRound ^^ RoundsBase_ι_Round_ι_participantQty ?> $ Л_chunkSize ) { for (( ( d0! Л_i := $ xInt0 ) >> 
all.v: 	 $ Л_i ?< $ Л_pendingRound ^^ RoundsBase_ι_Round_ι_participantQty ) >> 
all.v: 	 ( d0! Л_i += $ Л_chunkSize ) { this ^^ StakingContract_Ф_completePendingRoundChunk . value (( 1e7 )) (( $ Л_pendingRound ^^ RoundsBase_ι_Round_ι_id , $ Л_chunkSize )) ) >> 
all.v: ( d0! Л_pendingRound := StakingContract_Ф__returnOrReinvest (( $ Л_pendingRound , $ Л_chunkSize )) ) >> 
all.v: return $ Л_pendingRound ) >> 
DePoolClass.v: 	localState_ι_elector_process_new_stake_Л_queryId : I64 ; 
DePoolClass.v: 	localState_ι_elector_process_new_stake_Л_validatorKey : I256 ; 
DePoolClass.v: 	localState_ι_elector_process_new_stake_Л_stakeAt : I32 ; 
DePoolClass.v: 	localState_ι_elector_process_new_stake_Л_maxFactor : I32 ; 
DePoolClass.v: 	localState_ι_elector_process_new_stake_Л_adnlAddr : I256 ; 
DePoolClass.v: 	localState_ι_elector_process_new_stake_Л_signature : I8 ; 
DePoolClass.v: 	localState_ι_elector_recover_stake_Л_queryId : I64 ; 
DePoolClass.v: 	localState_ι_receiveRewardStake_Л_roundId : I32 ; 
DePoolClass.v: 	localState_ι_receiveRewardStake_Л_reward : I64 ; 
DePoolClass.v: 	localState_ι_receiveRewardStake_Л_usualStake : I64 ; 
DePoolClass.v: 	localState_ι_receiveRewardStake_Л_vestingStake : I64 ; 
DePoolClass.v: 	localState_ι_receiveRewardStake_Л_reinvest : B ; 
DePoolClass.v: 	localState_ι_receiveRewardStake_Л_fee : I64 ; 
DePoolClass.v: 	localState_ι_receiveRewardStake_Л_reason : I8 ; 
DePoolClass.v: 	localState_ι_receiveAnswer_Л_errcode : I32 ; 
DePoolClass.v: 	localState_ι_receiveAnswer_Л_comment : I64 ; 
DePoolClass.v: 	localState_ι_process_new_stake_Л_queryId : I64 ; 
DePoolClass.v: 	localState_ι_process_new_stake_Л_validatorKey : I256 ; 
DePoolClass.v: 	localState_ι_process_new_stake_Л_stakeAt : I32 ; 
DePoolClass.v: 	localState_ι_process_new_stake_Л_maxFactor : I32 ; 
DePoolClass.v: 	localState_ι_process_new_stake_Л_adnlAddr : I256 ; 
DePoolClass.v: 	localState_ι_process_new_stake_Л_signature : I8 ; 
DePoolClass.v: 	localState_ι_recover_stake_Л_queryId : I64 ; 
DePoolClass.v: 	localState_ι_receiveConfirmation_Л_queryId : I64 ; 
DePoolClass.v: 	localState_ι_receiveConfirmation_Л_comment : I32 ; 
DePoolClass.v: 	localState_ι_receiveReturnedStake_Л_queryId : I64 ; 
DePoolClass.v: 	localState_ι_receiveReturnedStake_Л_comment : I32 ; 
DePoolClass.v: 	localState_ι_acceptRecoveredStake_Л_queryId : I64 ; 
DePoolClass.v: 	localState_ι_sendTransaction_Л_dest : A ; 
DePoolClass.v: 	localState_ι_sendTransaction_Л_value : I64 ; 
DePoolClass.v: 	localState_ι_sendTransaction_Л_bounce : B ; 
DePoolClass.v: 	localState_ι_sendTransaction_Л_flags : I16 ; 
DePoolClass.v: 	localState_ι_sendTransaction_Л_payload : C ; 
DePoolClass.v: 	localState_ι_withdrawOwnerReward_Л_amount : I64 ; 
DePoolClass.v: 	localState_ι__increaseOwnerReward_Л_ownerReward : I64 ; 
DePoolClass.v: 	localState_ι__recoverPendingRoundStakes_Л_pendingId : I32 ; 
DePoolClass.v: 	localState_ι__sendRequestToElector_Л_req : (@ ElectorBase_ι_RequestP I64 I256 I32 I8 ) ; 
DePoolClass.v: 	localState_ι__sendRequestToElector_Л_nodeStake : I64 ; 
DePoolClass.v: 	localState_ι__isRoundUnfrozen_Л_electAt : I32 ; 
DePoolClass.v: 	localState_ι__getNextElectionId_Л_utime_until : I32 ; 
DePoolClass.v: 	localState_ι__getNextElectionId_Л_ok : B ; 
DePoolClass.v: 	localState_ι__setAndGetNextElectAt_Л_nextElectAt : I32 ; 
DePoolClass.v: 	localState_ι__isElectionOver_Л_currentElectAt : I32 ; 
DePoolClass.v: 	localState_ι__haveVesting_Л_stakeholder : (@ StakeholderBase_ι_StakeholderP I64 B I32 A ) ; 
DePoolClass.v: 	localState_ι__stakeholderSetVesting_Л_stakeholder : (@ StakeholderBase_ι_StakeholderP I64 B I32 A ) ; 
DePoolClass.v: 	localState_ι__stakeholderSetVesting_Л_stake : I64 ; 
DePoolClass.v: 	localState_ι__stakeholderSetVesting_Л_withdrawalPeriod : I32 ; 
DePoolClass.v: 	localState_ι__stakeholderSetVesting_Л_periodPayment : I64 ; 
DePoolClass.v: 	localState_ι__stakeholderSetVesting_Л_vestingOwner : A ; 
DePoolClass.v: 	localState_ι__getStakeholder_Л_addr : A ; 
DePoolClass.v: 	localState_ι__stakeholderFetch_Л_addr : A ; 
DePoolClass.v: 	localState_ι__setOrDeleteStakeholder_Л_addr : A ; 
DePoolClass.v: 	localState_ι__setOrDeleteStakeholder_Л_stakeholder : (@ StakeholderBase_ι_StakeholderP I64 B I32 A ) ; 
DePoolClass.v: 	localState_ι__stakeholderAddStakeAndSetReinvest_Л_stakeholder : (@ StakeholderBase_ι_StakeholderP I64 B I32 A ) ; 
DePoolClass.v: 	localState_ι__stakeholderAddStakeAndSetReinvest_Л_deltaStake : I64 ; 
DePoolClass.v: 	localState_ι__stakeholderAddStakeAndSetReinvest_Л_reinvest : B ; 
DePoolClass.v: 	localState_ι__stakeholderRemoveStake_Л_addr : A ; 
DePoolClass.v: 	localState_ι__stakeholderRemoveStake_Л_removedStake : I64 ; 
DePoolClass.v: 	localState_ι__stakeholderRemoveStake_Л_unusedStake : I64 ; 
DePoolClass.v: 	localState_ι__stakeholderRemoveStake_Л_stakeholder : (@ StakeholderBase_ι_StakeholderP I64 B I32 A ) ; 
DePoolClass.v: 	localState_ι__stakeholderIncreaseStakeAndUnused_Л_stakeholder : (@ StakeholderBase_ι_StakeholderP I64 B I32 A ) ; 
DePoolClass.v: 	localState_ι__stakeholderIncreaseStakeAndUnused_Л_deltaStake : I64 ; 
DePoolClass.v: 	localState_ι__stakeholderIncreaseStakeAndUnused_Л_deltaUnused : I64 ; 
DePoolClass.v: 	localState_ι_stakeholderDecreaseStakeAndUnused_Л_stakeholder : (@ StakeholderBase_ι_StakeholderP I64 B I32 A ) ; 
DePoolClass.v: 	localState_ι_stakeholderDecreaseStakeAndUnused_Л_deltaStake : I64 ; 
DePoolClass.v: 	localState_ι_stakeholderDecreaseStakeAndUnused_Л_deltaUnused : I64 ; 
DePoolClass.v: 	localState_ι__stakeholderSetReinvest_Л_stakeholder : (@ StakeholderBase_ι_StakeholderP I64 B I32 A ) ; 
DePoolClass.v: 	localState_ι__stakeholderSetReinvest_Л_flag : B ; 
DePoolClass.v: 	localState_ι__stakeholderUpdateTotalStake_Л_stakeholder : (@ StakeholderBase_ι_StakeholderP I64 B I32 A ) ; 
DePoolClass.v: 	localState_ι__stakeholderUpdateTotalStake_Л_newStake : I64 ; 
DePoolClass.v: 	localState_ι__stakeholderUpdateTotalStake_Л_oldStake : I64 ; 
DePoolClass.v: 	localState_ι__stakeholderIncreaseUnusedStake_Л_stakeholder : (@ StakeholderBase_ι_StakeholderP I64 B I32 A ) ; 
DePoolClass.v: 	localState_ι__stakeholderIncreaseUnusedStake_Л_delta : I64 ; 
DePoolClass.v: 	localState_ι__stakeholderDecreaseUnusedStake_Л_stakeholder : (@ StakeholderBase_ι_StakeholderP I64 B I32 A ) ; 
DePoolClass.v: 	localState_ι__stakeholderDecreaseUnusedStake_Л_delta : I64 ; 
DePoolClass.v: 	localState_ι__stakeholderResetVesting_Л_stakeholder : (@ StakeholderBase_ι_StakeholderP I64 B I32 A ) ; 
DePoolClass.v: 	localState_ι__stakeholderUpdateLastPaymentTime_Л_stakeholder : (@ StakeholderBase_ι_StakeholderP I64 B I32 A ) ; 
DePoolClass.v: 	localState_ι__stakeholderUpdateLastPaymentTime_Л_periodQty : I64 ; 
DePoolClass.v: 	localState_ι_setTimer_Л_timer : I ; 
DePoolClass.v: 	localState_ι_updateStakingPoolAddress_Л_addr : A ; 
DePoolClass.v: 	localState_ι_initTimer_Л_timer : A ; 
DePoolClass.v: 	localState_ι_initTimer_Л_period : I ; 
DePoolClass.v: 	localState_ι__settimer_Л_timer : A ; 
DePoolClass.v: 	localState_ι__settimer_Л_period : I ; 
DePoolClass.v: 	localState_ι_onTimer_Л_timer : A ; 
DePoolClass.v: 	localState_ι_upgrade_Л_newcode : C ; 
DePoolClass.v: 	localState_ι_receive_confirmation_Л_queryId : I64 ; 
DePoolClass.v: 	localState_ι_receive_confirmation_Л_comment : I32 ; 
DePoolClass.v: 	localState_ι_receive_returned_stake_Л_queryId : I64 ; 
DePoolClass.v: 	localState_ι_receive_returned_stake_Л_comment : I32 ; 
DePoolClass.v: 	localState_ι_accept_recovered_stake_Л_queryId : I64 ; 
DePoolClass.v: 	localState_ι__addNewPoolingRound_Л_validationStart : I32 ; 
DePoolClass.v: 	localState_ι__addNewPoolingRound_Л_validationPeriod : I32 ; 
DePoolClass.v: 	localState_ι__setOldestRound_Л_round : (@ RoundsBase_ι_RoundP HM I32 I8 I64 A ) ; 
DePoolClass.v: 	localState_ι__getLastRound_Л_exists : B ; 
DePoolClass.v: 	localState_ι__setLastRound_Л_round : (@ RoundsBase_ι_RoundP HM I32 I8 I64 A ) ; 
DePoolClass.v: 	localState_ι__setPenultimateRound_Л_round : (@ RoundsBase_ι_RoundP HM I32 I8 I64 A ) ; 
DePoolClass.v: 	localState_ι__roundAddStakeAndVesting_Л_round : (@ RoundsBase_ι_RoundP HM I32 I8 I64 A ) ; 
DePoolClass.v: 	localState_ι__roundAddStakeAndVesting_Л_addr : A ; 
DePoolClass.v: 	localState_ι__roundAddStakeAndVesting_Л_stake : I64 ; 
DePoolClass.v: 	localState_ι__roundAddStakeAndVesting_Л_vestingStake : I64 ; 
DePoolClass.v: 	localState_ι__roundAddStakeAndVesting_Л_totalStake : I64 ; 
DePoolClass.v: 	localState_ι__roundMoveStakes_Л_source : A ; 
DePoolClass.v: 	localState_ι__roundMoveStakes_Л_destination : A ; 
DePoolClass.v: 	localState_ι__roundMoveStakes_Л_targetAmount : I64 ; 
DePoolClass.v: 	localState_ι__roundMoveStakes_Л_roundId : I64 ; 
DePoolClass.v: 	localState_ι__roundMoveStakes_Л_round : (@ RoundsBase_ι_RoundP HM I32 I8 I64 A ) ; 
DePoolClass.v: 	localState_ι__roundMoveStake_Л_round : (@ RoundsBase_ι_RoundP HM I32 I8 I64 A ) ; 
DePoolClass.v: 	localState_ι__roundMoveStake_Л_source : A ; 
DePoolClass.v: 	localState_ι__roundMoveStake_Л_destination : A ; 
DePoolClass.v: 	localState_ι__roundMoveStake_Л_amount : I64 ; 
DePoolClass.v: 	localState_ι__roundMoveStake_Л_exists : B ; 
DePoolClass.v: 	localState_ι__roundRemoveStakeInLastRound_Л_participant : A ; 
DePoolClass.v: 	localState_ι__roundRemoveStakeInLastRound_Л_targetAmount : I64 ; 
DePoolClass.v: 	localState_ι__roundRemoveStakeInLastRound_Л_minStake : I64 ; 
DePoolClass.v: 	localState_ι__roundRemoveStakeInLastRound_Л_unused : I64 ; 
DePoolClass.v: 	localState_ι__roundRemoveStakeInLastRound_Л_round : (@ RoundsBase_ι_RoundP HM I32 I8 I64 A ) ; 
DePoolClass.v: 	localState_ι__roundRemoveStakeInLastRound_Л_exists : B ; 
DePoolClass.v: 	localState_ι__addPendingRound_Л_round : (@ RoundsBase_ι_RoundP HM I32 I8 I64 A ) ; 
DePoolClass.v: 	localState_ι__removePendingRound_Л_pendingId : I32 ; 
DePoolClass.v: 	localState_ι__roundFetchPendingRound_Л_pendingId : I32 ; 
DePoolClass.v: 	localState_ι__setOrDeletePendingRound_Л_round : (@ RoundsBase_ι_RoundP HM I32 I8 I64 A ) ; 
DePoolClass.v: 	localState_ι__deletePendingRound_Л_id : I32 ; 
DePoolClass.v: 	localState_ι_sumOfStakes_Л_stakes : (@ RoundsBase_ι_StakeValueP I64 ) ; 
DePoolClass.v: 	localState_ι__getRoundsInfo_Л_index : I64 ; 
DePoolClass.v: 	localState_ι__getRoundsInfo_Л_round : (@ RoundsBase_ι_RoundP HM I32 I8 I64 A ) ; 
DePoolClass.v: 	localState_ι__getPendingRoundsInfo_Л_key : I32 ; 
DePoolClass.v: 	localState_ι__getPendingRoundsInfo_Л_round : (@ RoundsBase_ι_RoundP HM I32 I8 I64 A ) ; 
DePoolClass.v: 	localState_ι__checkPenultimateRound_Л_lb1Round : (@ RoundsBase_ι_RoundP HM I32 I8 I64 A ) ; 
DePoolClass.v: 	localState_ι__checkOldestRound_Л_oldestRound : (@ RoundsBase_ι_RoundP HM I32 I8 I64 A ) ; 
DePoolClass.v: 	localState_ι__calcLastRoundInterest_Л_totalStake : I64 ; 
DePoolClass.v: 	localState_ι__calcLastRoundInterest_Л_rewards : I64 ; 
DePoolClass.v: 	localState_ι__sendError_Л_errcode : I32 ; 
DePoolClass.v: 	localState_ι__sendError_Л_comment : I64 ; 
DePoolClass.v: 	localState_ι__sendAccept_Л_fee : I64 ; 
DePoolClass.v: 	localState_ι__requestStakesSigning_Л_round : (@ RoundsBase_ι_RoundP HM I32 I8 I64 A ) ; 
DePoolClass.v: 	localState_ι__requestStakesSigning_Л_roundStake : I64 ; 
DePoolClass.v: 	localState_ι__requestStakesSigning_Л_currentElectAt : I32 ; 
DePoolClass.v: 	localState_ι__requestStakesSigning_Л_roundStakeCheck : B ; 
DePoolClass.v: 	localState_ι__requestStakesSigning_Л_nodeStakeCheck : B ; 
DePoolClass.v: 	localState_ι__addRequest_Л_stakeAt : I32 ; 
DePoolClass.v: 	localState_ι__addRequest_Л_request : (@ ElectorBase_ι_RequestP I64 I256 I32 I8 ) ; 
DePoolClass.v: 	localState_ι__acceptPendingRoundStake_Л_pendingId : I32 ; 
DePoolClass.v: 	localState_ι__acceptPendingRoundStake_Л_exists : B ; 
DePoolClass.v: 	localState_ι__acceptUnusedStake_Л_lb1round : (@ RoundsBase_ι_RoundP HM I32 I8 I64 A ) ; 
DePoolClass.v: 	localState_ι__acceptRewardStake_Л_oldestRound : (@ RoundsBase_ι_RoundP HM I32 I8 I64 A ) ; 
DePoolClass.v: 	localState_ι__acceptRewardStake_Л_roundStake : I64 ; 
DePoolClass.v: 	localState_ι__completePendingRound_Л_pendingRound : (@ RoundsBase_ι_RoundP HM I32 I8 I64 A ) ; 
DePoolClass.v: 	localState_ι__completePendingRound_Л_chunkSize : I8 ; 
DePoolClass.v: 	localState_ι__completeRoundWithSpecialChunkSize_Л_completedRound : (@ RoundsBase_ι_RoundP HM I32 I8 I64 A ) ; 
DePoolClass.v: 	localState_ι__completeRoundWithSpecialChunkSize_Л_completionStatus : I8 ; 
DePoolClass.v: 	localState_ι__completeRoundWithSpecialChunkSize_Л_chunkSize : I8 ; 
DePoolClass.v: 	localState_ι__completeRound_Л_completedRound : (@ RoundsBase_ι_RoundP HM I32 I8 I64 A ) ; 
DePoolClass.v: 	localState_ι__completeRound_Л_completionStatus : I8 ; 
DePoolClass.v: 	localState_ι__returnOrReinvestForStakeholder_Л_completedRound : (@ RoundsBase_ι_RoundP HM I32 I8 I64 A ) ; 
DePoolClass.v: 	localState_ι__returnOrReinvestForStakeholder_Л_lastRound : (@ RoundsBase_ι_RoundP HM I32 I8 I64 A ) ; 
DePoolClass.v: 	localState_ι__returnOrReinvestForStakeholder_Л_addr : A ; 
DePoolClass.v: 	localState_ι__returnOrReinvestForStakeholder_Л_stakes : (@ RoundsBase_ι_StakeValueP I64 ) ; 
DePoolClass.v: 	localState_ι__returnOrReinvestForStakeholder_Л_newStake : I64 ; 
DePoolClass.v: 	localState_ι__returnOrReinvestForStakeholder_Л_newVesting : I64 ; 
DePoolClass.v: 	localState_ι__returnOrReinvestForStakeholder_Л_stakeSum : I64 ; 
DePoolClass.v: 	localState_ι__returnOrReinvest_Л_completedRound : (@ RoundsBase_ι_RoundP HM I32 I8 I64 A ) ; 
DePoolClass.v: 	localState_ι__returnOrReinvest_Л_chunkSize : I8 ; 
DePoolClass.v: 	localState_ι__getMsgValueAndSendErrorIfNeeded_Л_unused : I64 ; 
DePoolClass.v: 	localState_ι__getMsgValueAndSendErrorIfNeeded_Л_msgValue : I64 ; 
DePoolClass.v: 	localState_ι_investStake_Л_unusedStake : I64 ; 
DePoolClass.v: 	localState_ι_investStake_Л_reinvest : B ; 
DePoolClass.v: 	localState_ι_investStake_Л_stakeholder : (@ StakeholderBase_ι_StakeholderP I64 B I32 A ) ; 
DePoolClass.v: 	localState_ι_addVesting_Л_dest : A ; 
DePoolClass.v: 	localState_ι_addVesting_Л_withdrawalPeriod : I32 ; 
DePoolClass.v: 	localState_ι_addVesting_Л_totalPeriod : I32 ; 
DePoolClass.v: 	localState_ι_removeStake_Л_doRemoveFromCurrentRound : B ; 
DePoolClass.v: 	localState_ι_removeStake_Л_targetValue : I64 ; 
DePoolClass.v: 	localState_ι_setReinvest_Л_flag : B ; 
DePoolClass.v: 	localState_ι_transferStake_Л_destination : A ; 
DePoolClass.v: 	localState_ι_transferStake_Л_amount : I64 ; 
DePoolClass.v: 	localState_ι_transferStake_Л_sender : A ; 
DePoolClass.v: 	localState_ι_transferStake_Л_exists : B ; 
DePoolClass.v: 	localState_ι_processNewStake_Л_queryId : I64 ; 
DePoolClass.v: 	localState_ι_processNewStake_Л_validatorKey : I256 ; 
DePoolClass.v: 	localState_ι_processNewStake_Л_stakeAt : I32 ; 
DePoolClass.v: 	localState_ι_processNewStake_Л_maxFactor : I32 ; 
DePoolClass.v: 	localState_ι_processNewStake_Л_adnlAddr : I256 ; 
DePoolClass.v: 	localState_ι_processNewStake_Л_signature : I8 ; 
DePoolClass.v: 	localState_ι_ticktock_Л_electionsStarted : B ; 
DePoolClass.v: 	localState_ι_forceCompletePendingRound_Л_doCompleteOneChunk : B ; 
DePoolClass.v: 	localState_ι_forceCompletePendingRound_Л_chunkSize : I8 ; 
DePoolClass.v: 	localState_ι_completePendingRoundChunk_Л_roundId : I32 ; 
DePoolClass.v: 	localState_ι_completePendingRoundChunk_Л_chunkSize : I8 ; 
DePoolClass.v: 	localState_ι_receiveReturnedStake_Л_round : (@ RoundsBase_ι_RoundP HM I32 I8 I64 A ) ; 
DePoolClass.v: 	localState_ι_terminator_Л_chunkSize : I8 ; 
DePoolClass.v: 	localState_ι_getStakeholderInfo_Л_addr : A ; 
DePoolClass.v: 	localState_ι_getStakeholderInfo_Л_exists : B ; 
DePoolClass.v: 	localState_ι_getStakeholderInfo_Л_round : (@ RoundsBase_ι_RoundP HM I32 I8 I64 A ) ; 
DePoolClass.v: 	localState_ι_sendError_Л_queryId : I64 ; 
DePoolClass.v: 	localState_ι_sendError_Л_op : I32 
DePoolClass.v: 		@existT _ _ _ localState_ι_elector_process_new_stake_Л_queryId , 
DePoolClass.v: 		@existT _ _ _ localState_ι_elector_process_new_stake_Л_validatorKey , 
DePoolClass.v: 		@existT _ _ _ localState_ι_elector_process_new_stake_Л_stakeAt , 
DePoolClass.v: 		@existT _ _ _ localState_ι_elector_process_new_stake_Л_maxFactor , 
DePoolClass.v: 		@existT _ _ _ localState_ι_elector_process_new_stake_Л_adnlAddr , 
DePoolClass.v: 		@existT _ _ _ localState_ι_elector_process_new_stake_Л_signature , 
DePoolClass.v: 		@existT _ _ _ localState_ι_elector_recover_stake_Л_queryId , 
DePoolClass.v: 		@existT _ _ _ localState_ι_receiveRewardStake_Л_roundId , 
DePoolClass.v: 		@existT _ _ _ localState_ι_receiveRewardStake_Л_reward , 
DePoolClass.v: 		@existT _ _ _ localState_ι_receiveRewardStake_Л_usualStake , 
DePoolClass.v: 		@existT _ _ _ localState_ι_receiveRewardStake_Л_vestingStake , 
DePoolClass.v: 		@existT _ _ _ localState_ι_receiveRewardStake_Л_reinvest , 
DePoolClass.v: 		@existT _ _ _ localState_ι_receiveRewardStake_Л_fee , 
DePoolClass.v: 		@existT _ _ _ localState_ι_receiveRewardStake_Л_reason , 
DePoolClass.v: 		@existT _ _ _ localState_ι_receiveAnswer_Л_errcode , 
DePoolClass.v: 		@existT _ _ _ localState_ι_receiveAnswer_Л_comment , 
DePoolClass.v: 		@existT _ _ _ localState_ι_process_new_stake_Л_queryId , 
DePoolClass.v: 		@existT _ _ _ localState_ι_process_new_stake_Л_validatorKey , 
DePoolClass.v: 		@existT _ _ _ localState_ι_process_new_stake_Л_stakeAt , 
DePoolClass.v: 		@existT _ _ _ localState_ι_process_new_stake_Л_maxFactor , 
DePoolClass.v: 		@existT _ _ _ localState_ι_process_new_stake_Л_adnlAddr , 
DePoolClass.v: 		@existT _ _ _ localState_ι_process_new_stake_Л_signature , 
DePoolClass.v: 		@existT _ _ _ localState_ι_recover_stake_Л_queryId , 
DePoolClass.v: 		@existT _ _ _ localState_ι_receiveConfirmation_Л_queryId , 
DePoolClass.v: 		@existT _ _ _ localState_ι_receiveConfirmation_Л_comment , 
DePoolClass.v: 		@existT _ _ _ localState_ι_receiveReturnedStake_Л_queryId , 
DePoolClass.v: 		@existT _ _ _ localState_ι_receiveReturnedStake_Л_comment , 
DePoolClass.v: 		@existT _ _ _ localState_ι_acceptRecoveredStake_Л_queryId , 
DePoolClass.v: 		@existT _ _ _ localState_ι_sendTransaction_Л_dest , 
DePoolClass.v: 		@existT _ _ _ localState_ι_sendTransaction_Л_value , 
DePoolClass.v: 		@existT _ _ _ localState_ι_sendTransaction_Л_bounce , 
DePoolClass.v: 		@existT _ _ _ localState_ι_sendTransaction_Л_flags , 
DePoolClass.v: 		@existT _ _ _ localState_ι_sendTransaction_Л_payload , 
DePoolClass.v: 		@existT _ _ _ localState_ι_withdrawOwnerReward_Л_amount , 
DePoolClass.v: 		@existT _ _ _ localState_ι__increaseOwnerReward_Л_ownerReward , 
DePoolClass.v: 		@existT _ _ _ localState_ι__recoverPendingRoundStakes_Л_pendingId , 
DePoolClass.v: 		@existT _ _ _ localState_ι__sendRequestToElector_Л_req , 
DePoolClass.v: 		@existT _ _ _ localState_ι__sendRequestToElector_Л_nodeStake , 
DePoolClass.v: 		@existT _ _ _ localState_ι__isRoundUnfrozen_Л_electAt , 
DePoolClass.v: 		@existT _ _ _ localState_ι__getNextElectionId_Л_utime_until , 
DePoolClass.v: 		@existT _ _ _ localState_ι__getNextElectionId_Л_ok , 
DePoolClass.v: 		@existT _ _ _ localState_ι__setAndGetNextElectAt_Л_nextElectAt , 
DePoolClass.v: 		@existT _ _ _ localState_ι__isElectionOver_Л_currentElectAt , 
DePoolClass.v: 		@existT _ _ _ localState_ι__haveVesting_Л_stakeholder , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderSetVesting_Л_stakeholder , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderSetVesting_Л_stake , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderSetVesting_Л_withdrawalPeriod , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderSetVesting_Л_periodPayment , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderSetVesting_Л_vestingOwner , 
DePoolClass.v: 		@existT _ _ _ localState_ι__getStakeholder_Л_addr , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderFetch_Л_addr , 
DePoolClass.v: 		@existT _ _ _ localState_ι__setOrDeleteStakeholder_Л_addr , 
DePoolClass.v: 		@existT _ _ _ localState_ι__setOrDeleteStakeholder_Л_stakeholder , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderAddStakeAndSetReinvest_Л_stakeholder , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderAddStakeAndSetReinvest_Л_deltaStake , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderAddStakeAndSetReinvest_Л_reinvest , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderRemoveStake_Л_addr , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderRemoveStake_Л_removedStake , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderRemoveStake_Л_unusedStake , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderRemoveStake_Л_stakeholder , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderIncreaseStakeAndUnused_Л_stakeholder , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderIncreaseStakeAndUnused_Л_deltaStake , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderIncreaseStakeAndUnused_Л_deltaUnused , 
DePoolClass.v: 		@existT _ _ _ localState_ι_stakeholderDecreaseStakeAndUnused_Л_stakeholder , 
DePoolClass.v: 		@existT _ _ _ localState_ι_stakeholderDecreaseStakeAndUnused_Л_deltaStake , 
DePoolClass.v: 		@existT _ _ _ localState_ι_stakeholderDecreaseStakeAndUnused_Л_deltaUnused , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderSetReinvest_Л_stakeholder , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderSetReinvest_Л_flag , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderUpdateTotalStake_Л_stakeholder , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderUpdateTotalStake_Л_newStake , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderUpdateTotalStake_Л_oldStake , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderIncreaseUnusedStake_Л_stakeholder , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderIncreaseUnusedStake_Л_delta , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderDecreaseUnusedStake_Л_stakeholder , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderDecreaseUnusedStake_Л_delta , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderResetVesting_Л_stakeholder , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderUpdateLastPaymentTime_Л_stakeholder , 
DePoolClass.v: 		@existT _ _ _ localState_ι__stakeholderUpdateLastPaymentTime_Л_periodQty , 
DePoolClass.v: 		@existT _ _ _ localState_ι_setTimer_Л_timer , 
DePoolClass.v: 		@existT _ _ _ localState_ι_updateStakingPoolAddress_Л_addr , 
DePoolClass.v: 		@existT _ _ _ localState_ι_initTimer_Л_timer , 
DePoolClass.v: 		@existT _ _ _ localState_ι_initTimer_Л_period , 
DePoolClass.v: 		@existT _ _ _ localState_ι__settimer_Л_timer , 
DePoolClass.v: 		@existT _ _ _ localState_ι__settimer_Л_period , 
DePoolClass.v: 		@existT _ _ _ localState_ι_onTimer_Л_timer , 
DePoolClass.v: 		@existT _ _ _ localState_ι_upgrade_Л_newcode , 
DePoolClass.v: 		@existT _ _ _ localState_ι_receive_confirmation_Л_queryId , 
DePoolClass.v: 		@existT _ _ _ localState_ι_receive_confirmation_Л_comment , 
DePoolClass.v: 		@existT _ _ _ localState_ι_receive_returned_stake_Л_queryId , 
DePoolClass.v: 		@existT _ _ _ localState_ι_receive_returned_stake_Л_comment , 
DePoolClass.v: 		@existT _ _ _ localState_ι_accept_recovered_stake_Л_queryId , 
DePoolClass.v: 		@existT _ _ _ localState_ι__addNewPoolingRound_Л_validationStart , 
DePoolClass.v: 		@existT _ _ _ localState_ι__addNewPoolingRound_Л_validationPeriod , 
DePoolClass.v: 		@existT _ _ _ localState_ι__setOldestRound_Л_round , 
DePoolClass.v: 		@existT _ _ _ localState_ι__getLastRound_Л_exists , 
DePoolClass.v: 		@existT _ _ _ localState_ι__setLastRound_Л_round , 
DePoolClass.v: 		@existT _ _ _ localState_ι__setPenultimateRound_Л_round , 
DePoolClass.v: 		@existT _ _ _ localState_ι__roundAddStakeAndVesting_Л_round , 
DePoolClass.v: 		@existT _ _ _ localState_ι__roundAddStakeAndVesting_Л_addr , 
DePoolClass.v: 		@existT _ _ _ localState_ι__roundAddStakeAndVesting_Л_stake , 
DePoolClass.v: 		@existT _ _ _ localState_ι__roundAddStakeAndVesting_Л_vestingStake , 
DePoolClass.v: 		@existT _ _ _ localState_ι__roundAddStakeAndVesting_Л_totalStake , 
DePoolClass.v: 		@existT _ _ _ localState_ι__roundMoveStakes_Л_source , 
DePoolClass.v: 		@existT _ _ _ localState_ι__roundMoveStakes_Л_destination , 
DePoolClass.v: 		@existT _ _ _ localState_ι__roundMoveStakes_Л_targetAmount , 
DePoolClass.v: 		@existT _ _ _ localState_ι__roundMoveStakes_Л_roundId , 
DePoolClass.v: 		@existT _ _ _ localState_ι__roundMoveStakes_Л_round , 
DePoolClass.v: 		@existT _ _ _ localState_ι__roundMoveStake_Л_round , 
DePoolClass.v: 		@existT _ _ _ localState_ι__roundMoveStake_Л_source , 
DePoolClass.v: 		@existT _ _ _ localState_ι__roundMoveStake_Л_destination , 
DePoolClass.v: 		@existT _ _ _ localState_ι__roundMoveStake_Л_amount , 
DePoolClass.v: 		@existT _ _ _ localState_ι__roundMoveStake_Л_exists , 
DePoolClass.v: 		@existT _ _ _ localState_ι__roundRemoveStakeInLastRound_Л_participant , 
DePoolClass.v: 		@existT _ _ _ localState_ι__roundRemoveStakeInLastRound_Л_targetAmount , 
DePoolClass.v: 		@existT _ _ _ localState_ι__roundRemoveStakeInLastRound_Л_minStake , 
DePoolClass.v: 		@existT _ _ _ localState_ι__roundRemoveStakeInLastRound_Л_unused , 
DePoolClass.v: 		@existT _ _ _ localState_ι__roundRemoveStakeInLastRound_Л_round , 
DePoolClass.v: 		@existT _ _ _ localState_ι__roundRemoveStakeInLastRound_Л_exists , 
DePoolClass.v: 		@existT _ _ _ localState_ι__addPendingRound_Л_round , 
DePoolClass.v: 		@existT _ _ _ localState_ι__removePendingRound_Л_pendingId , 
DePoolClass.v: 		@existT _ _ _ localState_ι__roundFetchPendingRound_Л_pendingId , 
DePoolClass.v: 		@existT _ _ _ localState_ι__setOrDeletePendingRound_Л_round , 
DePoolClass.v: 		@existT _ _ _ localState_ι__deletePendingRound_Л_id , 
DePoolClass.v: 		@existT _ _ _ localState_ι_sumOfStakes_Л_stakes , 
DePoolClass.v: 		@existT _ _ _ localState_ι__getRoundsInfo_Л_index , 
DePoolClass.v: 		@existT _ _ _ localState_ι__getRoundsInfo_Л_round , 
DePoolClass.v: 		@existT _ _ _ localState_ι__getPendingRoundsInfo_Л_key , 
DePoolClass.v: 		@existT _ _ _ localState_ι__getPendingRoundsInfo_Л_round , 
DePoolClass.v: 		@existT _ _ _ localState_ι__checkPenultimateRound_Л_lb1Round , 
DePoolClass.v: 		@existT _ _ _ localState_ι__checkOldestRound_Л_oldestRound , 
DePoolClass.v: 		@existT _ _ _ localState_ι__calcLastRoundInterest_Л_totalStake , 
DePoolClass.v: 		@existT _ _ _ localState_ι__calcLastRoundInterest_Л_rewards , 
DePoolClass.v: 		@existT _ _ _ localState_ι__sendError_Л_errcode , 
DePoolClass.v: 		@existT _ _ _ localState_ι__sendError_Л_comment , 
DePoolClass.v: 		@existT _ _ _ localState_ι__sendAccept_Л_fee , 
DePoolClass.v: 		@existT _ _ _ localState_ι__requestStakesSigning_Л_round , 
DePoolClass.v: 		@existT _ _ _ localState_ι__requestStakesSigning_Л_roundStake , 
DePoolClass.v: 		@existT _ _ _ localState_ι__requestStakesSigning_Л_currentElectAt , 
DePoolClass.v: 		@existT _ _ _ localState_ι__requestStakesSigning_Л_roundStakeCheck , 
DePoolClass.v: 		@existT _ _ _ localState_ι__requestStakesSigning_Л_nodeStakeCheck , 
DePoolClass.v: 		@existT _ _ _ localState_ι__addRequest_Л_stakeAt , 
DePoolClass.v: 		@existT _ _ _ localState_ι__addRequest_Л_request , 
DePoolClass.v: 		@existT _ _ _ localState_ι__acceptPendingRoundStake_Л_pendingId , 
DePoolClass.v: 		@existT _ _ _ localState_ι__acceptPendingRoundStake_Л_exists , 
DePoolClass.v: 		@existT _ _ _ localState_ι__acceptUnusedStake_Л_lb1round , 
DePoolClass.v: 		@existT _ _ _ localState_ι__acceptRewardStake_Л_oldestRound , 
DePoolClass.v: 		@existT _ _ _ localState_ι__acceptRewardStake_Л_roundStake , 
DePoolClass.v: 		@existT _ _ _ localState_ι__completePendingRound_Л_pendingRound , 
DePoolClass.v: 		@existT _ _ _ localState_ι__completePendingRound_Л_chunkSize , 
DePoolClass.v: 		@existT _ _ _ localState_ι__completeRoundWithSpecialChunkSize_Л_completedRound , 
DePoolClass.v: 		@existT _ _ _ localState_ι__completeRoundWithSpecialChunkSize_Л_completionStatus , 
DePoolClass.v: 		@existT _ _ _ localState_ι__completeRoundWithSpecialChunkSize_Л_chunkSize , 
DePoolClass.v: 		@existT _ _ _ localState_ι__completeRound_Л_completedRound , 
DePoolClass.v: 		@existT _ _ _ localState_ι__completeRound_Л_completionStatus , 
DePoolClass.v: 		@existT _ _ _ localState_ι__returnOrReinvestForStakeholder_Л_completedRound , 
DePoolClass.v: 		@existT _ _ _ localState_ι__returnOrReinvestForStakeholder_Л_lastRound , 
DePoolClass.v: 		@existT _ _ _ localState_ι__returnOrReinvestForStakeholder_Л_addr , 
DePoolClass.v: 		@existT _ _ _ localState_ι__returnOrReinvestForStakeholder_Л_stakes , 
DePoolClass.v: 		@existT _ _ _ localState_ι__returnOrReinvestForStakeholder_Л_newStake , 
DePoolClass.v: 		@existT _ _ _ localState_ι__returnOrReinvestForStakeholder_Л_newVesting , 
DePoolClass.v: 		@existT _ _ _ localState_ι__returnOrReinvestForStakeholder_Л_stakeSum , 
DePoolClass.v: 		@existT _ _ _ localState_ι__returnOrReinvest_Л_completedRound , 
DePoolClass.v: 		@existT _ _ _ localState_ι__returnOrReinvest_Л_chunkSize , 
DePoolClass.v: 		@existT _ _ _ localState_ι__getMsgValueAndSendErrorIfNeeded_Л_unused , 
DePoolClass.v: 		@existT _ _ _ localState_ι__getMsgValueAndSendErrorIfNeeded_Л_msgValue , 
DePoolClass.v: 		@existT _ _ _ localState_ι_investStake_Л_unusedStake , 
DePoolClass.v: 		@existT _ _ _ localState_ι_investStake_Л_reinvest , 
DePoolClass.v: 		@existT _ _ _ localState_ι_investStake_Л_stakeholder , 
DePoolClass.v: 		@existT _ _ _ localState_ι_addVesting_Л_dest , 
DePoolClass.v: 		@existT _ _ _ localState_ι_addVesting_Л_withdrawalPeriod , 
DePoolClass.v: 		@existT _ _ _ localState_ι_addVesting_Л_totalPeriod , 
DePoolClass.v: 		@existT _ _ _ localState_ι_removeStake_Л_doRemoveFromCurrentRound , 
DePoolClass.v: 		@existT _ _ _ localState_ι_removeStake_Л_targetValue , 
DePoolClass.v: 		@existT _ _ _ localState_ι_setReinvest_Л_flag , 
DePoolClass.v: 		@existT _ _ _ localState_ι_transferStake_Л_destination , 
DePoolClass.v: 		@existT _ _ _ localState_ι_transferStake_Л_amount , 
DePoolClass.v: 		@existT _ _ _ localState_ι_transferStake_Л_sender , 
DePoolClass.v: 		@existT _ _ _ localState_ι_transferStake_Л_exists , 
DePoolClass.v: 		@existT _ _ _ localState_ι_processNewStake_Л_queryId , 
DePoolClass.v: 		@existT _ _ _ localState_ι_processNewStake_Л_validatorKey , 
DePoolClass.v: 		@existT _ _ _ localState_ι_processNewStake_Л_stakeAt , 
DePoolClass.v: 		@existT _ _ _ localState_ι_processNewStake_Л_maxFactor , 
DePoolClass.v: 		@existT _ _ _ localState_ι_processNewStake_Л_adnlAddr , 
DePoolClass.v: 		@existT _ _ _ localState_ι_processNewStake_Л_signature , 
DePoolClass.v: 		@existT _ _ _ localState_ι_ticktock_Л_electionsStarted , 
DePoolClass.v: 		@existT _ _ _ localState_ι_forceCompletePendingRound_Л_doCompleteOneChunk , 
DePoolClass.v: 		@existT _ _ _ localState_ι_forceCompletePendingRound_Л_chunkSize , 
DePoolClass.v: 		@existT _ _ _ localState_ι_completePendingRoundChunk_Л_roundId , 
DePoolClass.v: 		@existT _ _ _ localState_ι_completePendingRoundChunk_Л_chunkSize , 
DePoolClass.v: 		@existT _ _ _ localState_ι_receiveReturnedStake_Л_round , 
DePoolClass.v: 		@existT _ _ _ localState_ι_terminator_Л_chunkSize , 
DePoolClass.v: 		@existT _ _ _ localState_ι_getStakeholderInfo_Л_addr , 
DePoolClass.v: 		@existT _ _ _ localState_ι_getStakeholderInfo_Л_exists , 
DePoolClass.v: 		@existT _ _ _ localState_ι_getStakeholderInfo_Л_round , 
DePoolClass.v: 		@existT _ _ _ localState_ι_sendError_Л_queryId , 
DePoolClass.v: 		@existT _ _ _ localState_ι_sendError_Л_op 
DePoolClass.v:Global Instance Acc_localState_ι_elector_process_new_stake_Л_queryId : Accessor localState_ι_elector_process_new_stake_Л_queryId :=  {  acc := ·0  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_elector_process_new_stake_Л_validatorKey : Accessor localState_ι_elector_process_new_stake_Л_validatorKey :=  {  acc := ·1  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_elector_process_new_stake_Л_stakeAt : Accessor localState_ι_elector_process_new_stake_Л_stakeAt :=  {  acc := ·2  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_elector_process_new_stake_Л_maxFactor : Accessor localState_ι_elector_process_new_stake_Л_maxFactor :=  {  acc := ·3  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_elector_process_new_stake_Л_adnlAddr : Accessor localState_ι_elector_process_new_stake_Л_adnlAddr :=  {  acc := ·4  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_elector_process_new_stake_Л_signature : Accessor localState_ι_elector_process_new_stake_Л_signature :=  {  acc := ·5  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_elector_recover_stake_Л_queryId : Accessor localState_ι_elector_recover_stake_Л_queryId :=  {  acc := ·6  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_receiveRewardStake_Л_roundId : Accessor localState_ι_receiveRewardStake_Л_roundId :=  {  acc := ·7  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_receiveRewardStake_Л_reward : Accessor localState_ι_receiveRewardStake_Л_reward :=  {  acc := ·8  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_receiveRewardStake_Л_usualStake : Accessor localState_ι_receiveRewardStake_Л_usualStake :=  {  acc := ·9  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_receiveRewardStake_Л_vestingStake : Accessor localState_ι_receiveRewardStake_Л_vestingStake :=  {  acc := ·10  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_receiveRewardStake_Л_reinvest : Accessor localState_ι_receiveRewardStake_Л_reinvest :=  {  acc := ·11  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_receiveRewardStake_Л_fee : Accessor localState_ι_receiveRewardStake_Л_fee :=  {  acc := ·12  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_receiveRewardStake_Л_reason : Accessor localState_ι_receiveRewardStake_Л_reason :=  {  acc := ·13  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_receiveAnswer_Л_errcode : Accessor localState_ι_receiveAnswer_Л_errcode :=  {  acc := ·14  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_receiveAnswer_Л_comment : Accessor localState_ι_receiveAnswer_Л_comment :=  {  acc := ·15  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_process_new_stake_Л_queryId : Accessor localState_ι_process_new_stake_Л_queryId :=  {  acc := ·16  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_process_new_stake_Л_validatorKey : Accessor localState_ι_process_new_stake_Л_validatorKey :=  {  acc := ·17  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_process_new_stake_Л_stakeAt : Accessor localState_ι_process_new_stake_Л_stakeAt :=  {  acc := ·18  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_process_new_stake_Л_maxFactor : Accessor localState_ι_process_new_stake_Л_maxFactor :=  {  acc := ·19  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_process_new_stake_Л_adnlAddr : Accessor localState_ι_process_new_stake_Л_adnlAddr :=  {  acc := ·20  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_process_new_stake_Л_signature : Accessor localState_ι_process_new_stake_Л_signature :=  {  acc := ·21  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_recover_stake_Л_queryId : Accessor localState_ι_recover_stake_Л_queryId :=  {  acc := ·22  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_receiveConfirmation_Л_queryId : Accessor localState_ι_receiveConfirmation_Л_queryId :=  {  acc := ·23  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_receiveConfirmation_Л_comment : Accessor localState_ι_receiveConfirmation_Л_comment :=  {  acc := ·24  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_receiveReturnedStake_Л_queryId : Accessor localState_ι_receiveReturnedStake_Л_queryId :=  {  acc := ·25  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_receiveReturnedStake_Л_comment : Accessor localState_ι_receiveReturnedStake_Л_comment :=  {  acc := ·26  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_acceptRecoveredStake_Л_queryId : Accessor localState_ι_acceptRecoveredStake_Л_queryId :=  {  acc := ·27  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_sendTransaction_Л_dest : Accessor localState_ι_sendTransaction_Л_dest :=  {  acc := ·28  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_sendTransaction_Л_value : Accessor localState_ι_sendTransaction_Л_value :=  {  acc := ·29  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_sendTransaction_Л_bounce : Accessor localState_ι_sendTransaction_Л_bounce :=  {  acc := ·30  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_sendTransaction_Л_flags : Accessor localState_ι_sendTransaction_Л_flags :=  {  acc := ·31  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_sendTransaction_Л_payload : Accessor localState_ι_sendTransaction_Л_payload :=  {  acc := ·32  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_withdrawOwnerReward_Л_amount : Accessor localState_ι_withdrawOwnerReward_Л_amount :=  {  acc := ·33  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__increaseOwnerReward_Л_ownerReward : Accessor localState_ι__increaseOwnerReward_Л_ownerReward :=  {  acc := ·34  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__recoverPendingRoundStakes_Л_pendingId : Accessor localState_ι__recoverPendingRoundStakes_Л_pendingId :=  {  acc := ·35  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__sendRequestToElector_Л_req : Accessor localState_ι__sendRequestToElector_Л_req :=  {  acc := ·36  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__sendRequestToElector_Л_nodeStake : Accessor localState_ι__sendRequestToElector_Л_nodeStake :=  {  acc := ·37  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__isRoundUnfrozen_Л_electAt : Accessor localState_ι__isRoundUnfrozen_Л_electAt :=  {  acc := ·38  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__getNextElectionId_Л_utime_until : Accessor localState_ι__getNextElectionId_Л_utime_until :=  {  acc := ·39  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__getNextElectionId_Л_ok : Accessor localState_ι__getNextElectionId_Л_ok :=  {  acc := ·40  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__setAndGetNextElectAt_Л_nextElectAt : Accessor localState_ι__setAndGetNextElectAt_Л_nextElectAt :=  {  acc := ·41  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__isElectionOver_Л_currentElectAt : Accessor localState_ι__isElectionOver_Л_currentElectAt :=  {  acc := ·42  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__haveVesting_Л_stakeholder : Accessor localState_ι__haveVesting_Л_stakeholder :=  {  acc := ·43  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderSetVesting_Л_stakeholder : Accessor localState_ι__stakeholderSetVesting_Л_stakeholder :=  {  acc := ·44  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderSetVesting_Л_stake : Accessor localState_ι__stakeholderSetVesting_Л_stake :=  {  acc := ·45  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderSetVesting_Л_withdrawalPeriod : Accessor localState_ι__stakeholderSetVesting_Л_withdrawalPeriod :=  {  acc := ·46  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderSetVesting_Л_periodPayment : Accessor localState_ι__stakeholderSetVesting_Л_periodPayment :=  {  acc := ·47  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderSetVesting_Л_vestingOwner : Accessor localState_ι__stakeholderSetVesting_Л_vestingOwner :=  {  acc := ·48  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__getStakeholder_Л_addr : Accessor localState_ι__getStakeholder_Л_addr :=  {  acc := ·49  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderFetch_Л_addr : Accessor localState_ι__stakeholderFetch_Л_addr :=  {  acc := ·50  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__setOrDeleteStakeholder_Л_addr : Accessor localState_ι__setOrDeleteStakeholder_Л_addr :=  {  acc := ·51  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__setOrDeleteStakeholder_Л_stakeholder : Accessor localState_ι__setOrDeleteStakeholder_Л_stakeholder :=  {  acc := ·52  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderAddStakeAndSetReinvest_Л_stakeholder : Accessor localState_ι__stakeholderAddStakeAndSetReinvest_Л_stakeholder :=  {  acc := ·53  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderAddStakeAndSetReinvest_Л_deltaStake : Accessor localState_ι__stakeholderAddStakeAndSetReinvest_Л_deltaStake :=  {  acc := ·54  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderAddStakeAndSetReinvest_Л_reinvest : Accessor localState_ι__stakeholderAddStakeAndSetReinvest_Л_reinvest :=  {  acc := ·55  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderRemoveStake_Л_addr : Accessor localState_ι__stakeholderRemoveStake_Л_addr :=  {  acc := ·56  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderRemoveStake_Л_removedStake : Accessor localState_ι__stakeholderRemoveStake_Л_removedStake :=  {  acc := ·57  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderRemoveStake_Л_unusedStake : Accessor localState_ι__stakeholderRemoveStake_Л_unusedStake :=  {  acc := ·58  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderRemoveStake_Л_stakeholder : Accessor localState_ι__stakeholderRemoveStake_Л_stakeholder :=  {  acc := ·59  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderIncreaseStakeAndUnused_Л_stakeholder : Accessor localState_ι__stakeholderIncreaseStakeAndUnused_Л_stakeholder :=  {  acc := ·60  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderIncreaseStakeAndUnused_Л_deltaStake : Accessor localState_ι__stakeholderIncreaseStakeAndUnused_Л_deltaStake :=  {  acc := ·61  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderIncreaseStakeAndUnused_Л_deltaUnused : Accessor localState_ι__stakeholderIncreaseStakeAndUnused_Л_deltaUnused :=  {  acc := ·62  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_stakeholderDecreaseStakeAndUnused_Л_stakeholder : Accessor localState_ι_stakeholderDecreaseStakeAndUnused_Л_stakeholder :=  {  acc := ·63  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_stakeholderDecreaseStakeAndUnused_Л_deltaStake : Accessor localState_ι_stakeholderDecreaseStakeAndUnused_Л_deltaStake :=  {  acc := ·64  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_stakeholderDecreaseStakeAndUnused_Л_deltaUnused : Accessor localState_ι_stakeholderDecreaseStakeAndUnused_Л_deltaUnused :=  {  acc := ·65  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderSetReinvest_Л_stakeholder : Accessor localState_ι__stakeholderSetReinvest_Л_stakeholder :=  {  acc := ·66  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderSetReinvest_Л_flag : Accessor localState_ι__stakeholderSetReinvest_Л_flag :=  {  acc := ·67  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderUpdateTotalStake_Л_stakeholder : Accessor localState_ι__stakeholderUpdateTotalStake_Л_stakeholder :=  {  acc := ·68  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderUpdateTotalStake_Л_newStake : Accessor localState_ι__stakeholderUpdateTotalStake_Л_newStake :=  {  acc := ·69  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderUpdateTotalStake_Л_oldStake : Accessor localState_ι__stakeholderUpdateTotalStake_Л_oldStake :=  {  acc := ·70  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderIncreaseUnusedStake_Л_stakeholder : Accessor localState_ι__stakeholderIncreaseUnusedStake_Л_stakeholder :=  {  acc := ·71  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderIncreaseUnusedStake_Л_delta : Accessor localState_ι__stakeholderIncreaseUnusedStake_Л_delta :=  {  acc := ·72  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderDecreaseUnusedStake_Л_stakeholder : Accessor localState_ι__stakeholderDecreaseUnusedStake_Л_stakeholder :=  {  acc := ·73  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderDecreaseUnusedStake_Л_delta : Accessor localState_ι__stakeholderDecreaseUnusedStake_Л_delta :=  {  acc := ·74  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderResetVesting_Л_stakeholder : Accessor localState_ι__stakeholderResetVesting_Л_stakeholder :=  {  acc := ·75  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderUpdateLastPaymentTime_Л_stakeholder : Accessor localState_ι__stakeholderUpdateLastPaymentTime_Л_stakeholder :=  {  acc := ·76  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__stakeholderUpdateLastPaymentTime_Л_periodQty : Accessor localState_ι__stakeholderUpdateLastPaymentTime_Л_periodQty :=  {  acc := ·77  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_setTimer_Л_timer : Accessor localState_ι_setTimer_Л_timer :=  {  acc := ·78  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_updateStakingPoolAddress_Л_addr : Accessor localState_ι_updateStakingPoolAddress_Л_addr :=  {  acc := ·79  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_initTimer_Л_timer : Accessor localState_ι_initTimer_Л_timer :=  {  acc := ·80  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_initTimer_Л_period : Accessor localState_ι_initTimer_Л_period :=  {  acc := ·81  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__settimer_Л_timer : Accessor localState_ι__settimer_Л_timer :=  {  acc := ·82  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__settimer_Л_period : Accessor localState_ι__settimer_Л_period :=  {  acc := ·83  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_onTimer_Л_timer : Accessor localState_ι_onTimer_Л_timer :=  {  acc := ·84  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_upgrade_Л_newcode : Accessor localState_ι_upgrade_Л_newcode :=  {  acc := ·85  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_receive_confirmation_Л_queryId : Accessor localState_ι_receive_confirmation_Л_queryId :=  {  acc := ·86  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_receive_confirmation_Л_comment : Accessor localState_ι_receive_confirmation_Л_comment :=  {  acc := ·87  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_receive_returned_stake_Л_queryId : Accessor localState_ι_receive_returned_stake_Л_queryId :=  {  acc := ·88  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_receive_returned_stake_Л_comment : Accessor localState_ι_receive_returned_stake_Л_comment :=  {  acc := ·89  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_accept_recovered_stake_Л_queryId : Accessor localState_ι_accept_recovered_stake_Л_queryId :=  {  acc := ·90  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__addNewPoolingRound_Л_validationStart : Accessor localState_ι__addNewPoolingRound_Л_validationStart :=  {  acc := ·91  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__addNewPoolingRound_Л_validationPeriod : Accessor localState_ι__addNewPoolingRound_Л_validationPeriod :=  {  acc := ·92  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__setOldestRound_Л_round : Accessor localState_ι__setOldestRound_Л_round :=  {  acc := ·93  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__getLastRound_Л_exists : Accessor localState_ι__getLastRound_Л_exists :=  {  acc := ·94  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__setLastRound_Л_round : Accessor localState_ι__setLastRound_Л_round :=  {  acc := ·95  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__setPenultimateRound_Л_round : Accessor localState_ι__setPenultimateRound_Л_round :=  {  acc := ·96  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__roundAddStakeAndVesting_Л_round : Accessor localState_ι__roundAddStakeAndVesting_Л_round :=  {  acc := ·97  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__roundAddStakeAndVesting_Л_addr : Accessor localState_ι__roundAddStakeAndVesting_Л_addr :=  {  acc := ·98  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__roundAddStakeAndVesting_Л_stake : Accessor localState_ι__roundAddStakeAndVesting_Л_stake :=  {  acc := ·99  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__roundAddStakeAndVesting_Л_vestingStake : Accessor localState_ι__roundAddStakeAndVesting_Л_vestingStake :=  {  acc := ·100  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__roundAddStakeAndVesting_Л_totalStake : Accessor localState_ι__roundAddStakeAndVesting_Л_totalStake :=  {  acc := ·101  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__roundMoveStakes_Л_source : Accessor localState_ι__roundMoveStakes_Л_source :=  {  acc := ·102  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__roundMoveStakes_Л_destination : Accessor localState_ι__roundMoveStakes_Л_destination :=  {  acc := ·103  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__roundMoveStakes_Л_targetAmount : Accessor localState_ι__roundMoveStakes_Л_targetAmount :=  {  acc := ·104  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__roundMoveStakes_Л_roundId : Accessor localState_ι__roundMoveStakes_Л_roundId :=  {  acc := ·105  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__roundMoveStakes_Л_round : Accessor localState_ι__roundMoveStakes_Л_round :=  {  acc := ·106  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__roundMoveStake_Л_round : Accessor localState_ι__roundMoveStake_Л_round :=  {  acc := ·107  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__roundMoveStake_Л_source : Accessor localState_ι__roundMoveStake_Л_source :=  {  acc := ·108  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__roundMoveStake_Л_destination : Accessor localState_ι__roundMoveStake_Л_destination :=  {  acc := ·109  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__roundMoveStake_Л_amount : Accessor localState_ι__roundMoveStake_Л_amount :=  {  acc := ·110  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__roundMoveStake_Л_exists : Accessor localState_ι__roundMoveStake_Л_exists :=  {  acc := ·111  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__roundRemoveStakeInLastRound_Л_participant : Accessor localState_ι__roundRemoveStakeInLastRound_Л_participant :=  {  acc := ·112  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__roundRemoveStakeInLastRound_Л_targetAmount : Accessor localState_ι__roundRemoveStakeInLastRound_Л_targetAmount :=  {  acc := ·113  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__roundRemoveStakeInLastRound_Л_minStake : Accessor localState_ι__roundRemoveStakeInLastRound_Л_minStake :=  {  acc := ·114  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__roundRemoveStakeInLastRound_Л_unused : Accessor localState_ι__roundRemoveStakeInLastRound_Л_unused :=  {  acc := ·115  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__roundRemoveStakeInLastRound_Л_round : Accessor localState_ι__roundRemoveStakeInLastRound_Л_round :=  {  acc := ·116  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__roundRemoveStakeInLastRound_Л_exists : Accessor localState_ι__roundRemoveStakeInLastRound_Л_exists :=  {  acc := ·117  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__addPendingRound_Л_round : Accessor localState_ι__addPendingRound_Л_round :=  {  acc := ·118  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__removePendingRound_Л_pendingId : Accessor localState_ι__removePendingRound_Л_pendingId :=  {  acc := ·119  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__roundFetchPendingRound_Л_pendingId : Accessor localState_ι__roundFetchPendingRound_Л_pendingId :=  {  acc := ·120  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__setOrDeletePendingRound_Л_round : Accessor localState_ι__setOrDeletePendingRound_Л_round :=  {  acc := ·121  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__deletePendingRound_Л_id : Accessor localState_ι__deletePendingRound_Л_id :=  {  acc := ·122  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_sumOfStakes_Л_stakes : Accessor localState_ι_sumOfStakes_Л_stakes :=  {  acc := ·123  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__getRoundsInfo_Л_index : Accessor localState_ι__getRoundsInfo_Л_index :=  {  acc := ·124  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__getRoundsInfo_Л_round : Accessor localState_ι__getRoundsInfo_Л_round :=  {  acc := ·125  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__getPendingRoundsInfo_Л_key : Accessor localState_ι__getPendingRoundsInfo_Л_key :=  {  acc := ·126  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__getPendingRoundsInfo_Л_round : Accessor localState_ι__getPendingRoundsInfo_Л_round :=  {  acc := ·127  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__checkPenultimateRound_Л_lb1Round : Accessor localState_ι__checkPenultimateRound_Л_lb1Round :=  {  acc := ·128  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__checkOldestRound_Л_oldestRound : Accessor localState_ι__checkOldestRound_Л_oldestRound :=  {  acc := ·129  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__calcLastRoundInterest_Л_totalStake : Accessor localState_ι__calcLastRoundInterest_Л_totalStake :=  {  acc := ·130  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__calcLastRoundInterest_Л_rewards : Accessor localState_ι__calcLastRoundInterest_Л_rewards :=  {  acc := ·131  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__sendError_Л_errcode : Accessor localState_ι__sendError_Л_errcode :=  {  acc := ·132  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__sendError_Л_comment : Accessor localState_ι__sendError_Л_comment :=  {  acc := ·133  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__sendAccept_Л_fee : Accessor localState_ι__sendAccept_Л_fee :=  {  acc := ·134  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__requestStakesSigning_Л_round : Accessor localState_ι__requestStakesSigning_Л_round :=  {  acc := ·135  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__requestStakesSigning_Л_roundStake : Accessor localState_ι__requestStakesSigning_Л_roundStake :=  {  acc := ·136  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__requestStakesSigning_Л_currentElectAt : Accessor localState_ι__requestStakesSigning_Л_currentElectAt :=  {  acc := ·137  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__requestStakesSigning_Л_roundStakeCheck : Accessor localState_ι__requestStakesSigning_Л_roundStakeCheck :=  {  acc := ·138  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__requestStakesSigning_Л_nodeStakeCheck : Accessor localState_ι__requestStakesSigning_Л_nodeStakeCheck :=  {  acc := ·139  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__addRequest_Л_stakeAt : Accessor localState_ι__addRequest_Л_stakeAt :=  {  acc := ·140  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__addRequest_Л_request : Accessor localState_ι__addRequest_Л_request :=  {  acc := ·141  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__acceptPendingRoundStake_Л_pendingId : Accessor localState_ι__acceptPendingRoundStake_Л_pendingId :=  {  acc := ·142  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__acceptPendingRoundStake_Л_exists : Accessor localState_ι__acceptPendingRoundStake_Л_exists :=  {  acc := ·143  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__acceptUnusedStake_Л_lb1round : Accessor localState_ι__acceptUnusedStake_Л_lb1round :=  {  acc := ·144  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__acceptRewardStake_Л_oldestRound : Accessor localState_ι__acceptRewardStake_Л_oldestRound :=  {  acc := ·145  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__acceptRewardStake_Л_roundStake : Accessor localState_ι__acceptRewardStake_Л_roundStake :=  {  acc := ·146  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__completePendingRound_Л_pendingRound : Accessor localState_ι__completePendingRound_Л_pendingRound :=  {  acc := ·147  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__completePendingRound_Л_chunkSize : Accessor localState_ι__completePendingRound_Л_chunkSize :=  {  acc := ·148  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__completeRoundWithSpecialChunkSize_Л_completedRound : Accessor localState_ι__completeRoundWithSpecialChunkSize_Л_completedRound :=  {  acc := ·149  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__completeRoundWithSpecialChunkSize_Л_completionStatus : Accessor localState_ι__completeRoundWithSpecialChunkSize_Л_completionStatus :=  {  acc := ·150  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__completeRoundWithSpecialChunkSize_Л_chunkSize : Accessor localState_ι__completeRoundWithSpecialChunkSize_Л_chunkSize :=  {  acc := ·151  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__completeRound_Л_completedRound : Accessor localState_ι__completeRound_Л_completedRound :=  {  acc := ·152  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__completeRound_Л_completionStatus : Accessor localState_ι__completeRound_Л_completionStatus :=  {  acc := ·153  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__returnOrReinvestForStakeholder_Л_completedRound : Accessor localState_ι__returnOrReinvestForStakeholder_Л_completedRound :=  {  acc := ·154  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__returnOrReinvestForStakeholder_Л_lastRound : Accessor localState_ι__returnOrReinvestForStakeholder_Л_lastRound :=  {  acc := ·155  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__returnOrReinvestForStakeholder_Л_addr : Accessor localState_ι__returnOrReinvestForStakeholder_Л_addr :=  {  acc := ·156  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__returnOrReinvestForStakeholder_Л_stakes : Accessor localState_ι__returnOrReinvestForStakeholder_Л_stakes :=  {  acc := ·157  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__returnOrReinvestForStakeholder_Л_newStake : Accessor localState_ι__returnOrReinvestForStakeholder_Л_newStake :=  {  acc := ·158  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__returnOrReinvestForStakeholder_Л_newVesting : Accessor localState_ι__returnOrReinvestForStakeholder_Л_newVesting :=  {  acc := ·159  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__returnOrReinvestForStakeholder_Л_stakeSum : Accessor localState_ι__returnOrReinvestForStakeholder_Л_stakeSum :=  {  acc := ·160  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__returnOrReinvest_Л_completedRound : Accessor localState_ι__returnOrReinvest_Л_completedRound :=  {  acc := ·161  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__returnOrReinvest_Л_chunkSize : Accessor localState_ι__returnOrReinvest_Л_chunkSize :=  {  acc := ·162  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__getMsgValueAndSendErrorIfNeeded_Л_unused : Accessor localState_ι__getMsgValueAndSendErrorIfNeeded_Л_unused :=  {  acc := ·163  }   . 
DePoolClass.v:Global Instance Acc_localState_ι__getMsgValueAndSendErrorIfNeeded_Л_msgValue : Accessor localState_ι__getMsgValueAndSendErrorIfNeeded_Л_msgValue :=  {  acc := ·164  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_investStake_Л_unusedStake : Accessor localState_ι_investStake_Л_unusedStake :=  {  acc := ·165  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_investStake_Л_reinvest : Accessor localState_ι_investStake_Л_reinvest :=  {  acc := ·166  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_investStake_Л_stakeholder : Accessor localState_ι_investStake_Л_stakeholder :=  {  acc := ·167  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_addVesting_Л_dest : Accessor localState_ι_addVesting_Л_dest :=  {  acc := ·168  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_addVesting_Л_withdrawalPeriod : Accessor localState_ι_addVesting_Л_withdrawalPeriod :=  {  acc := ·169  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_addVesting_Л_totalPeriod : Accessor localState_ι_addVesting_Л_totalPeriod :=  {  acc := ·170  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_removeStake_Л_doRemoveFromCurrentRound : Accessor localState_ι_removeStake_Л_doRemoveFromCurrentRound :=  {  acc := ·171  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_removeStake_Л_targetValue : Accessor localState_ι_removeStake_Л_targetValue :=  {  acc := ·172  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_setReinvest_Л_flag : Accessor localState_ι_setReinvest_Л_flag :=  {  acc := ·173  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_transferStake_Л_destination : Accessor localState_ι_transferStake_Л_destination :=  {  acc := ·174  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_transferStake_Л_amount : Accessor localState_ι_transferStake_Л_amount :=  {  acc := ·175  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_transferStake_Л_sender : Accessor localState_ι_transferStake_Л_sender :=  {  acc := ·176  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_transferStake_Л_exists : Accessor localState_ι_transferStake_Л_exists :=  {  acc := ·177  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_processNewStake_Л_queryId : Accessor localState_ι_processNewStake_Л_queryId :=  {  acc := ·178  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_processNewStake_Л_validatorKey : Accessor localState_ι_processNewStake_Л_validatorKey :=  {  acc := ·179  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_processNewStake_Л_stakeAt : Accessor localState_ι_processNewStake_Л_stakeAt :=  {  acc := ·180  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_processNewStake_Л_maxFactor : Accessor localState_ι_processNewStake_Л_maxFactor :=  {  acc := ·181  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_processNewStake_Л_adnlAddr : Accessor localState_ι_processNewStake_Л_adnlAddr :=  {  acc := ·182  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_processNewStake_Л_signature : Accessor localState_ι_processNewStake_Л_signature :=  {  acc := ·183  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_ticktock_Л_electionsStarted : Accessor localState_ι_ticktock_Л_electionsStarted :=  {  acc := ·184  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_forceCompletePendingRound_Л_doCompleteOneChunk : Accessor localState_ι_forceCompletePendingRound_Л_doCompleteOneChunk :=  {  acc := ·185  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_forceCompletePendingRound_Л_chunkSize : Accessor localState_ι_forceCompletePendingRound_Л_chunkSize :=  {  acc := ·186  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_completePendingRoundChunk_Л_roundId : Accessor localState_ι_completePendingRoundChunk_Л_roundId :=  {  acc := ·187  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_completePendingRoundChunk_Л_chunkSize : Accessor localState_ι_completePendingRoundChunk_Л_chunkSize :=  {  acc := ·188  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_receiveReturnedStake_Л_round : Accessor localState_ι_receiveReturnedStake_Л_round :=  {  acc := ·189  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_terminator_Л_chunkSize : Accessor localState_ι_terminator_Л_chunkSize :=  {  acc := ·190  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_getStakeholderInfo_Л_addr : Accessor localState_ι_getStakeholderInfo_Л_addr :=  {  acc := ·191  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_getStakeholderInfo_Л_exists : Accessor localState_ι_getStakeholderInfo_Л_exists :=  {  acc := ·192  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_getStakeholderInfo_Л_round : Accessor localState_ι_getStakeholderInfo_Л_round :=  {  acc := ·193  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_sendError_Л_queryId : Accessor localState_ι_sendError_Л_queryId :=  {  acc := ·194  }   . 
DePoolClass.v:Global Instance Acc_localState_ι_sendError_Л_op : Accessor localState_ι_sendError_Л_op :=  {  acc := ·195  }   . 
DePoolFuncOrig.v:Definition Participant_Ф_receiveRewardStake ( Л_roundId : XInteger32 )
DePoolFuncOrig.v:                                            ( Л_reward : XInteger64 )
DePoolFuncOrig.v:                                            ( Л_usualStake : XInteger64 )
DePoolFuncOrig.v:                                            ( Л_vestingStake : XInteger64 )
DePoolFuncOrig.v:                                            ( Л_reinvest : XBool )
DePoolFuncOrig.v:                                            ( Л_fee : XInteger64 )
DePoolFuncOrig.v:                                            ( Л_reason : XInteger8 ) : LedgerT True 
DePoolFuncOrig.v:Definition Participant_Ф_receiveAnswer ( Л_errcode : XInteger32 )
DePoolFuncOrig.v:                                       ( Л_comment : XInteger64 ) 
DePoolFuncOrig.v:                                                    ( Л_queryId : XInteger64 )
DePoolFuncOrig.v:                                                    ( Л_validatorKey : XInteger256 )
DePoolFuncOrig.v:                                                    ( Л_stakeAt : XInteger32 )
DePoolFuncOrig.v:                                                    ( Л_maxFactor : XInteger32 )
DePoolFuncOrig.v:                                                    ( Л_adnlAddr : XInteger256 )
DePoolFuncOrig.v:                                                    ( Л_signature : XInteger8 ) 
DePoolFuncOrig.v:Require (( $ msg_sender ?== ( ↑11 returnε localState_ι_receive_confirmation_Л_queryId ) , $ xInt102 )) ;
DePoolFuncOrig.v:(*  	 IElector (( ElectorBase_ι_m_elector )) . library_Ф_elector_process_new_stake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId , $ Л_validatorKey , $ Л_stakeAt , $ Л_maxFactor , $ Л_adnlAddr , $ Л_signature )) ) >> 
DePoolFuncOrig.v:                                                ( Л_queryId : XInteger64 ) 
DePoolFuncOrig.v:(*  	 IElector (( ElectorBase_ι_m_elector )) . library_Ф_elector_recover_stake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId )) ) >>  *)
DePoolFuncOrig.v:                                                 ( Л_queryId : XInteger64 )
DePoolFuncOrig.v:                                                 ( Л_comment : XInteger32 ) 
DePoolFuncOrig.v: Require (( $ Л_comment ?== $ xInt0 , u1! library_Errors_ι_INVALID_ELECTOR_CONFIRM )) ; 
DePoolFuncOrig.v: Require (( $ Л_queryId ?>= $ xInt0 , u1! library_Errors_ι_INVALID_ELECTOR_CONFIRM )) ; 
DePoolFuncOrig.v:d0! Л_round := ( $ default ) ; 
DePoolFuncOrig.v:                                                  ( Л_queryId : XInteger64 )
DePoolFuncOrig.v:                                                  ( Л_comment : XInteger32 ) 
DePoolFuncOrig.v:  (*  do b' ← $ default ; let Л_round := b' in *)
DePoolFuncOrig.v: 	 d0! Л_round := $ default ; (* RoundsBase_Ф__getPenultimateRound () ;  *)
DePoolFuncOrig.v: 	 RoundsBase_Ф__setPenultimateRound (( StakingContract_Ф__completeRound (( $ Л_round , RoundsBase_ι_ROUND_STAKE_REJECTED )) )) >> 
DePoolFuncOrig.v: 	 (* emit $ Л_roundStakeIsRejected (( $ Л_queryId , $ Л_comment )) ) >>  *)
DePoolFuncOrig.v:                                                  ( Л_queryId : XInteger64 ) 
DePoolFuncOrig.v: Ife ( $ Л_queryId ?== $ xInt0 ) { StakingContract_Ф__acceptUnusedStake ()  
DePoolFuncOrig.v: Ife ( $ Л_queryId ?== $ xInt1 ) { StakingContract_Ф__acceptRewardStake () 
DePoolFuncOrig.v: StakingContract_Ф__acceptPendingRoundStake (( uint32 (( $ Л_queryId )) ))  	 
DePoolFuncOrig.v: 	 d0! Л_electionsStarted := now ?>= ElectionParams_Ф__getElectionsStart () ; 
DePoolFuncOrig.v: Ife ( $ Л_electionsStarted ) { StakingContract_Ф__addNewRoundAndUpdateRounds ()  
DePoolFuncOrig.v:Definition Stakeholder_Ф_sendTransaction ( Л_dest : XAddress )( Л_value : XInteger64 )
DePoolFuncOrig.v:                                         ( Л_bounce : XBool )( Л_flags : XInteger16 )
DePoolFuncOrig.v:                                         ( Л_payload : TvmCell ) : StakeholderT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: 	 $ Л_dest ^^ transfer (( $ Л_value , $ Л_bounce , $ Л_flags , $ Л_payload )) ) >> 
DePoolFuncOrig.v:Definition OwnerBase_Ф_Constructor2 ( $ Л_poolOwnerAddr : XAddress ) : OwnerBaseT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: ( d1! OwnerBase_ι_m_owner := OwnerBase_ι_Owner (( $ Л_poolOwnerAddr , $ xInt0 )) ) >> 
DePoolFuncOrig.v:Definition OwnerBase_Ф_withdrawOwnerReward ( msg_sender : XInteger ) ( $ Л_amount : XInteger64 ) : OwnerBaseT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: 	 Require (( $ Л_amount ?<= OwnerBase_ι_Owner_ι_reward , library_Errors_ι_NOT_ENOUGH_FUNDS )) ) >> 
DePoolFuncOrig.v: 	 ( d1! OwnerBase_ι_Owner_ι_reward -= $ Л_amount ) >> 
DePoolFuncOrig.v: 	 OwnerBase_ι_Owner_ι_addr . transfer (( $ Л_amount , $ xBoolTrue , $ xInt3 )) ) >> 
DePoolFuncOrig.v:Definition OwnerBase_Ф__increaseOwnerReward ( $ Л_ownerReward : XInteger64 ) : OwnerBaseT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: ( d1! OwnerBase_ι_Owner_ι_reward += $ Л_ownerReward ) >> 
DePoolFuncOrig.v:Definition ElectorBase_Ф_Constructor3 ( $ Л_electorAddr : XAddress ) : ElectorBaseT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: ( d1! ElectorBase_ι_m_elector := $ Л_electorAddr ) >> 
DePoolFuncOrig.v: (( _ , , $ Л_utime_until , _ , , _ , , $ Л_ok )) := tvm_configParam (( $ xInt34 )) ) >> 
DePoolFuncOrig.v: Ift ( ! $ Л_ok ) { Require (( now ?>= ElectionParams_ι_m_electAt - ElectionParams_ι_m_beginBefore , $ xInt228 )) ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_offset := (( (( uint32 (( now )) - (( ElectionParams_ι_m_electAt - ElectionParams_ι_m_beginBefore )) )) / ElectionParams_ι_m_electedFor + $ xInt1 )) * ElectionParams_ι_m_electedFor ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_utime_until := ElectionParams_ι_m_electAt + $ Л_offset ) >> 
DePoolFuncOrig.v: return $ Л_utime_until ) >> 
DePoolFuncOrig.v:Definition ElectionParams_Ф__isElectionOver ( $ Л_currentElectAt : XInteger32 ) : ElectionParamsT XBool := 
DePoolFuncOrig.v: return now ?>= (( $ Л_currentElectAt - ElectionParams_ι_m_endBefore )) ) >> 
DePoolFuncOrig.v:Definition StakeholderBase_Ф__haveVesting ( $ Л_stakeholder : ι_Stakeholder ) : StakeholderBaseT XBool := 
DePoolFuncOrig.v: return $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_periodPayment ?!= $ xInt0 ) >> 
DePoolFuncOrig.v:Definition StakeholderBase_Ф__stakeholderSetVesting ( $ Л_stakeholder : ι_Stakeholder )( $ Л_stake : XInteger64 )( $ Л_withdrawalPeriod : XInteger32 )( $ Л_periodPayment : XInteger64 )( $ Л_vestingOwner : XAddress ) : StakeholderBaseT ι_Stakeholder := 
DePoolFuncOrig.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake += $ Л_stake ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_lastPaymentUnixTime := uint64 (( now )) ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_withdrawalPeriod := $ Л_withdrawalPeriod ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_periodPayment := $ Л_periodPayment ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_vestingOwner := $ Л_vestingOwner ) >> 
DePoolFuncOrig.v: 	 return $ Л_stakeholder ) >> 
DePoolFuncOrig.v:Definition StakeholderBase_Ф__getStakeholder ( $ Л_addr : XAddress ) : StakeholderBaseT ι_Stakeholder := 
DePoolFuncOrig.v: return StakeholderBase_ι_m_stakeholders [ $ Л_addr ] ) >> 
DePoolFuncOrig.v:Definition StakeholderBase_Ф__stakeholderFetch ( $ Л_addr : XAddress ) : StakeholderBaseT ( XBool # ι_Stakeholder ) := 
DePoolFuncOrig.v: return fetch (( $ Л_addr )) ) >> 
DePoolFuncOrig.v:Definition StakeholderBase_Ф__setOrDeleteStakeholder ( $ Л_addr : XAddress )( $ Л_stakeholder : ι_Stakeholder ) : StakeholderBaseT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: Ift ( $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake ?== $ xInt0 )) delete StakeholderBase_ι_m_stakeholders [ $ Л_addr ] ) >> 
DePoolFuncOrig.v: 	 else ( d4! StakeholderBase_ι_m_stakeholders [ Л_addr ] := $ Л_stakeholder ) >> 
DePoolFuncOrig.v:Definition StakeholderBase_Ф__stakeholderAddStakeAndSetReinvest ( $ Л_stakeholder : ι_Stakeholder )( $ Л_deltaStake : XInteger64 )( $ Л_reinvest : XBool ) : StakeholderBaseT ι_Stakeholder := 
DePoolFuncOrig.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_reinvest := $ Л_reinvest ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake += $ Л_deltaStake ) >> 
DePoolFuncOrig.v: 	 return $ Л_stakeholder ) >> 
DePoolFuncOrig.v:Definition StakeholderBase_Ф__stakeholderRemoveStake ( $ Л_addr : XAddress )( $ Л_removedStake : XInteger64 )( $ Л_unusedStake : XInteger64 ) : StakeholderBaseT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: ( d0! Л_stakeholder := StakeholderBase_ι_m_stakeholders [ $ Л_addr ] ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake -= $ Л_removedStake ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake -= $ Л_unusedStake ) >> 
DePoolFuncOrig.v: Ife ( $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake ?== $ xInt0 ) { delete StakeholderBase_ι_m_stakeholders [ $ Л_addr ] ) >> 
DePoolFuncOrig.v: ( d4! StakeholderBase_ι_m_stakeholders [ Л_addr ] := $ Л_stakeholder ) >> 
DePoolFuncOrig.v:Definition StakeholderBase_Ф__stakeholderIncreaseStakeAndUnused ( $ Л_stakeholder : ι_Stakeholder )( $ Л_deltaStake : XInteger64 )( $ Л_deltaUnused : XInteger64 ) : StakeholderBaseT ι_Stakeholder := 
DePoolFuncOrig.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake += $ Л_deltaStake + $ Л_deltaUnused ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake += $ Л_deltaUnused ) >> 
DePoolFuncOrig.v: 	 return $ Л_stakeholder ) >> 
DePoolFuncOrig.v:Definition StakeholderBase_Ф_stakeholderDecreaseStakeAndUnused ( $ Л_stakeholder : ι_Stakeholder )( $ Л_deltaStake : XInteger64 )( $ Л_deltaUnused : XInteger64 ) : StakeholderBaseT ι_Stakeholder := 
DePoolFuncOrig.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake -= $ Л_deltaStake + $ Л_deltaUnused ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake -= $ Л_deltaUnused ) >> 
DePoolFuncOrig.v: 	 return $ Л_stakeholder ) >> 
DePoolFuncOrig.v:Definition StakeholderBase_Ф__stakeholderSetReinvest ( $ Л_stakeholder : ι_Stakeholder )( $ Л_flag : XBool ) : StakeholderBaseT ι_Stakeholder := 
DePoolFuncOrig.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_reinvest := $ Л_flag ) >> 
DePoolFuncOrig.v: 	 return $ Л_stakeholder ) >> 
DePoolFuncOrig.v:Definition StakeholderBase_Ф__stakeholderUpdateTotalStake ( $ Л_stakeholder : ι_Stakeholder )( $ Л_newStake : XInteger64 )( $ Л_oldStake : XInteger64 ) : StakeholderBaseT ι_Stakeholder := 
DePoolFuncOrig.v: Ift ( $ Л_newStake ?>= $ Л_oldStake )) ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake += $ Л_newStake - $ Л_oldStake ) >> 
DePoolFuncOrig.v: 	 else ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake -= $ Л_oldStake - $ Л_newStake ) >> 
DePoolFuncOrig.v: 	 return $ Л_stakeholder ) >> 
DePoolFuncOrig.v:Definition StakeholderBase_Ф__stakeholderIncreaseUnusedStake ( $ Л_stakeholder : ι_Stakeholder )( $ Л_delta : XInteger64 ) : StakeholderBaseT ι_Stakeholder := 
DePoolFuncOrig.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake += $ Л_delta ) >> 
DePoolFuncOrig.v: 	 return $ Л_stakeholder ) >> 
DePoolFuncOrig.v:Definition StakeholderBase_Ф__stakeholderDecreaseUnusedStake ( $ Л_stakeholder : ι_Stakeholder )( $ Л_delta : XInteger64 ) : StakeholderBaseT ι_Stakeholder := 
DePoolFuncOrig.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake -= $ Л_delta ) >> 
DePoolFuncOrig.v: 	 return $ Л_stakeholder ) >> 
DePoolFuncOrig.v:Definition StakeholderBase_Ф__stakeholderResetVesting ( $ Л_stakeholder : ι_Stakeholder ) : StakeholderBaseT ι_Stakeholder := 
DePoolFuncOrig.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_lastPaymentUnixTime := $ xInt0 ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_withdrawalPeriod := $ xInt0 ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_periodPayment := $ xInt0 ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_vestingOwner := xInt0 ) >> 
DePoolFuncOrig.v: 	 return $ Л_stakeholder ) >> 
DePoolFuncOrig.v:Definition StakeholderBase_Ф__stakeholderUpdateLastPaymentTime ( $ Л_stakeholder : ι_Stakeholder )( $ Л_periodQty : XInteger64 ) : StakeholderBaseT ι_Stakeholder := 
DePoolFuncOrig.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_lastPaymentUnixTime += $ Л_periodQty * $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_withdrawalPeriod ) >> 
DePoolFuncOrig.v: 	 return $ Л_stakeholder ) >> 
DePoolFuncOrig.v:Definition StakingOwner_Ф_Constructor5 ( $ Л_pool : XAddress ) : StakingOwnerT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: 	 ( d1! StakingOwner_ι_m_stakingPool := $ Л_pool ) >> 
DePoolFuncOrig.v:Definition StakingOwner_Ф_updateStakingPoolAddress ( $ Л_addr : XAddress ) : StakingOwnerT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: 	 ( d1! StakingOwner_ι_m_stakingPool := $ Л_addr ) >> 
DePoolFuncOrig.v:Definition StakingProxyContract_Ф_Constructor6 ( $ Л_staking : XAddress )( $ Л_elector : XAddress ) : StakingProxyContractT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: 	 ( d1! StakingProxyContract_ι_m_staking := $ Л_staking ) >> 
DePoolFuncOrig.v: 	 ( d1! ElectorBase_ι_m_elector := $ Л_elector ) >> 
DePoolFuncOrig.v:Definition RoundsBase_Ф__addNewPoolingRound ( $ Л_validationStart : XInteger32 )( $ Л_validationPeriod : XInteger32 ) : RoundsBaseT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: RoundsBase_ι_Round_ι_id : $ Л_validationStart , RoundsBase_ι_Round_ι_step : RoundsBase_ι_STEP_POOLING , RoundsBase_ι_Round_ι_participantQty : $ xInt0 , RoundsBase_ι_Round_ι_stake : $ xInt0 , RoundsBase_ι_Round_ι_rewards : $ xInt0 , RoundsBase_ι_Round_ι_unused : $ xInt0 , RoundsBase_ι_Round_ι_completionStatus : RoundsBase_ι_ROUND_UNDEFINED , RoundsBase_ι_Round_ι_start : uint32 (( now )) , RoundsBase_ι_Round_ι_end : $ Л_validationStart + $ Л_validationPeriod 
DePoolFuncOrig.v: (( _ , $ Л_round )) := delMin () ) >> 
DePoolFuncOrig.v: 	 return $ Л_round ) >> 
DePoolFuncOrig.v:Definition RoundsBase_Ф__setOldestRound ( $ Л_round : ι_Round ) : RoundsBaseT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: ( d4! RoundsBase_ι_m_rounds [ RoundsBase_ι_m_startIdx ] := $ Л_round ) >> 
DePoolFuncOrig.v:Definition RoundsBase_Ф__roundAddStakeAndVesting ( $ Л_round : ι_Round )( $ Л_addr : XAddress )( $ Л_stake : XInteger64 )( $ Л_vestingStake : XInteger64 ) : RoundsBaseT ι_Round := 
DePoolFuncOrig.v: ( d0! Л_totalStake := $ Л_stake + $ Л_vestingStake ) >> 
DePoolFuncOrig.v: Ift ( $ Л_totalStake ?== $ xInt0 )) return $ Л_round ) >> 
DePoolFuncOrig.v: Ift ( ! $ Л_round ^^ RoundsBase_ι_Round_ι_stakes . exists (( $ Л_addr )) ) { $ Л_round ^^ RoundsBase_ι_Round_ι_participantQty ++ ) >> 
DePoolFuncOrig.v: ( d2! Л_round ^^ RoundsBase_ι_Round_ι_stake += $ Л_totalStake ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_sv := $ Л_round ^^ RoundsBase_ι_Round_ι_stakes [ $ Л_addr ] ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_sv ^^ RoundsBase_ι_StakeValue_ι_simple += $ Л_stake ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_sv ^^ RoundsBase_ι_StakeValue_ι_vesting += $ Л_vestingStake ) >> 
DePoolFuncOrig.v: 	 ( d3! Л_round ^^ RoundsBase_ι_Round_ι_stakes [ Л_addr ] := $ Л_sv ) >> 
DePoolFuncOrig.v: 	 return $ Л_round ) >> 
DePoolFuncOrig.v:Definition RoundsBase_Ф__roundMoveStake ( $ Л_round : ι_Round )( $ Л_source : XAddress )( $ Л_destination : XAddress )( $ Л_amount : XInteger64 ) : RoundsBaseT ι_Round # XInteger64 := 
DePoolFuncOrig.v: (( $ Л_exists , $ Л_sourceStake )) := $ Л_round ^^ RoundsBase_ι_Round_ι_stakes . fetch (( $ Л_source )) ) >> 
DePoolFuncOrig.v: Ife ( ! $ Л_exists )) return (( $ Л_round , $ xInt0 )) ) >> 
DePoolFuncOrig.v: Ife ( $ Л_sourceStake ^^ RoundsBase_ι_StakeValue_ι_simple ?>= $ Л_amount ) { ( d0! Л_newSourceStake := $ Л_sourceStake ^^ RoundsBase_ι_StakeValue_ι_simple - $ Л_amount ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_deltaDestinationStake := $ Л_amount ) >> 
DePoolFuncOrig.v: ( d0! Л_newSourceStake := $ xInt0 ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_deltaDestinationStake := $ Л_sourceStake ^^ RoundsBase_ι_StakeValue_ι_simple ) >> 
DePoolFuncOrig.v: Ife ( $ Л_newSourceStake ?== $ xInt0 && $ Л_round ^^ RoundsBase_ι_Round_ι_stakes [ $ Л_source ] ^^ RoundsBase_ι_StakeValue_ι_vesting ?== $ xInt0 ) { -- $ Л_round ^^ RoundsBase_ι_Round_ι_participantQty ) >> 
DePoolFuncOrig.v: 	 delete $ Л_round ^^ RoundsBase_ι_Round_ι_stakes [ $ Л_source ] ) >> 
DePoolFuncOrig.v: $ Л_round ^^ RoundsBase_ι_Round_ι_stakes [ $ Л_source ( d2! ] ^^ RoundsBase_ι_StakeValue_ι_simple := $ Л_newSourceStake ) >> 
DePoolFuncOrig.v: Ift ( ! $ Л_round ^^ RoundsBase_ι_Round_ι_stakes . exists (( $ Л_destination )) )) $ Л_round ^^ RoundsBase_ι_Round_ι_participantQty ++ ) >> 
DePoolFuncOrig.v: 	 $ Л_round ^^ RoundsBase_ι_Round_ι_stakes [ $ Л_destination ( d2! ] ^^ RoundsBase_ι_StakeValue_ι_simple += $ Л_deltaDestinationStake ) >> 
DePoolFuncOrig.v: 	 return (( $ Л_round , $ Л_deltaDestinationStake )) ) >> 
DePoolFuncOrig.v:Definition RoundsBase_Ф__addPendingRound ( $ Л_round : ι_Round ) : RoundsBaseT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: RoundsBase_ι_m_pendingRounds [ $ Л_round ^^ RoundsBase_ι_Round_ι_id $ Л_round ) >> 
DePoolFuncOrig.v:Definition RoundsBase_Ф__removePendingRound ( $ Л_pendingId : XInteger32 ) : RoundsBaseT XBool # ι_Round := 
DePoolFuncOrig.v: (( exists , round )) := fetch (( $ Л_pendingId )) ) >> 
DePoolFuncOrig.v: Ift ( exists ) { delete RoundsBase_ι_m_pendingRounds [ $ Л_pendingId ] ) >> 
DePoolFuncOrig.v:Definition RoundsBase_Ф__roundFetchPendingRound ( $ Л_pendingId : XInteger32 ) : RoundsBaseT XBool # ι_Round := 
DePoolFuncOrig.v: return fetch (( $ Л_pendingId )) ) >> 
DePoolFuncOrig.v:Definition RoundsBase_Ф__setOrDeletePendingRound ( $ Л_round : ι_Round ) : RoundsBaseT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: Ife ( $ Л_round ^^ RoundsBase_ι_Round_ι_step ?== RoundsBase_ι_STEP_COMPLETED ) { delete RoundsBase_ι_m_pendingRounds [ $ Л_round ^^ RoundsBase_ι_Round_ι_id ] ) >> 
DePoolFuncOrig.v: RoundsBase_ι_m_pendingRounds [ $ Л_round ^^ RoundsBase_ι_Round_ι_id $ Л_round ) >> 
DePoolFuncOrig.v:Definition RoundsBase_Ф__deletePendingRound ( $ Л_id : XInteger32 ) : RoundsBaseT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: delete RoundsBase_ι_m_pendingRounds [ $ Л_id ] ) >> 
DePoolFuncOrig.v:Definition RoundsBase_Ф_sumOfStakes ( $ Л_stakes : ι_StakeValue ) : RoundsBaseT XInteger64 := 
DePoolFuncOrig.v: return $ Л_stakes ^^ RoundsBase_ι_StakeValue_ι_simple + $ Л_stakes ^^ RoundsBase_ι_StakeValue_ι_vesting ) >> 
DePoolFuncOrig.v: (( $ Л_index , $ Л_round , $ Л_ok )) := min () ) >> 
DePoolFuncOrig.v: 	 while (( $ Л_ok ) { infos ^^ push (( RoundsBase_ι_RoundInfo (( $ Л_round ^^ RoundsBase_ι_Round_ι_id , $ Л_round ^^ RoundsBase_ι_Round_ι_start , $ Л_round ^^ RoundsBase_ι_Round_ι_end , $ Л_round ^^ RoundsBase_ι_Round_ι_step , $ Л_round ^^ RoundsBase_ι_Round_ι_completionStatus , $ Л_round ^^ RoundsBase_ι_Round_ι_stake , $ Л_round ^^ RoundsBase_ι_Round_ι_participantQty , $ Л_round ^^ RoundsBase_ι_Round_ι_rewards )) )) ) >> 
DePoolFuncOrig.v: 	 (( $ Л_index , $ Л_round , $ Л_ok )) := next (( $ Л_index )) ) >> 
DePoolFuncOrig.v: (( $ Л_key , $ Л_round , $ Л_ok )) := min () ) >> 
DePoolFuncOrig.v: 	 while (( $ Л_ok ) { infos ^^ push (( RoundsBase_ι_RoundInfo (( $ Л_round ^^ RoundsBase_ι_Round_ι_id , $ Л_round ^^ RoundsBase_ι_Round_ι_start , $ Л_round ^^ RoundsBase_ι_Round_ι_end , $ Л_round ^^ RoundsBase_ι_Round_ι_step , $ Л_round ^^ RoundsBase_ι_Round_ι_completionStatus , $ Л_round ^^ RoundsBase_ι_Round_ι_stake , $ Л_round ^^ RoundsBase_ι_Round_ι_participantQty , $ Л_round ^^ RoundsBase_ι_Round_ι_rewards )) )) ) >> 
DePoolFuncOrig.v: 	 (( $ Л_key , $ Л_round , $ Л_ok )) := next (( $ Л_key )) ) >> 
DePoolFuncOrig.v:Definition StakingContract_Ф__calcLastRoundInterest ( $ Л_totalStake : XInteger64 )( $ Л_rewards : XInteger64 ) : StakingContractT XInteger64 := 
DePoolFuncOrig.v: return (( $ Л_totalStake ?!= $ xInt0 )) ? uint64 (( (( uint (( $ Л_rewards )) * $ xInt100 * 1e9 )) / $ Л_totalStake ) : $ xInt0 ) >> 
DePoolFuncOrig.v:Definition StakingContract_Ф__addRequest ( $ Л_stakeAt : XInteger32 )( $ Л_request : ι_Request ) : StakingContractT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: Require (( ! exists (( $ Л_stakeAt )) , library_Errors_ι_REPEATED_REQUEST )) ) >> 
DePoolFuncOrig.v: 	 ( d4! StakingContract_ι_m_requests [ Л_stakeAt ] := $ Л_request ) >> 
DePoolFuncOrig.v:Definition StakingContract_Ф_Constructor7 ( $ Л_electorAddr : XAddress )( $ Л_poolOwnerAddr : XAddress )( $ Л_electionId : XInteger32 )( $ Л_nodeWallet : XAddress )( $ Л_beginBefore : XInteger32 )( $ Л_endBefore : XInteger32 )( $ Л_heldFor : XInteger32 )( $ Л_electedFor : XInteger32 )( $ Л_minStake : XInteger64 )( $ Л_minRoundStake : XInteger64 )( $ Л_maxRoundStake : XInteger64 ) : StakingContractT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: ( d1! StakingContract_ι_m_minStake := $ Л_minStake ) >> 
DePoolFuncOrig.v: 	 ( d1! StakingContract_ι_m_minRoundStake := $ Л_minRoundStake ) >> 
DePoolFuncOrig.v: 	 ( d1! StakingContract_ι_m_maxRoundStake := $ Л_maxRoundStake ) >> 
DePoolFuncOrig.v: 	 ( d1! StakingContract_ι_m_nodeWallet := $ Л_nodeWallet ) >> 
DePoolFuncOrig.v:Definition StakingContract_Ф_receiveConfirmation ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_comment : XInteger32 ) : StakingContractT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: 	 Require (( $ Л_comment ?== $ xInt0 , library_Errors_ι_INVALID_ELECTOR_CONFIRM )) ) >> 
DePoolFuncOrig.v: 	 Require (( $ Л_queryId ?>= $ xInt0 , library_Errors_ι_INVALID_ELECTOR_CONFIRM )) ) >> 
DePoolFuncOrig.v:Definition DePool_Ф_Constructor8 ( $ Л_electorAddr : XAddress )( $ Л_poolOwnerAddr : XAddress )( $ Л_electionId : XInteger32 )( $ Л_nodeWallet : XAddress )( $ Л_beginBefore : XInteger32 )( $ Л_endBefore : XInteger32 )( $ Л_heldFor : XInteger32 )( $ Л_electedFor : XInteger32 )( $ Л_minStake : XInteger64 )( $ Л_minRoundStake : XInteger64 )( $ Л_maxRoundStake : XInteger64 ) : DePoolT True 
DePoolFuncOrig.v:Definition StakingContract_Ф_receiveConfirmation ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_comment : XInteger32 ) : StakingContractT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: 	 Require (( $ Л_comment ?== $ xInt0 , library_Errors_ι_INVALID_ELECTOR_CONFIRM )) ) >> 
DePoolFuncOrig.v: 	 Require (( $ Л_queryId ?>= $ xInt0 , library_Errors_ι_INVALID_ELECTOR_CONFIRM )) ) >> 
DePoolFuncOrig.v:Definition StakingContract_Ф_acceptRecoveredStake ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 ) : StakingContractT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: Ife ( $ Л_queryId ?== $ xInt0 ) { StakingContract_Ф__acceptUnusedStake () ) >> 
DePoolFuncOrig.v: Ife ( $ Л_queryId ?== $ xInt1 ) { StakingContract_Ф__acceptRewardStake () ) >> 
DePoolFuncOrig.v: StakingContract_Ф__acceptPendingRoundStake (( uint32 (( $ Л_queryId )) )) ) >> 
DePoolFuncOrig.v:Definition TestElector_Ф_Constructor9 ( $ Л_offset : XInteger32 ) : TestElectorT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: ( d1! TestElector_ι_electAt := uint32 (( now )) + $ Л_offset ) >> 
DePoolFuncOrig.v:Definition ElectorBase_Ф__recoverPendingRoundStakes ( $ Л_pendingId : XInteger32 ) : ElectorBaseT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: IProxy (( ElectorBase_ι_m_elector )) . Participant_Ф_recover_stake ^^ value (( ElectorBase_ι_RECOVER_STAKE_MSG_VALUE )) (( $ Л_pendingId )) ) >> 
DePoolFuncOrig.v:Definition ElectorBase_Ф__sendRequestToElector ( $ Л_req : ι_Request )( $ Л_nodeStake : XInteger64 ) : ElectorBaseT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: value : $ Л_nodeStake + 1e9 + 2*1e7 
DePoolFuncOrig.v: (( $ Л_req ^^ ElectorBase_ι_Request_ι_queryId , $ Л_req ^^ ElectorBase_ι_Request_ι_validatorKey , $ Л_req ^^ ElectorBase_ι_Request_ι_stakeAt , $ Л_req ^^ ElectorBase_ι_Request_ι_maxFactor , $ Л_req ^^ ElectorBase_ι_Request_ι_adnlAddr , $ Л_req ^^ ElectorBase_ι_Request_ι_signature )) ) >> 
DePoolFuncOrig.v:Definition ElectionParams_Ф__isRoundUnfrozen ( $ Л_electAt : XInteger32 ) : ElectionParamsT XBool := 
DePoolFuncOrig.v: return now ?> (( $ Л_electAt + ElectionParams_Ф__getFreezingPeriod () )) ) >> 
DePoolFuncOrig.v: ( d0! Л_nextElectAt := ElectionParams_Ф__getNextElectionId () ) >> 
DePoolFuncOrig.v: Ift ( now ?>= $ Л_nextElectAt - ElectionParams_ι_m_beginBefore ) { ( d0! Л_nextElectAt += ElectionParams_ι_m_electedFor ) >> 
DePoolFuncOrig.v: ( d1! ElectionParams_ι_m_electAt := $ Л_nextElectAt ) >> 
DePoolFuncOrig.v: 	 return $ Л_nextElectAt ) >> 
DePoolFuncOrig.v:Definition StakingOwner_Ф__settimer ( $ Л_timer : XAddress )( $ Л_period : XInteger ) : StakingOwnerT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: ITimer (( $ Л_timer )) . StakeholderBase_Ф_setTimer ^^ value (( StakingOwner_ι_TIMER_FEE )) (( $ Л_period )) ) >> 
DePoolFuncOrig.v: ( d0! Л_timer := StakingOwner_ι_m_timer ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_period := StakingOwner_ι_m_timeout ) >> 
DePoolFuncOrig.v: Ift ( $ msg_sender ?== $ Л_timer && $ Л_period ?> $ xInt0 ) { IStaking (( StakingOwner_ι_m_stakingPool )) . Participant_Ф_ticktock ^^ value (( StakingOwner_ι_TICKTOCK_FEE )) () ) >> 
DePoolFuncOrig.v: 	 StakingOwner_Ф__settimer (( $ Л_timer , $ Л_period )) ) >> 
DePoolFuncOrig.v:Definition StakingProxyContract_Ф_process_new_stake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_validatorKey : XInteger256 )( $ Л_stakeAt : XInteger32 )( $ Л_maxFactor : XInteger32 )( $ Л_adnlAddr : XInteger256 )( $ Л_signature : XInteger8 ) : StakingProxyContractT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: 	 IElector (( ElectorBase_ι_m_elector )) . library_Ф_elector_process_new_stake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId , $ Л_validatorKey , $ Л_stakeAt , $ Л_maxFactor , $ Л_adnlAddr , $ Л_signature )) ) >> 
DePoolFuncOrig.v:Definition StakingProxyContract_Ф_recover_stake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 ) : StakingProxyContractT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: 	 IElector (( ElectorBase_ι_m_elector )) . library_Ф_elector_recover_stake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId )) ) >> 
DePoolFuncOrig.v:Definition StakingProxyContract_Ф_receive_confirmation ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_comment : XInteger32 ) : StakingProxyContractT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: 	 IStaking (( StakingProxyContract_ι_m_staking )) . Participant_Ф_receiveConfirmation ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId , $ Л_comment )) ) >> 
DePoolFuncOrig.v:Definition StakingProxyContract_Ф_receive_returned_stake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_comment : XInteger32 ) : StakingProxyContractT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: 	 IStaking (( StakingProxyContract_ι_m_staking )) . Participant_Ф_receiveReturnedStake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId , $ Л_comment )) ) >> 
DePoolFuncOrig.v:Definition StakingProxyContract_Ф_accept_recovered_stake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 ) : StakingProxyContractT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: 	 IStaking (( StakingProxyContract_ι_m_staking )) . Participant_Ф_acceptRecoveredStake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId )) ) >> 
DePoolFuncOrig.v: (( $ Л_exists , $ Л_round )) := fetch (( RoundsBase_Ф__getLastRoundIdx () )) ) >> 
DePoolFuncOrig.v: 	 Require (( $ Л_exists , $ xInt200 )) ) >> 
DePoolFuncOrig.v: 	 return $ Л_round ) >> 
DePoolFuncOrig.v:Definition RoundsBase_Ф__setLastRound ( $ Л_round : ι_Round ) : RoundsBaseT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: RoundsBase_ι_m_rounds [ RoundsBase_Ф__getLastRoundIdx () $ Л_round ) >> 
DePoolFuncOrig.v:Definition RoundsBase_Ф__setPenultimateRound ( $ Л_round : ι_Round ) : RoundsBaseT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: RoundsBase_ι_m_rounds [ RoundsBase_Ф__getLastRoundIdx () - $ xInt1 $ Л_round ) >> 
DePoolFuncOrig.v:Definition RoundsBase_Ф__roundRemoveStakeInLastRound ( $ Л_participant : XAddress )( $ Л_targetAmount : XInteger64 )( $ Л_minStake : XInteger64 ) : RoundsBaseT XInteger64 # XInteger64 := 
DePoolFuncOrig.v: ( d0! Л_round := RoundsBase_Ф__getLastRound () ) >> 
DePoolFuncOrig.v: 	 (( $ Л_exists , $ Л_sv )) := $ Л_round ^^ RoundsBase_ι_Round_ι_stakes . fetch (( $ Л_participant )) ) >> 
DePoolFuncOrig.v: Ift ( ! $ Л_exists ) { return (( $ xInt0 , $ xInt0 )) ) >> 
DePoolFuncOrig.v: ( d0! Л_targetAmount := tvm_min (( $ Л_targetAmount , $ Л_sv ^^ RoundsBase_ι_StakeValue_ι_simple )) ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_sv ^^ RoundsBase_ι_StakeValue_ι_simple -= $ Л_targetAmount ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_round ^^ RoundsBase_ι_Round_ι_stake -= $ Л_targetAmount ) >> 
DePoolFuncOrig.v: Ift ( $ Л_sv ^^ RoundsBase_ι_StakeValue_ι_simple ?< $ Л_minStake ) { ( d0! Л_unused := $ Л_sv ^^ RoundsBase_ι_StakeValue_ι_simple ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_round ^^ RoundsBase_ι_Round_ι_stake -= $ Л_sv ^^ RoundsBase_ι_StakeValue_ι_simple ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_sv ^^ RoundsBase_ι_StakeValue_ι_simple := $ xInt0 ) >> 
DePoolFuncOrig.v: Ife ( RoundsBase_Ф_sumOfStakes (( $ Л_sv )) ?== $ xInt0 ) { -- $ Л_round ^^ RoundsBase_ι_Round_ι_participantQty ) >> 
DePoolFuncOrig.v: 	 delete $ Л_round ^^ RoundsBase_ι_Round_ι_stakes [ $ Л_participant ] ) >> 
DePoolFuncOrig.v: ( d3! Л_round ^^ RoundsBase_ι_Round_ι_stakes [ Л_participant ] := $ Л_sv ) >> 
DePoolFuncOrig.v: RoundsBase_Ф__setLastRound (( $ Л_round )) ) >> 
DePoolFuncOrig.v: 	 return (( $ Л_targetAmount , $ Л_unused )) ) >> 
DePoolFuncOrig.v: Ift ( RoundsBase_Ф__getRoundsCount () ?> $ xInt4 ) { ( d0! Л_removingRound := RoundsBase_Ф__removeOldestRound () ) >> 
DePoolFuncOrig.v: 	 delete StakingContract_ι_m_requests [ $ Л_removingRound ^^ RoundsBase_ι_Round_ι_id ] ) >> 
DePoolFuncOrig.v: Ift ( $ Л_removingRound ^^ RoundsBase_ι_Round_ι_step ?== RoundsBase_ι_STEP_WAITING_ELECTION_RESULTS ) { RoundsBase_Ф__addPendingRound (( $ Л_removingRound )) ) >> 
DePoolFuncOrig.v: 	 ElectorBase_Ф__recoverPendingRoundStakes (( $ Л_removingRound ^^ RoundsBase_ι_Round_ι_id )) ) >> 
DePoolFuncOrig.v: ( d0! Л_lb1Round := RoundsBase_Ф__getPenultimateRound () ) >> 
DePoolFuncOrig.v: Ift ( now ?> $ Л_lb1Round ^^ RoundsBase_ι_Round_ι_id ) { 
DePoolFuncOrig.v: Ift ( $ Л_lb1Round ^^ RoundsBase_ι_Round_ι_step ?< RoundsBase_ι_STEP_ELECTIONS ) { RoundsBase_Ф__setPenultimateRound (( StakingContract_Ф__completeRound (( $ Л_lb1Round , RoundsBase_ι_ROUND_MISSED_ELECTIONS )) )) ) >> 
DePoolFuncOrig.v: Ift ( $ Л_lb1Round ^^ RoundsBase_ι_Round_ι_step ?< RoundsBase_ι_STEP_WAITING_ELECTION_RESULTS ) { ElectorBase_Ф__recoverStakes () ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_lb1Round ^^ RoundsBase_ι_Round_ι_step := RoundsBase_ι_STEP_WAITING_ELECTION_RESULTS ) >> 
DePoolFuncOrig.v: 	 RoundsBase_Ф__setPenultimateRound (( $ Л_lb1Round )) ) >> 
DePoolFuncOrig.v: ( d0! Л_oldestRound := RoundsBase_Ф__getOldestRound () ) >> 
DePoolFuncOrig.v: Ift ( ElectionParams_Ф__isRoundUnfrozen (( $ Л_oldestRound ^^ RoundsBase_ι_Round_ι_id )) ) { 
DePoolFuncOrig.v: Ift ( $ Л_oldestRound ^^ RoundsBase_ι_Round_ι_step ?== RoundsBase_ι_STEP_WAITING_ELECTION_RESULTS ) { ElectorBase_Ф__recoverStakeRewards () ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_oldestRound ^^ RoundsBase_ι_Round_ι_step := RoundsBase_ι_STEP_WAITING_UNFREEZE ) >> 
DePoolFuncOrig.v: 	 RoundsBase_Ф__setOldestRound (( $ Л_oldestRound )) ) >> 
DePoolFuncOrig.v:Definition StakingContract_Ф__sendError ( msg_sender : XInteger ) ( $ Л_errcode : XInteger32 )( $ Л_comment : XInteger64 ) : StakingContractT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: (( $ Л_errcode , $ Л_comment )) ) >> 
DePoolFuncOrig.v:Definition StakingContract_Ф__sendAccept ( msg_sender : XInteger ) ( $ Л_fee : XInteger64 ) : StakingContractT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: (( StakingContract_ι_STATUS_SUCCESS , $ Л_fee )) ) >> 
DePoolFuncOrig.v:Definition StakingContract_Ф__requestStakesSigning ( $ Л_round : ι_Round ) : StakingContractT ι_Round := 
DePoolFuncOrig.v: ( d0! Л_roundStake := $ Л_round ^^ RoundsBase_ι_Round_ι_stake ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_currentElectAt := $ Л_round ^^ RoundsBase_ι_Round_ι_id ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_roundStakeCheck := $ Л_roundStake ?>= StakingContract_ι_m_minRoundStake ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_nodeStakeCheck := RoundsBase_Ф_sumOfStakes (( $ Л_round ^^ RoundsBase_ι_Round_ι_stakes [ StakingContract_ι_m_nodeWallet ] )) ?>= (( StakingContract_ι_m_minRoundStake * StakingContract_ι_NODE_WALLET_MIN_STAKE )) / $ xInt100 ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_canParticipate := ! ElectionParams_Ф__isElectionOver (( $ Л_currentElectAt )) && $ Л_roundStakeCheck && $ Л_nodeStakeCheck ) >> 
DePoolFuncOrig.v: Ife ( $ Л_canParticipate ) { emit $ Л_stakeSigningRequested (( $ Л_currentElectAt )) ) >> 
DePoolFuncOrig.v: 	 (( $ Л_exists , $ Л_request )) := fetch (( $ Л_currentElectAt )) ) >> 
DePoolFuncOrig.v: Ife ( $ Л_exists ) { ( d2! Л_round ^^ RoundsBase_ι_Round_ι_step := RoundsBase_ι_STEP_ELECTIONS ) >> 
DePoolFuncOrig.v: 	 ElectorBase_Ф__sendRequestToElector (( $ Л_request , $ Л_roundStake )) ) >> 
DePoolFuncOrig.v: ( d2! Л_round ^^ RoundsBase_ι_Round_ι_step := RoundsBase_ι_STEP_WAITING_REQUESTS ) >> 
DePoolFuncOrig.v: ( d0! Л_completionStatus := ! $ Л_roundStakeCheck ? RoundsBase_ι_ROUND_NOT_ENOUGH_TOTAL_STAKE : RoundsBase_ι_ROUND_NODE_STAKE_TOO_SMALL ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_round := StakingContract_Ф__completeRound (( $ Л_round , $ Л_completionStatus )) ) >> 
DePoolFuncOrig.v: return $ Л_round ) >> 
DePoolFuncOrig.v:Definition StakingContract_Ф__acceptPendingRoundStake ( $ Л_pendingId : XInteger32 ) : StakingContractT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: (( $ Л_exists , $ Л_round )) := RoundsBase_Ф__removePendingRound (( $ Л_pendingId )) ) >> 
DePoolFuncOrig.v: Ift ( $ Л_exists ) { StakingContract_Ф__completeRound (( $ Л_round , RoundsBase_ι_ROUND_RECEIVED_REWARD )) ) >> 
DePoolFuncOrig.v: ( d0! Л_lb1round := RoundsBase_Ф__getPenultimateRound () ) >> 
DePoolFuncOrig.v: Ife ( $ msg_value ?>= $ Л_lb1round ^^ RoundsBase_ι_Round_ι_stake ) { RoundsBase_Ф__setPenultimateRound (( StakingContract_Ф__completeRound (( $ Л_lb1round , RoundsBase_ι_ROUND_LOST_ELECTIONS )) )) ) >> 
DePoolFuncOrig.v: ( d2! Л_lb1round ^^ RoundsBase_ι_Round_ι_unused := uint64 (( $ msg_value )) ) >> 
DePoolFuncOrig.v: 	 RoundsBase_Ф__setPenultimateRound (( $ Л_lb1round )) ) >> 
DePoolFuncOrig.v: 	 ( d1! StakingContract_ι_m_minRoundStake := $ Л_lb1round ^^ RoundsBase_ι_Round_ι_stake - $ Л_lb1round ^^ RoundsBase_ι_Round_ι_unused + StakingContract_ι_ROUND_UP_VALUE ) >> 
DePoolFuncOrig.v: ( d0! Л_oldestRound := RoundsBase_Ф__getOldestRound () ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_roundStake := $ Л_oldestRound ^^ RoundsBase_ι_Round_ι_stake - $ Л_oldestRound ^^ RoundsBase_ι_Round_ι_unused ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_totalReward := $ xInt0 ) >> 
DePoolFuncOrig.v: Ift ( uint64 (( $ msg_value )) ?>= $ Л_roundStake ) { ( d0! Л_totalReward := uint64 (( $ msg_value )) - $ Л_roundStake ) >> 
DePoolFuncOrig.v: ( d0! Л_roundReward := uint64 (( uint (( $ Л_totalReward )) * StakingContract_ι_NOM_FRACTION / $ xInt100 )) ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_ownerReward := uint64 (( uint (( $ Л_totalReward )) * StakingContract_ι_NODE_FRACTION / $ xInt100 )) ) >> 
DePoolFuncOrig.v: 	 OwnerBase_Ф__increaseOwnerReward (( $ Л_ownerReward )) ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_oldestRound ^^ RoundsBase_ι_Round_ι_rewards := $ Л_roundReward ) >> 
DePoolFuncOrig.v: 	 ( d1! StakingContract_ι_m_lastRoundInterest := StakingContract_Ф__calcLastRoundInterest (( $ Л_roundStake , $ Л_roundReward )) ) >> 
DePoolFuncOrig.v: 	 RoundsBase_Ф__setOldestRound (( StakingContract_Ф__completeRound (( $ Л_oldestRound , RoundsBase_ι_ROUND_RECEIVED_REWARD )) )) ) >> 
DePoolFuncOrig.v:Definition StakingContract_Ф__completeRoundWithSpecialChunkSize ( $ Л_completedRound : ι_Round )( $ Л_completionStatus : XInteger8 )( $ Л_chunkSize : XInteger8 ) : StakingContractT ι_Round := 
DePoolFuncOrig.v: ( d2! Л_completedRound ^^ RoundsBase_ι_Round_ι_completionStatus := $ Л_completionStatus ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_completedRound ^^ RoundsBase_ι_Round_ι_step := RoundsBase_ι_STEP_COMPLETING ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_completedRound ^^ RoundsBase_ι_Round_ι_end := uint32 (( now )) ) >> 
DePoolFuncOrig.v: 	 RoundsBase_Ф__setOrDeletePendingRound (( $ Л_completedRound )) ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_completedRound := StakingContract_Ф__completePendingRound (( $ Л_completedRound , $ Л_chunkSize )) ) >> 
DePoolFuncOrig.v: 	 RoundsBase_Ф__setOrDeletePendingRound (( $ Л_completedRound )) ) >> 
DePoolFuncOrig.v: 	 delete $ Л_completedRound ^^ RoundsBase_ι_Round_ι_stakes ) >> 
DePoolFuncOrig.v: 	 return $ Л_completedRound ) >> 
DePoolFuncOrig.v:Definition StakingContract_Ф__completeRound ( $ Л_completedRound : ι_Round )( $ Л_completionStatus : XInteger8 ) : StakingContractT ι_Round := 
DePoolFuncOrig.v: return StakingContract_Ф__completeRoundWithSpecialChunkSize (( $ Л_completedRound , $ Л_completionStatus , StakingContract_ι_MAX_MSGS_PER_TR )) ) >> 
DePoolFuncOrig.v:Definition StakingContract_Ф__returnOrReinvestForStakeholder ( $ Л_completedRound : ι_Round )( $ Л_lastRound : ι_Round )( $ Л_addr : XAddress )( $ Л_stakes : ι_StakeValue ) : StakingContractT ι_Round := 
DePoolFuncOrig.v: ( d0! Л_newStake := $ Л_stakes ^^ RoundsBase_ι_StakeValue_ι_simple ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_newVesting := $ Л_stakes ^^ RoundsBase_ι_StakeValue_ι_vesting ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_stakeSum := RoundsBase_Ф_sumOfStakes (( $ Л_stakes )) ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_reward := tvm_max (( int64 (( int (( $ Л_stakeSum )) * $ Л_completedRound ^^ RoundsBase_ι_Round_ι_rewards / $ Л_completedRound ^^ RoundsBase_ι_Round_ι_stake - int (( StakingContract_ι_NOTIFY_FEE )) )) , - int64 (( $ Л_stakeSum )) )) ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_stakeholder := StakeholderBase_Ф__getStakeholder (( $ Л_addr )) ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake := uint64 (( int64 (( $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake )) + $ Л_reward )) ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_stakeholder ^^ OwnerBase_ι_Owner_ι_reward += $ Л_reward ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_notificationFee := StakingContract_ι_NOTIFY_FEE ) >> 
DePoolFuncOrig.v: Ift ( $ Л_reward ?< $ xInt0 ) { ( d0! Л_notificationFee := uint64 (( - $ Л_reward )) ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_targetDecrease := uint64 (( - $ Л_reward )) ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_deltaSimple := tvm_min (( $ Л_newStake , $ Л_targetDecrease )) ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_newStake -= $ Л_deltaSimple ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_newVesting -= $ Л_targetDecrease - $ Л_deltaSimple ) >> 
DePoolFuncOrig.v: Ift ( $ Л_reward ?> $ xInt0 ) { ( d0! Л_newStake += uint64 (( $ Л_reward )) ) >> 
DePoolFuncOrig.v: Ift ( $ Л_newVesting ?!= $ xInt0 ) { ( d0! Л_periodQty := (( uint64 (( now )) - $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_lastPaymentUnixTime )) / $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_withdrawalPeriod ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_withdrawalVesting := tvm_min (( $ Л_periodQty * $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_periodPayment , $ Л_newVesting )) ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_newVesting -= $ Л_withdrawalVesting ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_newStake += $ Л_withdrawalVesting ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderUpdateLastPaymentTime (( $ Л_stakeholder , $ Л_periodQty )) ) >> 
DePoolFuncOrig.v: Ift ( $ Л_newVesting ?< StakingContract_ι_m_minStake ) { ( d0! Л_newStake += $ Л_newVesting ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_newVesting := $ xInt0 ) >> 
DePoolFuncOrig.v: Ift ( $ Л_newStake ?< StakingContract_ι_m_minStake ) { ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderIncreaseUnusedStake (( $ Л_stakeholder , $ Л_newStake )) ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_newStake := $ xInt0 ) >> 
DePoolFuncOrig.v: Ife ( StakingContract_ι_m_poolClosed ) { ( d0! Л_attachedValue := $ Л_newStake + $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_stakeholder := StakeholderBase_Ф_stakeholderDecreaseStakeAndUnused (( $ Л_stakeholder , $ Л_newStake + $ Л_newVesting , $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake )) ) >> 
DePoolFuncOrig.v: Ift ( $ Л_newVesting ?!= $ xInt0 && $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_vestingOwner ?!= xInt0 ) { $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_vestingOwner . transfer (( 
DePoolFuncOrig.v: value : $ Л_newVesting , flag : $ xInt3 
DePoolFuncOrig.v: ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderResetVesting (( $ Л_stakeholder )) ) >> 
DePoolFuncOrig.v: ( d0! Л_attachedValue := $ xInt1 ) >> 
DePoolFuncOrig.v: Ife ( $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_reinvest ) { ( d0! Л_lastRound := RoundsBase_Ф__roundAddStakeAndVesting (( $ Л_lastRound , $ Л_addr , $ Л_newStake , $ Л_newVesting )) ) >> 
DePoolFuncOrig.v: ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderIncreaseUnusedStake (( $ Л_stakeholder , $ Л_newStake )) ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_lastRound := RoundsBase_Ф__roundAddStakeAndVesting (( $ Л_lastRound , $ Л_addr , $ xInt0 , $ Л_newVesting )) ) >> 
DePoolFuncOrig.v: StakeholderBase_Ф__setOrDeleteStakeholder (( $ Л_addr , $ Л_stakeholder )) ) >> 
DePoolFuncOrig.v: 	 IParticipant (( $ Л_addr )) . library_Ф_receiveRewardStake 
DePoolFuncOrig.v: value : $ Л_attachedValue , flag : $ xInt3 
DePoolFuncOrig.v: (( $ Л_completedRound ^^ RoundsBase_ι_Round_ι_id , $ Л_reward , $ Л_newStake , $ Л_newVesting , $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_reinvest , $ Л_notificationFee , $ Л_completedRound ^^ RoundsBase_ι_Round_ι_completionStatus )) ) >> 
DePoolFuncOrig.v: 	 return $ Л_lastRound ) >> 
DePoolFuncOrig.v:Definition StakingContract_Ф__returnOrReinvest ( $ Л_completedRound : ι_Round )( $ Л_chunkSize : XInteger8 ) : StakingContractT ι_Round := 
DePoolFuncOrig.v: ( d1! RoundsBase_ι_Round_ι_stakes := $ Л_completedRound ^^ RoundsBase_ι_Round_ι_stakes ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_lastRound := RoundsBase_Ф__getLastRound () ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_sentMsgs := $ xInt0 ) >> 
DePoolFuncOrig.v: 	 while (( ! empty () && $ Л_sentMsgs ?< $ Л_chunkSize ) { $ Л_sentMsgs ++ ) >> 
DePoolFuncOrig.v: 	 (( $ Л_addr , $ Л_stake )) := delMin () ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_lastRound := StakingContract_Ф__returnOrReinvestForStakeholder (( $ Л_completedRound , $ Л_lastRound , $ Л_addr , $ Л_stake )) ) >> 
DePoolFuncOrig.v: Ift ( $ Л_completedRound ^^ RoundsBase_ι_Round_ι_id ?!= $ Л_lastRound ^^ RoundsBase_ι_Round_ι_id ) { RoundsBase_Ф__setLastRound (( $ Л_lastRound )) ) >> 
DePoolFuncOrig.v: ( d2! Л_completedRound ^^ RoundsBase_ι_Round_ι_step := empty () ? RoundsBase_ι_STEP_COMPLETED : RoundsBase_ι_STEP_COMPLETING ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_completedRound ^^ RoundsBase_ι_Round_ι_stakes := RoundsBase_ι_Round_ι_stakes ) >> 
DePoolFuncOrig.v: 	 return $ Л_completedRound ) >> 
DePoolFuncOrig.v:Definition StakingContract_Ф__getMsgValueAndSendErrorIfNeeded ( msg_value : XInteger ) ( $ Л_unused : XInteger64 ) : StakingContractT XInteger64 # XBool := 
DePoolFuncOrig.v: 	 ( d0! Л_msgValue := uint64 (( $ msg_value )) ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_minRequiredValue := StakingContract_ι_m_minStake + StakingContract_ι_ADD_STAKE_FEE ) >> 
DePoolFuncOrig.v: Ift ( $ Л_msgValue + $ Л_unused ?< $ Л_minRequiredValue ) { StakingContract_Ф__sendError (( StakingContract_ι_STATUS_STAKE_TOO_SMALL , $ Л_minRequiredValue )) ) >> 
DePoolFuncOrig.v: return (( $ Л_msgValue - StakingContract_ι_ADD_STAKE_FEE , $ xBoolTrue )) ) >> 
DePoolFuncOrig.v:Definition StakingContract_Ф_investStake ( msg_sender : XInteger ) ( $ Л_unusedStake : XInteger64 )( $ Л_reinvest : XBool ) : StakingContractT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: 	 ( d0! Л_stakeholder := StakeholderBase_Ф__getStakeholder (( $ msg_sender )) ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_unusedStake := tvm_min (( $ Л_unusedStake , $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake )) ) >> 
DePoolFuncOrig.v: 	 (( $ Л_msgValue , $ Л_ok )) := StakingContract_Ф__getMsgValueAndSendErrorIfNeeded (( $ Л_unusedStake )) ) >> 
DePoolFuncOrig.v: Ift ( ! $ Л_ok ) { return ) >> 
DePoolFuncOrig.v: ( d0! Л_stake := $ Л_unusedStake + $ Л_msgValue ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_round := RoundsBase_Ф__getLastRound () ) >> 
DePoolFuncOrig.v: Ift ( $ Л_round ^^ RoundsBase_ι_Round_ι_stake + $ Л_stake ?> StakingContract_ι_m_maxRoundStake ) { return StakingContract_Ф__sendError (( StakingContract_ι_STATUS_ROUND_STAKE_LIMIT , StakingContract_ι_m_maxRoundStake - $ Л_round ^^ RoundsBase_ι_Round_ι_stake )) ) >> 
DePoolFuncOrig.v: RoundsBase_Ф__setLastRound (( RoundsBase_Ф__roundAddStakeAndVesting (( $ Л_round , $ msg_sender , $ Л_stake , $ xInt0 )) )) ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake -= $ Л_unusedStake ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake += $ Л_msgValue ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_reinvest := $ Л_reinvest ) >> 
DePoolFuncOrig.v: 	 StakeholderBase_Ф__setOrDeleteStakeholder (( $ msg_sender , $ Л_stakeholder )) ) >> 
DePoolFuncOrig.v:Definition StakingContract_Ф_addVesting ( msg_sender : XInteger ) ( $ Л_dest : XAddress )( $ Л_withdrawalPeriod : XInteger32 )( $ Л_totalPeriod : XInteger32 ) : StakingContractT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: Require (( $ Л_dest ^^ isStdAddrWithoutAnyCast () , library_Errors_ι_INVALID_ADDRESS )) ) >> 
DePoolFuncOrig.v: Ift ( $ Л_dest ?== xInt0 ) { ( d0! Л_dest := $ msg_sender ) >> 
DePoolFuncOrig.v: (( $ Л_stake , $ Л_ok )) := StakingContract_Ф__getMsgValueAndSendErrorIfNeeded (( $ xInt0 )) ) >> 
DePoolFuncOrig.v: Ift ( ! $ Л_ok ) { return ) >> 
DePoolFuncOrig.v: ( d0! Л_round := RoundsBase_Ф__getLastRound () ) >> 
DePoolFuncOrig.v: Ift ( $ Л_round ^^ RoundsBase_ι_Round_ι_stake + $ Л_stake ?> StakingContract_ι_m_maxRoundStake ) { return StakingContract_Ф__sendError (( StakingContract_ι_STATUS_ROUND_STAKE_LIMIT , StakingContract_ι_m_maxRoundStake - $ Л_round ^^ RoundsBase_ι_Round_ι_stake )) ) >> 
DePoolFuncOrig.v: Ift ( $ Л_withdrawalPeriod ?> $ Л_totalPeriod ) { return StakingContract_Ф__sendError (( StakingContract_ι_STATUS_WITHDRAWAL_PERIOD_GREATER_TOTAL_PERIOD , $ xInt0 )) ) >> 
DePoolFuncOrig.v: Ift ( $ Л_totalPeriod ?>= $ xInt100 * (( $ Л_days )) ) { return StakingContract_Ф__sendError (( StakingContract_ι_STATUS_TOTAL_PERIOD_MORE_100YEARS , $ xInt0 )) ) >> 
DePoolFuncOrig.v: Ift ( $ Л_withdrawalPeriod ?== $ xInt0 ) { return StakingContract_Ф__sendError (( StakingContract_ι_STATUS_WITHDRAWAL_PERIOD_IS_ZERO , $ xInt0 )) ) >> 
DePoolFuncOrig.v: Ift ( $ Л_totalPeriod $ Л_% $ Л_withdrawalPeriod ?!= $ xInt0 ) { return StakingContract_Ф__sendError (( StakingContract_ι_STATUS_TOTAL_PERIOD_IS_NOT_DIVED_BY_WITHDRAWAL_PERIOD , $ xInt0 )) ) >> 
DePoolFuncOrig.v: ( d0! Л_stakeholder := StakeholderBase_Ф__getStakeholder (( $ Л_dest )) ) >> 
DePoolFuncOrig.v: Ift ( StakeholderBase_Ф__haveVesting (( $ Л_stakeholder )) ) { return StakingContract_Ф__sendError (( StakingContract_ι_STATUS_STAKEHOLDER_HAVE_ALREADY_VESTING , $ xInt0 )) ) >> 
DePoolFuncOrig.v: ( d0! Л_periodPayment := uint64 (( uint (( $ Л_stake )) * $ Л_withdrawalPeriod / $ Л_totalPeriod )) ) >> 
DePoolFuncOrig.v: Ift ( $ Л_periodPayment ?== $ xInt0 ) { return StakingContract_Ф__sendError (( StakingContract_ι_STATUS_PERIOD_PAYMENT_IS_ZERO , $ xInt0 )) ) >> 
DePoolFuncOrig.v: ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderSetVesting (( $ Л_stakeholder , $ Л_stake , $ Л_withdrawalPeriod , $ Л_periodPayment , $ msg_sender )) ) >> 
DePoolFuncOrig.v: 	 StakeholderBase_Ф__setOrDeleteStakeholder (( $ Л_dest , $ Л_stakeholder )) ) >> 
DePoolFuncOrig.v: 	 RoundsBase_Ф__setLastRound (( RoundsBase_Ф__roundAddStakeAndVesting (( $ Л_round , $ Л_dest , $ xInt0 , $ Л_stake )) )) ) >> 
DePoolFuncOrig.v:Definition StakingContract_Ф_removeStake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_doRemoveFromCurrentRound : XBool )( $ Л_targetValue : XInteger64 ) : StakingContractT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: (( $ Л_exists , $ Л_participant )) := StakeholderBase_Ф__stakeholderFetch (( $ msg_sender )) ) >> 
DePoolFuncOrig.v: Ift ( ! $ Л_exists ) { return StakingContract_Ф__sendError (( StakingContract_ι_STATUS_NO_STAKEHOLDER , $ xInt0 )) ) >> 
DePoolFuncOrig.v: Ift ( $ Л_targetValue ?== $ xInt0 ) { ( d0! Л_targetValue := StakingContract_ι_MAX_MONEY_VALUE ) >> 
DePoolFuncOrig.v: ( d0! Л_removedStake := $ xInt0 ) >> 
DePoolFuncOrig.v: Ift ( $ Л_doRemoveFromCurrentRound && RoundsBase_Ф__getRoundsCount () ?> $ xInt0 ) { (( $ Л_removedStake , $ Л_unused )) := RoundsBase_Ф__roundRemoveStakeInLastRound (( $ msg_sender , $ Л_targetValue , StakingContract_ι_m_minStake )) ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_participant := StakeholderBase_Ф__stakeholderIncreaseUnusedStake (( $ Л_participant , $ Л_unused )) ) >> 
DePoolFuncOrig.v: ( d0! Л_removedUnused := tvm_min (( $ Л_targetValue - $ Л_removedStake , $ Л_participant ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake )) ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_participant := StakeholderBase_Ф_stakeholderDecreaseStakeAndUnused (( $ Л_participant , $ Л_removedStake , $ Л_removedUnused )) ) >> 
DePoolFuncOrig.v: 	 StakeholderBase_Ф__setOrDeleteStakeholder (( $ msg_sender , $ Л_participant )) ) >> 
DePoolFuncOrig.v: Ift ( $ Л_removedStake + $ Л_removedUnused ?== $ xInt0 ) { return StakingContract_Ф__sendError (( StakingContract_ι_STATUS_NO_AVAILABLE_TOKENS , $ xInt0 )) ) >> 
DePoolFuncOrig.v: $ msg_sender ^^ transfer (( $ Л_removedStake + $ Л_removedUnused , $ xBoolTrue , $ xInt3 )) ) >> 
DePoolFuncOrig.v:Definition StakingContract_Ф_setReinvest ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_flag : XBool ) : StakingContractT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: (( $ Л_exists , $ Л_stakeholder )) := StakeholderBase_Ф__stakeholderFetch (( $ msg_sender )) ) >> 
DePoolFuncOrig.v: Ift ( ! $ Л_exists ) { return StakingContract_Ф__sendError (( StakingContract_ι_STATUS_NO_STAKEHOLDER , $ xInt0 )) ) >> 
DePoolFuncOrig.v: ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderSetReinvest (( $ Л_stakeholder , $ Л_flag )) ) >> 
DePoolFuncOrig.v: 	 StakeholderBase_Ф__setOrDeleteStakeholder (( $ msg_sender , $ Л_stakeholder )) ) >> 
DePoolFuncOrig.v:Definition StakingContract_Ф_transferStake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_destination : XAddress )( $ Л_amount : XInteger64 ) : StakingContractT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: 	 ( d0! Л_sender := $ msg_sender ) >> 
DePoolFuncOrig.v: 	 (( $ Л_exists , $ Л_donor )) := StakeholderBase_Ф__stakeholderFetch (( $ Л_sender )) ) >> 
DePoolFuncOrig.v: Ift ( ! $ Л_exists ) { return StakingContract_Ф__sendError (( StakingContract_ι_STATUS_NO_STAKEHOLDER , $ xInt0 )) ) >> 
DePoolFuncOrig.v: Require (( $ Л_destination ^^ isStdAddrWithoutAnyCast () && ! $ Л_destination ^^ isStdZero () , library_Errors_ι_INVALID_ADDRESS )) ) >> 
DePoolFuncOrig.v: Ift ( $ Л_amount ?== $ xInt0 ) { ( d0! Л_amount := StakingContract_ι_MAX_MONEY_VALUE ) >> 
DePoolFuncOrig.v: ( d0! Л_receiver := StakeholderBase_Ф__getStakeholder (( $ Л_destination )) ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_transferredStake := RoundsBase_Ф__roundMoveStakes (( $ Л_sender , $ Л_destination , $ Л_amount )) ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_transferredUnused := tvm_min (( $ Л_amount - $ Л_transferredStake , $ Л_donor ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake )) ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_donor := StakeholderBase_Ф_stakeholderDecreaseStakeAndUnused (( $ Л_donor , $ Л_transferredStake , $ Л_transferredUnused )) ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_receiver := StakeholderBase_Ф__stakeholderIncreaseStakeAndUnused (( $ Л_receiver , $ Л_transferredStake , $ Л_transferredUnused )) ) >> 
DePoolFuncOrig.v: 	 StakeholderBase_Ф__setOrDeleteStakeholder (( $ Л_sender , $ Л_donor )) ) >> 
DePoolFuncOrig.v: 	 StakeholderBase_Ф__setOrDeleteStakeholder (( $ Л_destination , $ Л_receiver )) ) >> 
DePoolFuncOrig.v:Definition StakingContract_Ф_processNewStake ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_validatorKey : XInteger256 )( $ Л_stakeAt : XInteger32 )( $ Л_maxFactor : XInteger32 )( $ Л_adnlAddr : XInteger256 )( $ Л_signature : XInteger8 ) : StakingContractT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: 	 ( d0! Л_request := ElectorBase_ι_Request (( $ Л_queryId , $ Л_validatorKey , $ Л_stakeAt , $ Л_maxFactor , $ Л_adnlAddr , $ Л_signature )) ) >> 
DePoolFuncOrig.v: 	 StakingContract_Ф__addRequest (( $ Л_stakeAt , $ Л_request )) ) >> 
DePoolFuncOrig.v: Ife ( $ Л_stakeAt ?== ElectionParams_Ф__getElectAt () ) { 
DePoolFuncOrig.v: 	 ( d0! Л_round := RoundsBase_Ф__getPenultimateRound () ) >> 
DePoolFuncOrig.v: 	 Require (( $ Л_round ^^ RoundsBase_ι_Round_ι_step ?== RoundsBase_ι_STEP_WAITING_REQUESTS , library_Errors_ι_WRONG_ROUND_STATE )) ) >> 
DePoolFuncOrig.v: 	 Require (( $ Л_stakeAt ?== $ Л_round ^^ RoundsBase_ι_Round_ι_id , library_Errors_ι_INVALID_ELECTION_ID )) ) >> 
DePoolFuncOrig.v: 	 ( d2! Л_round ^^ RoundsBase_ι_Round_ι_step := RoundsBase_ι_STEP_ELECTIONS ) >> 
DePoolFuncOrig.v: 	 ElectorBase_Ф__sendRequestToElector (( $ Л_request , $ Л_round ^^ RoundsBase_ι_Round_ι_stake )) ) >> 
DePoolFuncOrig.v: 	 RoundsBase_Ф__setPenultimateRound (( $ Л_round )) ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_electionsStarted := now ?>= ElectionParams_Ф__getElectionsStart () ) >> 
DePoolFuncOrig.v: Ife ( $ Л_electionsStarted ) { StakingContract_Ф__addNewRoundAndUpdateRounds () ) >> 
DePoolFuncOrig.v:Definition StakingContract_Ф_forceCompletePendingRound ( msg_sender : XInteger ) ( $ Л_doCompleteOneChunk : XBool )( $ Л_chunkSize : XInteger8 ) : StakingContractT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: 	 (( _ , $ Л_round , $ Л_ok )) := RoundsBase_Ф__fetchOldestPendingRound () ) >> 
DePoolFuncOrig.v: 	 Require (( $ Л_ok , library_Errors_ι_NO_PENDING_ROUNDS )) ) >> 
DePoolFuncOrig.v: 	 Require (( $ Л_round ^^ RoundsBase_ι_Round_ι_end + $ xInt1 $ Л_hours ?< now , library_Errors_ι_PENDING_ROUND_IS_TOO_YOUNG )) ) >> 
DePoolFuncOrig.v: Ife ( $ Л_doCompleteOneChunk ) { ( d0! Л_round := StakingContract_Ф__returnOrReinvest (( $ Л_round , $ Л_chunkSize )) ) >> 
DePoolFuncOrig.v: ( d0! Л_round := StakingContract_Ф__completePendingRound (( $ Л_round , $ Л_chunkSize )) ) >> 
DePoolFuncOrig.v: RoundsBase_Ф__setOrDeletePendingRound (( $ Л_round )) ) >> 
DePoolFuncOrig.v:Definition StakingContract_Ф_completePendingRoundChunk ( msg_sender : XInteger ) ( $ Л_roundId : XInteger32 )( $ Л_chunkSize : XInteger8 ) : StakingContractT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: 	 (( $ Л_exists , $ Л_round )) := RoundsBase_Ф__roundFetchPendingRound (( $ Л_roundId )) ) >> 
DePoolFuncOrig.v: Ift ( $ Л_exists ) { tvm_accept () ) >> 
DePoolFuncOrig.v: 	 RoundsBase_Ф__setOrDeletePendingRound (( StakingContract_Ф__returnOrReinvest (( $ Л_round , $ Л_chunkSize )) )) ) >> 
DePoolFuncOrig.v:Definition StakingContract_Ф_receiveReturnedStake ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_comment : XInteger32 ) : StakingContractT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: 	 ( d0! Л_round := RoundsBase_Ф__getPenultimateRound () ) >> 
DePoolFuncOrig.v: 	 RoundsBase_Ф__setPenultimateRound (( StakingContract_Ф__completeRound (( $ Л_round , RoundsBase_ι_ROUND_STAKE_REJECTED )) )) ) >> 
DePoolFuncOrig.v: 	 emit $ Л_roundStakeIsRejected (( $ Л_queryId , $ Л_comment )) ) >> 
DePoolFuncOrig.v:Definition StakingContract_Ф_acceptRecoveredStake ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 ) : StakingContractT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: Ife ( $ Л_queryId ?== $ xInt0 ) { StakingContract_Ф__acceptUnusedStake () ) >> 
DePoolFuncOrig.v: Ife ( $ Л_queryId ?== $ xInt1 ) { StakingContract_Ф__acceptRewardStake () ) >> 
DePoolFuncOrig.v: StakingContract_Ф__acceptPendingRoundStake (( uint32 (( $ Л_queryId )) )) ) >> 
DePoolFuncOrig.v:Definition StakingContract_Ф_terminator ( $ Л_chunkSize : XInteger8 ) : StakingContractT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: Ift ( RoundsBase_Ф__getRoundsCount () ?!= $ xInt0 ) { ( d0! Л_lastRound := RoundsBase_Ф__getLastRound () ) >> 
DePoolFuncOrig.v: 	 RoundsBase_Ф__setLastRound (( StakingContract_Ф__completeRoundWithSpecialChunkSize (( $ Л_lastRound , RoundsBase_ι_ROUND_POOL_CLOSED , $ Л_chunkSize )) )) ) >> 
DePoolFuncOrig.v: emit $ Л_stakingPoolClosed () ) >> 
DePoolFuncOrig.v:Definition DePool_Ф_getStakeholderInfo ( $ Л_addr : XAddress ) : DePoolT XInteger64 # XInteger64 # XInteger64 # XBool # XInteger64 # ι_М_StakeInfo := 
DePoolFuncOrig.v: (( $ Л_exists , $ Л_stakeholder )) := StakeholderBase_Ф__stakeholderFetch (( $ Л_addr )) ) >> 
DePoolFuncOrig.v: 	 Require (( $ Л_exists , library_Errors_ι_NO_SUCH_STAKEHOLDER )) ) >> 
DePoolFuncOrig.v: 	 ( d1! StakeholderBase_ι_Stakeholder_ι_reinvest := $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_reinvest ) >> 
DePoolFuncOrig.v: 	 $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake ) >> 
DePoolFuncOrig.v: 	 ( d1! OwnerBase_ι_Owner_ι_reward := $ Л_stakeholder ^^ OwnerBase_ι_Owner_ι_reward ) >> 
DePoolFuncOrig.v: 	 $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_invested2 := $ xInt0 ) >> 
DePoolFuncOrig.v: 	 (( $ Л_index , $ Л_round , $ Л_ok )) := min () ) >> 
DePoolFuncOrig.v: 	 while (( $ Л_ok ) { 
DePoolFuncOrig.v: Ife ( $ Л_round ^^ RoundsBase_ι_Round_ι_step ?< RoundsBase_ι_STEP_COMPLETED ) { (( $ Л_presents , $ Л_value )) := $ Л_round ^^ RoundsBase_ι_Round_ι_stakes . fetch (( $ Л_addr )) ) >> 
DePoolFuncOrig.v: Ift ( $ Л_presents ) { push (( DePool_ι_StakeInfo (( $ Л_round ^^ RoundsBase_ι_Round_ι_id , $ Л_value ^^ RoundsBase_ι_StakeValue_ι_simple , $ Л_value ^^ RoundsBase_ι_StakeValue_ι_vesting )) )) ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_invested2 += $ Л_value ^^ RoundsBase_ι_StakeValue_ι_simple + $ Л_value ^^ RoundsBase_ι_StakeValue_ι_vesting ) >> 
DePoolFuncOrig.v: (( $ Л_presents , $ Л_value )) := $ Л_round ^^ RoundsBase_ι_Round_ι_stakes . fetch (( $ Л_addr )) ) >> 
DePoolFuncOrig.v: Ift ( $ Л_presents ) { ( d0! Л_invested2 += $ Л_value ^^ RoundsBase_ι_StakeValue_ι_simple + $ Л_value ^^ RoundsBase_ι_StakeValue_ι_vesting ) >> 
DePoolFuncOrig.v: (( $ Л_index , $ Л_round , $ Л_ok )) := next (( $ Л_index )) ) >> 
DePoolFuncOrig.v: (( $ Л_index , $ Л_round , $ Л_ok )) := min () ) >> 
DePoolFuncOrig.v: 	 while (( $ Л_ok ) { (( $ Л_presents , $ Л_value )) := $ Л_round ^^ RoundsBase_ι_Round_ι_stakes . fetch (( $ Л_addr )) ) >> 
DePoolFuncOrig.v: Ift ( $ Л_presents ) { ( d0! Л_invested2 += $ Л_value ^^ RoundsBase_ι_StakeValue_ι_simple + $ Л_value ^^ RoundsBase_ι_StakeValue_ι_vesting ) >> 
DePoolFuncOrig.v: (( $ Л_index , $ Л_round , $ Л_ok )) := next (( uint32 (( $ Л_index )) )) ) >> 
DePoolFuncOrig.v:Definition StakingProxyContract_Ф_process_new_stake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_validatorKey : XInteger256 )( $ Л_stakeAt : XInteger32 )( $ Л_maxFactor : XInteger32 )( $ Л_adnlAddr : XInteger256 )( $ Л_signature : XInteger8 ) : StakingProxyContractT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: 	 IElector (( ElectorBase_ι_m_elector )) . library_Ф_elector_process_new_stake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId , $ Л_validatorKey , $ Л_stakeAt , $ Л_maxFactor , $ Л_adnlAddr , $ Л_signature )) ) >> 
DePoolFuncOrig.v:Definition ElectionParams_Ф_Constructor4 ( $ Л_electionId : XInteger32 )( $ Л_beginBefore : XInteger32 )( $ Л_endBefore : XInteger32 )( $ Л_heldFor : XInteger32 )( $ Л_electedFor : XInteger32 ) : ElectionParamsT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: Ife ( $ Л_electionId ?!= $ xInt0 ) { ( d1! ElectionParams_ι_m_electAt := $ Л_electionId ) >> 
DePoolFuncOrig.v: (( ElectionParams_ι_m_electedFor , ElectionParams_ι_m_beginBefore , ElectionParams_ι_m_endBefore , ElectionParams_ι_m_heldFor , $ Л_ok )) := tvm_configParam (( $ xInt15 )) ) >> 
DePoolFuncOrig.v: Ift ( ! $ Л_ok ) { ( d1! ElectionParams_ι_m_beginBefore := $ Л_beginBefore ) >> 
DePoolFuncOrig.v: 	 ( d1! ElectionParams_ι_m_endBefore := $ Л_endBefore ) >> 
DePoolFuncOrig.v: 	 ( d1! ElectionParams_ι_m_electedFor := $ Л_electedFor ) >> 
DePoolFuncOrig.v: 	 ( d1! ElectionParams_ι_m_heldFor := $ Л_heldFor ) >> 
DePoolFuncOrig.v:Definition StakingOwner_Ф_initTimer ( $ Л_timer : XAddress )( $ Л_period : XInteger ) : StakingOwnerT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: 	 ( d1! StakingOwner_ι_m_timer := $ Л_timer ) >> 
DePoolFuncOrig.v: 	 ( d1! StakingOwner_ι_m_timeout := $ Л_period ) >> 
DePoolFuncOrig.v: 	 StakingOwner_Ф__settimer (( $ Л_timer , $ Л_period )) ) >> 
DePoolFuncOrig.v:Definition StakingOwner_Ф_upgrade ( $ Л_newcode : TvmCell ) : StakingOwnerT (XErrorValue True XInteger) := 
DePoolFuncOrig.v: 	 tvm_setcode (( $ Л_newcode )) ) >> 
DePoolFuncOrig.v: 	 tvm_setCurrentCode (( $ Л_newcode )) ) >> 
DePoolFuncOrig.v:Definition RoundsBase_Ф__roundMoveStakes ( $ Л_source : XAddress )( $ Л_destination : XAddress )( $ Л_targetAmount : XInteger64 ) : RoundsBaseT XInteger64 := 
DePoolFuncOrig.v: (( $ Л_roundId , $ Л_round , $ Л_ok )) := min () ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_transferred := $ xInt0 ) >> 
DePoolFuncOrig.v: 	 while (( $ Л_ok && $ Л_targetAmount ?!= $ xInt0 ) { 
DePoolFuncOrig.v: Ift ( $ Л_round ^^ RoundsBase_ι_Round_ι_step ?!= RoundsBase_ι_STEP_COMPLETED && $ Л_round ^^ RoundsBase_ι_Round_ι_step ?!= RoundsBase_ι_STEP_COMPLETING ) { (( RoundsBase_ι_m_rounds [ $ Л_roundId ] , $ Л_currentTransferred )) := RoundsBase_Ф__roundMoveStake (( $ Л_round , $ Л_source , $ Л_destination , $ Л_targetAmount )) ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_targetAmount -= $ Л_currentTransferred ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_transferred += $ Л_currentTransferred ) >> 
DePoolFuncOrig.v: (( $ Л_roundId , $ Л_round , $ Л_ok )) := next (( $ Л_roundId )) ) >> 
DePoolFuncOrig.v: return $ Л_transferred ) >> 
DePoolFuncOrig.v:Definition StakingContract_Ф__completePendingRound ( $ Л_pendingRound : ι_Round )( $ Л_chunkSize : XInteger8 ) : StakingContractT ι_Round := 
DePoolFuncOrig.v: Ife ( $ Л_pendingRound ^^ RoundsBase_ι_Round_ι_participantQty ?> $ Л_chunkSize ) { for (( ( d0! Л_i := $ xInt0 ) >> 
DePoolFuncOrig.v: 	 $ Л_i ?< $ Л_pendingRound ^^ RoundsBase_ι_Round_ι_participantQty ) >> 
DePoolFuncOrig.v: 	 ( d0! Л_i += $ Л_chunkSize ) { this ^^ StakingContract_Ф_completePendingRoundChunk . value (( 1e7 )) (( $ Л_pendingRound ^^ RoundsBase_ι_Round_ι_id , $ Л_chunkSize )) ) >> 
DePoolFuncOrig.v: ( d0! Л_pendingRound := StakingContract_Ф__returnOrReinvest (( $ Л_pendingRound , $ Л_chunkSize )) ) >> 
DePoolFuncOrig.v: return $ Л_pendingRound ) >> 
depoolFuncs.v:Definition Participant_Ф_receiveRewardStake ( $ Л_roundId : XInteger32 )( $ Л_reward : XInteger64 )( $ Л_stake : XInteger64 )( $ Л_reinvest : XBool )( $ Л_fee : XInteger64 )( $ Л_reason : XInteger8 ) : ParticipantT True 
depoolFuncs.v:Definition Participant_Ф_receiveAnswer ( $ Л_errcode : XInteger32 )( $ Л_comment : XInteger64 ) : ParticipantT True 
depoolFuncs.v:Definition Participant_Ф_receiveRewardStake ( $ Л_roundId : XInteger32 )( $ Л_reward : XInteger64 )( $ Л_stake : XInteger64 )( $ Л_reinvest : XBool )( $ Л_fee : XInteger64 )( $ Л_reason : XInteger8 ) : ParticipantT True 
depoolFuncs.v:Definition Participant_Ф_receiveAnswer ( $ Л_errcode : XInteger32 )( $ Л_comment : XInteger64 ) : ParticipantT True 
depoolFuncs.v:Definition StakingProxyContract_Ф_process_new_stake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_validatorKey : XInteger256 )( $ Л_stakeAt : XInteger32 )( $ Л_maxFactor : XInteger32 )( $ Л_adnlAddr : XInteger256 )( $ Л_signature : XInteger8 ) : StakingProxyContractT := 
depoolFuncs.v: 	 IElector (( ElectorBase_ι_m_elector )) . _Ф_elector_process_new_stake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId , $ Л_validatorKey , $ Л_stakeAt , $ Л_maxFactor , $ Л_adnlAddr , $ Л_signature )) ) >> 
depoolFuncs.v:Definition StakingProxyContract_Ф_recover_stake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 ) : StakingProxyContractT := 
depoolFuncs.v: 	 IElector (( ElectorBase_ι_m_elector )) . _Ф_elector_recover_stake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId )) ) >> 
depoolFuncs.v:Definition StakingContract_Ф_receiveConfirmation ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_comment : XInteger32 ) : StakingContractT := 
depoolFuncs.v: 	 require (( $ Л_comment ?== $ xInt0 , $ xInt110 )) ) >> 
depoolFuncs.v: 	 require (( $ Л_queryId ?>= $ xInt0 , $ xInt110 )) ) >> 
depoolFuncs.v:Definition StakingContract_Ф_receiveReturnedStake ( $ Л_queryId : XInteger64 )( $ Л_comment : XInteger32 ) : StakingContractT XInteger64 # XInteger32 := 
depoolFuncs.v: ( d0! Л_round := RoundsBase_Ф__getPenultimateRound () ) >> 
depoolFuncs.v: 	 ( d2! Л_round ^^ RoundsBase_ι_Round_ι_completionStatus := RoundsBase_ι_ROUND_STAKE_REJECTED ) >> 
depoolFuncs.v: 	 return (( $ Л_queryId , $ Л_comment )) ) >> 
depoolFuncs.v:Definition StakingContract_Ф_acceptRecoveredStake ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 ) : StakingContractT := 
depoolFuncs.v: Ife ( $ Л_queryId ?== $ xInt0 ) { StakingContract_Ф__acceptUnusedStake () ) >> 
depoolFuncs.v: Ife ( $ Л_queryId ?== $ xInt1 ) { StakingContract_Ф__acceptRewardStake () ) >> 
depoolFuncs.v: StakingContract_Ф__acceptPendingRoundStake (( uint32 (( $ Л_queryId )) )) ) >> 
depoolFuncs.v: 	 ( d0! Л_electionsStarted := now ?>= ElectionParams_Ф__getElectionsStart () ) >> 
depoolFuncs.v: Ife ( $ Л_electionsStarted ) { StakingContract_Ф__addNewRoundAndUpdateRounds () ) >> 
depoolFuncs.v:Definition Stakeholder_Ф_sendTransaction ( $ Л_dest : XAddress )( $ Л_value : XInteger64 )( $ Л_bounce : XBool )( $ Л_flags : XInteger16 )( $ Л_payload : TvmCell ) : StakeholderT := 
depoolFuncs.v: 	 $ Л_dest ^^ transfer (( $ Л_value , $ Л_bounce , $ Л_flags , $ Л_payload )) ) >> 
depoolFuncs.v:Definition OwnerBase_Ф_Constructor2 ( $ Л_poolOwnerAddr : XAddress ) : OwnerBaseT := 
depoolFuncs.v: ( d1! OwnerBase_ι_m_owner := OwnerBase_ι_Owner (( $ Л_poolOwnerAddr , $ xInt0 )) ) >> 
depoolFuncs.v:Definition OwnerBase_Ф_withdrawOwnerReward ( msg_sender : XInteger ) ( $ Л_amount : XInteger64 ) : OwnerBaseT := 
depoolFuncs.v: 	 require (( $ Л_amount ?<= OwnerBase_ι_Owner_ι_reward , $ xInt105 )) ) >> 
depoolFuncs.v: 	 ( d1! OwnerBase_ι_Owner_ι_reward -= $ Л_amount ) >> 
depoolFuncs.v: 	 OwnerBase_ι_Owner_ι_addr . transfer (( $ Л_amount , $ xBoolTrue , $ xInt3 )) ) >> 
depoolFuncs.v:Definition OwnerBase_Ф__increaseOwnerReward ( $ Л_ownerReward : XInteger64 ) : OwnerBaseT := 
depoolFuncs.v: ( d1! OwnerBase_ι_Owner_ι_reward += $ Л_ownerReward ) >> 
depoolFuncs.v:Definition ElectorBase_Ф_Constructor3 ( $ Л_electorAddr : XAddress ) : ElectorBaseT := 
depoolFuncs.v: ( d1! ElectorBase_ι_m_elector := $ Л_electorAddr ) >> 
depoolFuncs.v: (( _ , , $ Л_utime_until , _ , , _ , , $ Л_ok )) := tvm_configParam (( $ xInt34 )) ) >> 
depoolFuncs.v: Ift ( ! $ Л_ok ) { ( d0! Л_offset := (( (( uint32 (( now )) - (( ElectionParams_ι_m_electAt - ElectionParams_ι_m_beginBefore )) )) / ElectionParams_ι_m_electedFor + $ xInt1 )) * ElectionParams_ι_m_electedFor ) >> 
depoolFuncs.v: 	 ( d0! Л_utime_until := ElectionParams_ι_m_electAt + $ Л_offset ) >> 
depoolFuncs.v: return $ Л_utime_until ) >> 
depoolFuncs.v:Definition ElectionParams_Ф__isElectionOver ( $ Л_currentElectAt : XInteger32 ) : ElectionParamsT XBool := 
depoolFuncs.v: return now ?>= (( $ Л_currentElectAt - ElectionParams_ι_m_endBefore )) ) >> 
depoolFuncs.v:Definition StakeholderBase_Ф__haveVesting ( $ Л_stakeholder : ι_Stakeholder ) : StakeholderBaseT XBool := 
depoolFuncs.v: return $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_periodPayment ?!= $ xInt0 ) >> 
depoolFuncs.v:Definition StakeholderBase_Ф__stakeholderSetVesting ( $ Л_stakeholder : ι_Stakeholder )( $ Л_stake : XInteger64 )( $ Л_withdrawalPeriod : XInteger32 )( $ Л_periodPayment : XInteger64 )( $ Л_vestingOwner : XAddress ) : StakeholderBaseT ι_Stakeholder := 
depoolFuncs.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake += $ Л_stake ) >> 
depoolFuncs.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_lastPaymentUnixTime := uint64 (( now )) ) >> 
depoolFuncs.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_withdrawalPeriod := $ Л_withdrawalPeriod ) >> 
depoolFuncs.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_periodPayment := $ Л_periodPayment ) >> 
depoolFuncs.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_vestingOwner := $ Л_vestingOwner ) >> 
depoolFuncs.v: 	 return $ Л_stakeholder ) >> 
depoolFuncs.v:Definition StakeholderBase_Ф__stakeholderExists ( $ Л_addr : XAddress ) : StakeholderBaseT XBool := 
depoolFuncs.v: return exists (( $ Л_addr )) ) >> 
depoolFuncs.v:Definition StakeholderBase_Ф__getStakeholder ( $ Л_addr : XAddress ) : StakeholderBaseT ι_Stakeholder := 
depoolFuncs.v: return StakeholderBase_ι_m_stakeholders [ $ Л_addr ] ) >> 
depoolFuncs.v:Definition StakeholderBase_Ф__stakeholderFetch ( $ Л_addr : XAddress ) : StakeholderBaseT XBool # ι_Stakeholder := 
depoolFuncs.v: return fetch (( $ Л_addr )) ) >> 
depoolFuncs.v:Definition StakeholderBase_Ф__setOrDeleteStakeholder ( $ Л_addr : XAddress )( $ Л_stakeholder : ι_Stakeholder ) : StakeholderBaseT := 
depoolFuncs.v: Ift ( $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake ?== $ xInt0 )) delete StakeholderBase_ι_m_stakeholders [ $ Л_addr ] ) >> 
depoolFuncs.v: 	 else ( d4! StakeholderBase_ι_m_stakeholders [ Л_addr ] := $ Л_stakeholder ) >> 
depoolFuncs.v:Definition StakeholderBase_Ф__stakeholderUpdateStake ( $ Л_addr : XAddress )( $ Л_totalStake : XInteger64 )( $ Л_reinvest : XBool ) : StakeholderBaseT := 
depoolFuncs.v: ( d0! Л_user := StakeholderBase_ι_m_stakeholders [ $ Л_addr ] ) >> 
depoolFuncs.v: 	 ( d2! Л_user ^^ StakeholderBase_ι_Stakeholder_ι_reinvest := $ Л_reinvest ) >> 
depoolFuncs.v: 	 ( d2! Л_user ^^ StakeholderBase_ι_Stakeholder_ι_totalStake += $ Л_totalStake ) >> 
depoolFuncs.v: 	 ( d4! StakeholderBase_ι_m_stakeholders [ Л_addr ] := $ Л_user ) >> 
depoolFuncs.v:Definition StakeholderBase_Ф__stakeholderUpdateStake2 ( $ Л_stakeholder : ι_Stakeholder )( $ Л_totalStake : XInteger64 )( $ Л_reinvest : XBool ) : StakeholderBaseT ι_Stakeholder := 
depoolFuncs.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_reinvest := $ Л_reinvest ) >> 
depoolFuncs.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake += $ Л_totalStake ) >> 
depoolFuncs.v: 	 return $ Л_stakeholder ) >> 
depoolFuncs.v:Definition StakeholderBase_Ф__stakeholderRemoveStake ( $ Л_addr : XAddress )( $ Л_removedStake : XInteger64 )( $ Л_unusedStake : XInteger64 ) : StakeholderBaseT := 
depoolFuncs.v: ( d0! Л_stakeholder := StakeholderBase_ι_m_stakeholders [ $ Л_addr ] ) >> 
depoolFuncs.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake -= $ Л_removedStake ) >> 
depoolFuncs.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake -= $ Л_unusedStake ) >> 
depoolFuncs.v: Ife ( $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake ?== $ xInt0 ) { delete StakeholderBase_ι_m_stakeholders [ $ Л_addr ] ) >> 
depoolFuncs.v: ( d4! StakeholderBase_ι_m_stakeholders [ Л_addr ] := $ Л_stakeholder ) >> 
depoolFuncs.v:Definition StakeholderBase_Ф__stakeholderIncreaseTotalAndUnused ( $ Л_stakeholder : ι_Stakeholder )( $ Л_deltaTotal : XInteger64 )( $ Л_deltaUnused : XInteger64 ) : StakeholderBaseT ι_Stakeholder := 
depoolFuncs.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake += $ Л_deltaTotal ) >> 
depoolFuncs.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake += $ Л_deltaUnused ) >> 
depoolFuncs.v: 	 return $ Л_stakeholder ) >> 
depoolFuncs.v:Definition StakeholderBase_Ф__stakeholderDecreaseTotalAndUnused ( $ Л_stakeholder : ι_Stakeholder )( $ Л_deltaTotal : XInteger64 )( $ Л_deltaUnused : XInteger64 ) : StakeholderBaseT ι_Stakeholder := 
depoolFuncs.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake -= $ Л_deltaTotal ) >> 
depoolFuncs.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake -= $ Л_deltaUnused ) >> 
depoolFuncs.v: 	 return $ Л_stakeholder ) >> 
depoolFuncs.v:Definition StakeholderBase_Ф__stakeholderSetReinvest ( $ Л_addr : XAddress )( $ Л_flag : XBool ) : StakeholderBaseT := 
depoolFuncs.v: StakeholderBase_ι_m_stakeholders [ $ Л_addr ( d2! ] ^^ StakeholderBase_ι_Stakeholder_ι_reinvest := $ Л_flag ) >> 
depoolFuncs.v:Definition StakeholderBase_Ф__stakeholderSetReinvest2 ( $ Л_stakeholder : ι_Stakeholder )( $ Л_flag : XBool ) : StakeholderBaseT ι_Stakeholder := 
depoolFuncs.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_reinvest := $ Л_flag ) >> 
depoolFuncs.v: 	 return $ Л_stakeholder ) >> 
depoolFuncs.v:Definition StakeholderBase_Ф__stakeholderUpdateGrossReward ( $ Л_stakeholder : ι_Stakeholder )( $ Л_reward : XInteger64 ) : StakeholderBaseT ι_Stakeholder := 
depoolFuncs.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_grossReward += $ Л_reward ) >> 
depoolFuncs.v: 	 return $ Л_stakeholder ) >> 
depoolFuncs.v:Definition StakeholderBase_Ф__stakeholderUpdateTotalStake ( $ Л_stakeholder : ι_Stakeholder )( $ Л_newStake : XInteger64 )( $ Л_oldStake : XInteger64 ) : StakeholderBaseT ι_Stakeholder := 
depoolFuncs.v: Ift ( $ Л_newStake ?>= $ Л_oldStake )) ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake += $ Л_newStake - $ Л_oldStake ) >> 
depoolFuncs.v: 	 else ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake -= $ Л_oldStake - $ Л_newStake ) >> 
depoolFuncs.v: 	 return $ Л_stakeholder ) >> 
depoolFuncs.v:Definition StakeholderBase_Ф__stakeholderUpdateUnusedStake ( $ Л_addr : XAddress )( $ Л_add : XInteger64 )( $ Л_remove : XInteger64 ) : StakeholderBaseT := 
depoolFuncs.v: StakeholderBase_ι_m_stakeholders [ $ Л_addr ( d2! ] ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake := (( StakeholderBase_ι_m_stakeholders [ $ Л_addr ] ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake + $ Л_add )) - $ Л_remove ) >> 
depoolFuncs.v:Definition StakeholderBase_Ф__stakeholderIncreaseUnusedStake ( $ Л_stakeholder : ι_Stakeholder )( $ Л_delta : XInteger64 ) : StakeholderBaseT ι_Stakeholder := 
depoolFuncs.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake += $ Л_delta ) >> 
depoolFuncs.v: 	 return $ Л_stakeholder ) >> 
depoolFuncs.v:Definition StakeholderBase_Ф__stakeholderDecreaseUnusedStake ( $ Л_stakeholder : ι_Stakeholder )( $ Л_delta : XInteger64 ) : StakeholderBaseT ι_Stakeholder := 
depoolFuncs.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake -= $ Л_delta ) >> 
depoolFuncs.v: 	 return $ Л_stakeholder ) >> 
depoolFuncs.v:Definition StakeholderBase_Ф__stakeholderResetVesting ( $ Л_stakeholder : ι_Stakeholder ) : StakeholderBaseT ι_Stakeholder := 
depoolFuncs.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_lastPaymentUnixTime := $ xInt0 ) >> 
depoolFuncs.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_withdrawalPeriod := $ xInt0 ) >> 
depoolFuncs.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_periodPayment := $ xInt0 ) >> 
depoolFuncs.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_vestingOwner := xInt0 ) >> 
depoolFuncs.v: 	 return $ Л_stakeholder ) >> 
depoolFuncs.v:Definition StakeholderBase_Ф__stakeholderUpdateLastPaymentTime ( $ Л_stakeholder : ι_Stakeholder )( $ Л_periodQty : XInteger64 ) : StakeholderBaseT ι_Stakeholder := 
depoolFuncs.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_lastPaymentUnixTime += $ Л_periodQty * $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_withdrawalPeriod ) >> 
depoolFuncs.v: 	 return $ Л_stakeholder ) >> 
depoolFuncs.v:Definition StakingOwner_Ф_Constructor5 ( $ Л_pool : XAddress ) : StakingOwnerT := 
depoolFuncs.v: 	 ( d1! StakingOwner_ι_m_stakingPool := $ Л_pool ) >> 
depoolFuncs.v:Definition StakingOwner_Ф_updateStakingPoolAddress ( $ Л_addr : XAddress ) : StakingOwnerT := 
depoolFuncs.v: 	 ( d1! StakingOwner_ι_m_stakingPool := $ Л_addr ) >> 
depoolFuncs.v:Definition StakingProxyContract_Ф_Constructor6 ( $ Л_staking : XAddress )( $ Л_elector : XAddress ) : StakingProxyContractT := 
depoolFuncs.v: 	 ( d1! StakingProxyContract_ι_m_staking := $ Л_staking ) >> 
depoolFuncs.v: 	 ( d1! ElectorBase_ι_m_elector := $ Л_elector ) >> 
depoolFuncs.v: (( $ Л_index , $ Л_round , $ Л_ok )) := min () ) >> 
depoolFuncs.v: 	 while (( $ Л_ok ) { infos ^^ push (( RoundsBase_ι_RoundInfo (( $ Л_round ^^ RoundsBase_ι_Round_ι_id , $ Л_round ^^ RoundsBase_ι_Round_ι_start , $ Л_round ^^ RoundsBase_ι_Round_ι_end , $ Л_round ^^ RoundsBase_ι_Round_ι_step , $ Л_round ^^ RoundsBase_ι_Round_ι_completionStatus , $ Л_round ^^ RoundsBase_ι_Round_ι_stake , $ Л_round ^^ RoundsBase_ι_Round_ι_participantQty , $ Л_round ^^ RoundsBase_ι_Round_ι_rewards )) )) ) >> 
depoolFuncs.v: 	 (( $ Л_index , $ Л_round , $ Л_ok )) := next (( $ Л_index )) ) >> 
depoolFuncs.v: (( $ Л_key , $ Л_round , $ Л_ok )) := min () ) >> 
depoolFuncs.v: 	 while (( $ Л_ok ) { infos ^^ push (( RoundsBase_ι_RoundInfo (( $ Л_round ^^ RoundsBase_ι_Round_ι_id , $ Л_round ^^ RoundsBase_ι_Round_ι_start , $ Л_round ^^ RoundsBase_ι_Round_ι_end , $ Л_round ^^ RoundsBase_ι_Round_ι_step , $ Л_round ^^ RoundsBase_ι_Round_ι_completionStatus , $ Л_round ^^ RoundsBase_ι_Round_ι_stake , $ Л_round ^^ RoundsBase_ι_Round_ι_participantQty , $ Л_round ^^ RoundsBase_ι_Round_ι_rewards )) )) ) >> 
depoolFuncs.v: 	 (( $ Л_key , $ Л_round , $ Л_ok )) := next (( $ Л_key )) ) >> 
depoolFuncs.v:Definition RoundsBase_Ф__addNewPoolingRound ( $ Л_validationStart : XInteger32 )( $ Л_validationPeriod : XInteger32 ) : RoundsBaseT := 
depoolFuncs.v: RoundsBase_ι_Round_ι_id : $ Л_validationStart , RoundsBase_ι_Round_ι_step : RoundsBase_ι_STEP_POOLING , RoundsBase_ι_Round_ι_participantQty : $ xInt0 , RoundsBase_ι_Round_ι_stake : $ xInt0 , RoundsBase_ι_Round_ι_rewards : $ xInt0 , RoundsBase_ι_Round_ι_unused : $ xInt0 , RoundsBase_ι_Round_ι_completionStatus : RoundsBase_ι_ROUND_UNDEFINED , RoundsBase_ι_Round_ι_start : uint32 (( now )) , RoundsBase_ι_Round_ι_end : $ Л_validationStart + $ Л_validationPeriod 
depoolFuncs.v: (( _ , $ Л_round )) := delMin () ) >> 
depoolFuncs.v: 	 return $ Л_round ) >> 
depoolFuncs.v:Definition RoundsBase_Ф__setOldestRound ( $ Л_round : ι_Round ) : RoundsBaseT := 
depoolFuncs.v: ( d4! RoundsBase_ι_m_rounds [ RoundsBase_ι_m_startIdx ] := $ Л_round ) >> 
depoolFuncs.v:Definition RoundsBase_Ф__roundAddStakeAndVesting ( $ Л_round : ι_Round )( $ Л_addr : XAddress )( $ Л_stake : XInteger64 )( $ Л_vestingStake : XInteger64 ) : RoundsBaseT ι_Round := 
depoolFuncs.v: ( d0! Л_totalStake := $ Л_stake + $ Л_vestingStake ) >> 
depoolFuncs.v: Ift ( $ Л_totalStake ?== $ xInt0 )) return $ Л_round ) >> 
depoolFuncs.v: Ift ( ! $ Л_round ^^ RoundsBase_ι_Round_ι_stakes . exists (( $ Л_addr )) ) { $ Л_round ^^ RoundsBase_ι_Round_ι_participantQty ++ ) >> 
depoolFuncs.v: ( d2! Л_round ^^ RoundsBase_ι_Round_ι_stake += $ Л_totalStake ) >> 
depoolFuncs.v: 	 ( d0! Л_sv := $ Л_round ^^ RoundsBase_ι_Round_ι_stakes [ $ Л_addr ] ) >> 
depoolFuncs.v: 	 ( d2! Л_sv ^^ RoundsBase_ι_StakeValue_ι_simple += $ Л_stake ) >> 
depoolFuncs.v: 	 ( d2! Л_sv ^^ RoundsBase_ι_StakeValue_ι_vesting += $ Л_vestingStake ) >> 
depoolFuncs.v: 	 ( d3! Л_round ^^ RoundsBase_ι_Round_ι_stakes [ Л_addr ] := $ Л_sv ) >> 
depoolFuncs.v: 	 return $ Л_round ) >> 
depoolFuncs.v:Definition RoundsBase_Ф__roundMoveStake ( $ Л_round : ι_Round )( $ Л_source : XAddress )( $ Л_destination : XAddress )( $ Л_amount : XInteger64 ) : RoundsBaseT ι_Round # XInteger64 := 
depoolFuncs.v: (( $ Л_exists , $ Л_sourceStake )) := $ Л_round ^^ RoundsBase_ι_Round_ι_stakes . fetch (( $ Л_source )) ) >> 
depoolFuncs.v: Ife ( ! $ Л_exists )) return (( $ Л_round , $ xInt0 )) ) >> 
depoolFuncs.v: Ife ( $ Л_sourceStake ^^ RoundsBase_ι_StakeValue_ι_simple ?>= $ Л_amount ) { ( d0! Л_newSourceStake := $ Л_sourceStake ^^ RoundsBase_ι_StakeValue_ι_simple - $ Л_amount ) >> 
depoolFuncs.v: 	 ( d0! Л_deltaDestinationStake := $ Л_amount ) >> 
depoolFuncs.v: ( d0! Л_newSourceStake := $ xInt0 ) >> 
depoolFuncs.v: 	 ( d0! Л_deltaDestinationStake := $ Л_sourceStake ^^ RoundsBase_ι_StakeValue_ι_simple ) >> 
depoolFuncs.v: Ife ( $ Л_newSourceStake ?== $ xInt0 && $ Л_round ^^ RoundsBase_ι_Round_ι_stakes [ $ Л_source ] ^^ RoundsBase_ι_StakeValue_ι_vesting ?== $ xInt0 ) { -- $ Л_round ^^ RoundsBase_ι_Round_ι_participantQty ) >> 
depoolFuncs.v: 	 delete $ Л_round ^^ RoundsBase_ι_Round_ι_stakes [ $ Л_source ] ) >> 
depoolFuncs.v: $ Л_round ^^ RoundsBase_ι_Round_ι_stakes [ $ Л_source ( d2! ] ^^ RoundsBase_ι_StakeValue_ι_simple := $ Л_newSourceStake ) >> 
depoolFuncs.v: Ift ( ! $ Л_round ^^ RoundsBase_ι_Round_ι_stakes . exists (( $ Л_destination )) )) $ Л_round ^^ RoundsBase_ι_Round_ι_participantQty ++ ) >> 
depoolFuncs.v: 	 $ Л_round ^^ RoundsBase_ι_Round_ι_stakes [ $ Л_destination ( d2! ] ^^ RoundsBase_ι_StakeValue_ι_simple += $ Л_deltaDestinationStake ) >> 
depoolFuncs.v: 	 return (( $ Л_round , $ Л_deltaDestinationStake )) ) >> 
depoolFuncs.v:Definition RoundsBase_Ф__addPendingRound ( $ Л_round : ι_Round ) : RoundsBaseT := 
depoolFuncs.v: RoundsBase_ι_m_pendingRounds [ $ Л_round ^^ RoundsBase_ι_Round_ι_id $ Л_round ) >> 
depoolFuncs.v:Definition RoundsBase_Ф__removePendingRound ( $ Л_pendingId : XInteger32 ) : RoundsBaseT XBool # ι_Round := 
depoolFuncs.v: (( exists , round )) := fetch (( $ Л_pendingId )) ) >> 
depoolFuncs.v: Ift ( exists ) { delete RoundsBase_ι_m_pendingRounds [ $ Л_pendingId ] ) >> 
depoolFuncs.v:Definition RoundsBase_Ф__roundFetchPendingRound ( $ Л_pendingId : XInteger32 ) : RoundsBaseT XBool # ι_Round := 
depoolFuncs.v: return fetch (( $ Л_pendingId )) ) >> 
depoolFuncs.v:Definition RoundsBase_Ф__setOrDeletePendingRound ( $ Л_round : ι_Round ) : RoundsBaseT := 
depoolFuncs.v: Ife ( $ Л_round ^^ RoundsBase_ι_Round_ι_step ?== RoundsBase_ι_STEP_COMPLETED ) { delete RoundsBase_ι_m_pendingRounds [ $ Л_round ^^ RoundsBase_ι_Round_ι_id ] ) >> 
depoolFuncs.v: RoundsBase_ι_m_pendingRounds [ $ Л_round ^^ RoundsBase_ι_Round_ι_id $ Л_round ) >> 
depoolFuncs.v:Definition RoundsBase_Ф__deletePendingRound ( $ Л_id : XInteger32 ) : RoundsBaseT := 
depoolFuncs.v: delete RoundsBase_ι_m_pendingRounds [ $ Л_id ] ) >> 
depoolFuncs.v:Definition RoundsBase_Ф_getTotalStake ( $ Л_stakes : ι_StakeValue ) : RoundsBaseT XInteger64 := 
depoolFuncs.v: return $ Л_stakes ^^ RoundsBase_ι_StakeValue_ι_simple + $ Л_stakes ^^ RoundsBase_ι_StakeValue_ι_vesting ) >> 
depoolFuncs.v:Definition StakingContract_Ф__calcLastRoundInterest ( $ Л_totalStake : XInteger64 )( $ Л_rewards : XInteger64 ) : StakingContractT XInteger64 := 
depoolFuncs.v: return (( $ Л_totalStake ?!= $ xInt0 )) ? uint64 (( (( $ Л_rewards * $ xInt100 * 1e9 )) / $ Л_totalStake ) : $ xInt0 ) >> 
depoolFuncs.v:Definition StakingContract_Ф__addRequest ( $ Л_stakeAt : XInteger32 )( $ Л_request : ι_Request ) : StakingContractT := 
depoolFuncs.v: require (( ! exists (( $ Л_stakeAt )) , $ xInt112 )) ) >> 
depoolFuncs.v: 	 ( d4! StakingContract_ι_m_requests [ Л_stakeAt ] := $ Л_request ) >> 
depoolFuncs.v:Definition StakingContract_Ф__getStakeAndFeeAndUpdateMinStakeIfNeeded ( $ Л_stake : XInteger64 )( $ Л_reward : XInteger64 )( $ Л_roundStake : XInteger64 )( $ Л_roundRewards : XInteger64 ) : StakingContractT XInteger64 # XInteger64 := 
depoolFuncs.v: Ife ( StakingContract_ι_NOTIFY_FEE ?< $ Л_stake + $ Л_reward ) { 
depoolFuncs.v: Ift ( $ Л_reward ?!= $ xInt0 && StakingContract_ι_NOTIFY_FEE ?> $ Л_reward ) { ( d1! StakingContract_ι_m_minStake := uint64 (( (( $ Л_roundStake * StakingContract_ι_NOTIFY_FEE )) / $ Л_roundRewards )) ) >> 
depoolFuncs.v: return (( $ Л_stake + $ Л_reward - StakingContract_ι_NOTIFY_FEE , StakingContract_ι_NOTIFY_FEE )) ) >> 
depoolFuncs.v: return (( $ xInt0 , $ Л_stake + $ Л_reward )) ) >> 
depoolFuncs.v:Definition StakingContract_Ф_Constructor7 ( $ Л_electorAddr : XAddress )( $ Л_poolOwnerAddr : XAddress )( $ Л_electionId : XInteger32 )( $ Л_nodeWallet : XAddress )( $ Л_beginBefore : XInteger32 )( $ Л_endBefore : XInteger32 )( $ Л_heldFor : XInteger32 )( $ Л_electedFor : XInteger32 )( $ Л_minStake : XInteger64 )( $ Л_minRoundStake : XInteger64 )( $ Л_maxRoundStake : XInteger64 ) : StakingContractT := 
depoolFuncs.v: ( d1! StakingContract_ι_m_minStake := $ Л_minStake ) >> 
depoolFuncs.v: 	 ( d1! StakingContract_ι_m_minRoundStake := $ Л_minRoundStake ) >> 
depoolFuncs.v: 	 ( d1! StakingContract_ι_m_maxRoundStake := $ Л_maxRoundStake ) >> 
depoolFuncs.v: 	 ( d1! StakingContract_ι_m_node := StakingContract_ι_Node (( $ Л_nodeWallet , $ xInt3 * $ xInt65536 , $ xInt0 )) ) >> 
depoolFuncs.v:Definition StakingContract_Ф_receiveConfirmation ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_comment : XInteger32 ) : StakingContractT := 
depoolFuncs.v: 	 require (( $ Л_comment ?== $ xInt0 , $ xInt110 )) ) >> 
depoolFuncs.v: 	 require (( $ Л_queryId ?>= $ xInt0 , $ xInt110 )) ) >> 
depoolFuncs.v:Definition DePool_Ф_Constructor8 ( $ Л_electorAddr : XAddress )( $ Л_poolOwnerAddr : XAddress )( $ Л_electionId : XInteger32 )( $ Л_nodeWallet : XAddress )( $ Л_beginBefore : XInteger32 )( $ Л_endBefore : XInteger32 )( $ Л_heldFor : XInteger32 )( $ Л_electedFor : XInteger32 )( $ Л_minStake : XInteger64 )( $ Л_minRoundStake : XInteger64 )( $ Л_maxRoundStake : XInteger64 ) : DePoolT True 
depoolFuncs.v:Definition StakingContract_Ф_receiveConfirmation ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_comment : XInteger32 ) : StakingContractT := 
depoolFuncs.v: 	 require (( $ Л_comment ?== $ xInt0 , $ xInt110 )) ) >> 
depoolFuncs.v: 	 require (( $ Л_queryId ?>= $ xInt0 , $ xInt110 )) ) >> 
depoolFuncs.v:Definition StakingContract_Ф_acceptRecoveredStake ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 ) : StakingContractT := 
depoolFuncs.v: Ife ( $ Л_queryId ?== $ xInt0 ) { StakingContract_Ф__acceptUnusedStake () ) >> 
depoolFuncs.v: Ife ( $ Л_queryId ?== $ xInt1 ) { StakingContract_Ф__acceptRewardStake () ) >> 
depoolFuncs.v: StakingContract_Ф__acceptPendingRoundStake (( uint32 (( $ Л_queryId )) )) ) >> 
depoolFuncs.v:Definition TestElector_Ф_Constructor9 ( $ Л_offset : XInteger32 ) : TestElectorT := 
depoolFuncs.v: ( d1! TestElector_ι_electAt := uint32 (( now )) + $ Л_offset ) >> 
depoolFuncs.v:Definition ElectorBase_Ф__recoverPendingRoundStakes ( $ Л_pendingId : XInteger32 ) : ElectorBaseT := 
depoolFuncs.v: IProxy (( ElectorBase_ι_m_elector )) . Participant_Ф_recover_stake ^^ value (( ElectorBase_ι_RECOVER_STAKE_MSG_VALUE )) (( $ Л_pendingId )) ) >> 
depoolFuncs.v:Definition ElectorBase_Ф__runForElection ( $ Л_req : ι_Request )( $ Л_nodeStake : XInteger64 ) : ElectorBaseT := 
depoolFuncs.v: IProxy (( ElectorBase_ι_m_elector )) . Participant_Ф_process_new_stake ^^ value (( $ Л_nodeStake + 1e9 + 2*1e7 )) (( $ Л_req ^^ ElectorBase_ι_Request_ι_queryId , $ Л_req ^^ ElectorBase_ι_Request_ι_validatorKey , $ Л_req ^^ ElectorBase_ι_Request_ι_stakeAt , $ Л_req ^^ ElectorBase_ι_Request_ι_maxFactor , $ Л_req ^^ ElectorBase_ι_Request_ι_adnlAddr , $ Л_req ^^ ElectorBase_ι_Request_ι_signature )) ) >> 
depoolFuncs.v:Definition ElectionParams_Ф__isRoundUnfrozen ( $ Л_electAt : XInteger32 ) : ElectionParamsT XBool := 
depoolFuncs.v: return now ?> (( $ Л_electAt + ElectionParams_Ф__getFreezingPeriod () )) ) >> 
depoolFuncs.v: ( d0! Л_nextElectAt := ElectionParams_Ф__getNextElectionId () ) >> 
depoolFuncs.v: Ift ( now ?>= $ Л_nextElectAt - ElectionParams_ι_m_beginBefore ) { ( d0! Л_nextElectAt += ElectionParams_ι_m_electedFor ) >> 
depoolFuncs.v: ( d1! ElectionParams_ι_m_electAt := $ Л_nextElectAt ) >> 
depoolFuncs.v: 	 return $ Л_nextElectAt ) >> 
depoolFuncs.v:Definition StakingOwner_Ф__settimer ( $ Л_timer : XAddress )( $ Л_period : XInteger ) : StakingOwnerT := 
depoolFuncs.v: ITimer (( $ Л_timer )) . StakeholderBase_Ф_setTimer ^^ value (( StakingOwner_ι_TIMER_FEE )) (( $ Л_period )) ) >> 
depoolFuncs.v: ( d0! Л_timer := StakingOwner_ι_m_timer ) >> 
depoolFuncs.v: 	 ( d0! Л_period := StakingOwner_ι_m_timeout ) >> 
depoolFuncs.v: Ift ( $ msg_sender ?== $ Л_timer && $ Л_period ?> $ xInt0 ) { IStaking (( StakingOwner_ι_m_stakingPool )) . Participant_Ф_ticktock ^^ value (( StakingOwner_ι_TICKTOCK_FEE )) () ) >> 
depoolFuncs.v: 	 StakingOwner_Ф__settimer (( $ Л_timer , $ Л_period )) ) >> 
depoolFuncs.v:Definition StakingProxyContract_Ф_process_new_stake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_validatorKey : XInteger256 )( $ Л_stakeAt : XInteger32 )( $ Л_maxFactor : XInteger32 )( $ Л_adnlAddr : XInteger256 )( $ Л_signature : XInteger8 ) : StakingProxyContractT := 
depoolFuncs.v: 	 IElector (( ElectorBase_ι_m_elector )) . _Ф_elector_process_new_stake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId , $ Л_validatorKey , $ Л_stakeAt , $ Л_maxFactor , $ Л_adnlAddr , $ Л_signature )) ) >> 
depoolFuncs.v:Definition StakingProxyContract_Ф_recover_stake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 ) : StakingProxyContractT := 
depoolFuncs.v: 	 IElector (( ElectorBase_ι_m_elector )) . _Ф_elector_recover_stake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId )) ) >> 
depoolFuncs.v:Definition StakingProxyContract_Ф_receive_confirmation ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_comment : XInteger32 ) : StakingProxyContractT := 
depoolFuncs.v: 	 IStaking (( StakingProxyContract_ι_m_staking )) . Participant_Ф_receiveConfirmation ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId , $ Л_comment )) ) >> 
depoolFuncs.v:Definition StakingProxyContract_Ф_receive_returned_stake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_comment : XInteger32 ) : StakingProxyContractT := 
depoolFuncs.v: 	 IStaking (( StakingProxyContract_ι_m_staking )) . Participant_Ф_receiveReturnedStake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId , $ Л_comment )) ) >> 
depoolFuncs.v:Definition StakingProxyContract_Ф_accept_recovered_stake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 ) : StakingProxyContractT := 
depoolFuncs.v: 	 IStaking (( StakingProxyContract_ι_m_staking )) . Participant_Ф_acceptRecoveredStake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId )) ) >> 
depoolFuncs.v: (( $ Л_exists , $ Л_round )) := fetch (( RoundsBase_Ф__getLastRoundIdx () )) ) >> 
depoolFuncs.v: 	 require (( $ Л_exists , $ xInt200 )) ) >> 
depoolFuncs.v: 	 return $ Л_round ) >> 
depoolFuncs.v:Definition RoundsBase_Ф__setLastRound ( $ Л_round : ι_Round ) : RoundsBaseT := 
depoolFuncs.v: RoundsBase_ι_m_rounds [ RoundsBase_Ф__getLastRoundIdx () $ Л_round ) >> 
depoolFuncs.v:Definition RoundsBase_Ф__setPenultimateRound ( $ Л_round : ι_Round ) : RoundsBaseT := 
depoolFuncs.v: RoundsBase_ι_m_rounds [ RoundsBase_Ф__getLastRoundIdx () - $ xInt1 $ Л_round ) >> 
depoolFuncs.v: Ift ( RoundsBase_Ф__getRoundsCount () ?> $ xInt4 ) { ( d0! Л_removingRound := RoundsBase_Ф__removeOldestRound () ) >> 
depoolFuncs.v: 	 delete StakingContract_ι_m_requests [ $ Л_removingRound ^^ RoundsBase_ι_Round_ι_id ] ) >> 
depoolFuncs.v: Ift ( $ Л_removingRound ^^ RoundsBase_ι_Round_ι_step ?== RoundsBase_ι_STEP_WAITING_ELECTION_RESULTS ) { RoundsBase_Ф__addPendingRound (( $ Л_removingRound )) ) >> 
depoolFuncs.v: 	 ElectorBase_Ф__recoverPendingRoundStakes (( $ Л_removingRound ^^ RoundsBase_ι_Round_ι_id )) ) >> 
depoolFuncs.v: ( d0! Л_lb1Round := RoundsBase_Ф__getPenultimateRound () ) >> 
depoolFuncs.v: Ift ( now ?> $ Л_lb1Round ^^ RoundsBase_ι_Round_ι_id ) { 
depoolFuncs.v: Ift ( $ Л_lb1Round ^^ RoundsBase_ι_Round_ι_step ?< RoundsBase_ι_STEP_ELECTIONS ) { RoundsBase_Ф__setPenultimateRound (( StakingContract_Ф__completeRoundAndSetCompletionStatus (( $ Л_lb1Round , RoundsBase_ι_ROUND_MISSED_ELECTIONS )) )) ) >> 
depoolFuncs.v: Ift ( $ Л_lb1Round ^^ RoundsBase_ι_Round_ι_step ?< RoundsBase_ι_STEP_WAITING_ELECTION_RESULTS ) { ElectorBase_Ф__recoverStakes () ) >> 
depoolFuncs.v: 	 ( d2! Л_lb1Round ^^ RoundsBase_ι_Round_ι_step := RoundsBase_ι_STEP_WAITING_ELECTION_RESULTS ) >> 
depoolFuncs.v: 	 RoundsBase_Ф__setPenultimateRound (( $ Л_lb1Round )) ) >> 
depoolFuncs.v: ( d0! Л_oldestRound := RoundsBase_Ф__getOldestRound () ) >> 
depoolFuncs.v: Ift ( ElectionParams_Ф__isRoundUnfrozen (( $ Л_oldestRound ^^ RoundsBase_ι_Round_ι_id )) ) { 
depoolFuncs.v: Ift ( $ Л_oldestRound ^^ RoundsBase_ι_Round_ι_step ?== RoundsBase_ι_STEP_WAITING_ELECTION_RESULTS ) { ElectorBase_Ф__recoverStakeRewards () ) >> 
depoolFuncs.v: 	 ( d2! Л_oldestRound ^^ RoundsBase_ι_Round_ι_step := RoundsBase_ι_STEP_WAITING_UNFREEZE ) >> 
depoolFuncs.v: 	 RoundsBase_Ф__setOldestRound (( $ Л_oldestRound )) ) >> 
depoolFuncs.v:Definition StakingContract_Ф__returnAnswer ( msg_sender : XInteger ) ( $ Л_errcode : XInteger32 )( $ Л_amount : XInteger64 )( $ Л_comment : XInteger64 ) : StakingContractT := 
depoolFuncs.v: value : $ Л_amount , flag : (( $ Л_amount ?== $ xInt0 ? $ xInt64 : $ xInt3 )) 
depoolFuncs.v: (( $ Л_errcode , $ Л_comment )) ) >> 
depoolFuncs.v:Definition StakingContract_Ф__returnError ( $ Л_errcode : XInteger32 )( $ Л_comment : XInteger64 ) : StakingContractT := 
depoolFuncs.v: StakingContract_Ф__returnAnswer (( $ Л_errcode , $ xInt0 , $ Л_comment )) ) >> 
depoolFuncs.v:Definition StakingContract_Ф__returnConfirmation ( $ Л_fee : XInteger64 ) : StakingContractT := 
depoolFuncs.v: StakingContract_Ф__returnAnswer (( StakingContract_ι_STATUS_SUCCESS , StakingContract_ι_ANSWER_MSG_FEE , $ Л_fee )) ) >> 
depoolFuncs.v:Definition StakingContract_Ф__investStake ( $ Л_addr : XAddress )( $ Л_unusedStake : XInteger64 )( $ Л_newStake : XInteger64 )( $ Л_reinvest : XBool ) : StakingContractT XBool := 
depoolFuncs.v: ( d0! Л_stakeholder := StakeholderBase_Ф__getStakeholder (( $ Л_addr )) ) >> 
depoolFuncs.v: 	 ( d0! Л_unusedStake := tvm_min (( $ Л_unusedStake , $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake )) ) >> 
depoolFuncs.v: 	 ( d0! Л_investStake := $ Л_unusedStake + $ Л_newStake ) >> 
depoolFuncs.v: 	 ( d0! Л_round := RoundsBase_Ф__getLastRound () ) >> 
depoolFuncs.v: Ift ( $ Л_round ^^ RoundsBase_ι_Round_ι_stake + $ Л_investStake ?> StakingContract_ι_m_maxRoundStake ) { return $ xBoolFalse ) >> 
depoolFuncs.v: RoundsBase_Ф__setLastRound (( RoundsBase_Ф__roundAddStakeAndVesting (( $ Л_round , $ Л_addr , $ Л_investStake , $ xInt0 )) )) ) >> 
depoolFuncs.v: 	 $ Л_stakeholder $ Л_=_stakeholderDecreaseUnusedStake (( $ Л_stakeholder , $ Л_unusedStake )) ) >> 
depoolFuncs.v: Ife ( $ Л_newStake ?> $ xInt0 ) { ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderUpdateStake2 (( $ Л_stakeholder , $ Л_newStake , $ Л_reinvest )) ) >> 
depoolFuncs.v: ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderSetReinvest2 (( $ Л_stakeholder , $ Л_reinvest )) ) >> 
depoolFuncs.v: StakeholderBase_Ф__setOrDeleteStakeholder (( $ Л_addr , $ Л_stakeholder )) ) >> 
depoolFuncs.v:Definition StakingContract_Ф__requestStakesSigning ( $ Л_round : ι_Round ) : StakingContractT ι_Round := 
depoolFuncs.v: ( d0! Л_roundStake := $ Л_round ^^ RoundsBase_ι_Round_ι_stake ) >> 
depoolFuncs.v: 	 ( d0! Л_currentElectAt := $ Л_round ^^ RoundsBase_ι_Round_ι_id ) >> 
depoolFuncs.v: 	 ( d0! Л_roundStakeCheck := $ Л_roundStake ?>= StakingContract_ι_m_minRoundStake ) >> 
depoolFuncs.v: 	 ( d0! Л_nodeStakeCheck := RoundsBase_Ф_getTotalStake (( $ Л_round ^^ RoundsBase_ι_Round_ι_stakes [ StakingContract_ι_Node_ι_wallet ] )) ?>= (( StakingContract_ι_m_minRoundStake * StakingContract_ι_NODE_WALLET_MIN_STAKE )) / $ xInt100 ) >> 
depoolFuncs.v: 	 ( d0! Л_canParticipate := ! ElectionParams_Ф__isElectionOver (( $ Л_currentElectAt )) && $ Л_roundStakeCheck && $ Л_nodeStakeCheck ) >> 
depoolFuncs.v: Ife ( $ Л_canParticipate ) { ( d1! RoundsBase_ι_Round_ι_stake := $ Л_roundStake ) >> 
depoolFuncs.v: 	 emit $ Л_stakeSigningRequested (( $ Л_currentElectAt )) ) >> 
depoolFuncs.v: 	 (( $ Л_exists , $ Л_request )) := fetch (( $ Л_currentElectAt )) ) >> 
depoolFuncs.v: Ife ( $ Л_exists ) { ( d2! Л_round ^^ RoundsBase_ι_Round_ι_step := RoundsBase_ι_STEP_ELECTIONS ) >> 
depoolFuncs.v: 	 ElectorBase_Ф__runForElection (( $ Л_request , $ Л_roundStake )) ) >> 
depoolFuncs.v: ( d2! Л_round ^^ RoundsBase_ι_Round_ι_step := RoundsBase_ι_STEP_WAITING_REQUESTS ) >> 
depoolFuncs.v: ( d0! Л_completionStatus := ! $ Л_roundStakeCheck ? RoundsBase_ι_ROUND_NOT_ENOUGH_TOTAL_STAKE : RoundsBase_ι_ROUND_NODE_STAKE_TOO_SMALL ) >> 
depoolFuncs.v: 	 ( d0! Л_round := StakingContract_Ф__completeRoundAndSetCompletionStatus (( $ Л_round , $ Л_completionStatus )) ) >> 
depoolFuncs.v: return $ Л_round ) >> 
depoolFuncs.v:Definition StakingContract_Ф__acceptPendingRoundStake ( $ Л_pendingId : XInteger32 ) : StakingContractT := 
depoolFuncs.v: (( $ Л_exists , $ Л_round )) := RoundsBase_Ф__removePendingRound (( $ Л_pendingId )) ) >> 
depoolFuncs.v: Ift ( $ Л_exists ) { StakingContract_Ф__completeRoundAndSetCompletionStatus (( $ Л_round , RoundsBase_ι_ROUND_RECEIVED_REWARD )) ) >> 
depoolFuncs.v: ( d0! Л_lb1round := RoundsBase_Ф__getPenultimateRound () ) >> 
depoolFuncs.v: Ife ( $ msg_value ?>= $ Л_lb1round ^^ RoundsBase_ι_Round_ι_stake ) { RoundsBase_Ф__setPenultimateRound (( StakingContract_Ф__completeRoundAndSetCompletionStatus (( $ Л_lb1round , RoundsBase_ι_ROUND_LOST_ELECTIONS )) )) ) >> 
depoolFuncs.v: ( d2! Л_lb1round ^^ RoundsBase_ι_Round_ι_unused := uint64 (( $ msg_value )) ) >> 
depoolFuncs.v: 	 ( d1! StakingContract_ι_m_minRoundStake := $ Л_lb1round ^^ RoundsBase_ι_Round_ι_stake - $ Л_lb1round ^^ RoundsBase_ι_Round_ι_unused + StakingContract_ι_ROUND_UP_VALUE ) >> 
depoolFuncs.v: ( d0! Л_oldestRound := RoundsBase_Ф__getOldestRound () ) >> 
depoolFuncs.v: 	 ( d0! Л_roundStake := $ Л_oldestRound ^^ RoundsBase_ι_Round_ι_stake - $ Л_oldestRound ^^ RoundsBase_ι_Round_ι_unused ) >> 
depoolFuncs.v: 	 ( d0! Л_totalReward := $ xInt0 ) >> 
depoolFuncs.v: Ift ( uint64 (( $ msg_value )) ?>= $ Л_roundStake ) { ( d0! Л_totalReward := uint64 (( $ msg_value )) - $ Л_roundStake ) >> 
depoolFuncs.v: ( d0! Л_roundReward := uint64 (( (( $ Л_totalReward * StakingContract_ι_NOM_FRACTION )) / $ xInt100 )) ) >> 
depoolFuncs.v: 	 ( d0! Л_ownerReward := uint64 (( (( $ Л_totalReward * StakingContract_ι_NODE_FRACTION )) / $ xInt100 )) ) >> 
depoolFuncs.v: 	 OwnerBase_Ф__increaseOwnerReward (( $ Л_ownerReward )) ) >> 
depoolFuncs.v: 	 ( d2! Л_oldestRound ^^ RoundsBase_ι_Round_ι_rewards := $ Л_roundReward ) >> 
depoolFuncs.v: 	 ( d1! StakingContract_ι_m_lastRoundInterest := StakingContract_Ф__calcLastRoundInterest (( $ Л_roundStake , $ Л_roundReward )) ) >> 
depoolFuncs.v: 	 RoundsBase_Ф__setOldestRound (( StakingContract_Ф__completeRoundAndSetCompletionStatus (( $ Л_oldestRound , RoundsBase_ι_ROUND_RECEIVED_REWARD )) )) ) >> 
depoolFuncs.v:Definition StakingContract_Ф__completeRound ( $ Л_completedRound : ι_Round )( $ Л_chunkSize : XInteger8 ) : StakingContractT ι_Round := 
depoolFuncs.v: ( d2! Л_completedRound ^^ RoundsBase_ι_Round_ι_step := RoundsBase_ι_STEP_COMPLETING ) >> 
depoolFuncs.v: 	 ( d2! Л_completedRound ^^ RoundsBase_ι_Round_ι_end := uint32 (( now )) ) >> 
depoolFuncs.v: 	 RoundsBase_Ф__setOrDeletePendingRound (( $ Л_completedRound )) ) >> 
depoolFuncs.v: 	 ( d0! Л_completedRound := StakingContract_Ф__completePendingRound (( $ Л_completedRound , $ Л_chunkSize )) ) >> 
depoolFuncs.v: 	 RoundsBase_Ф__setOrDeletePendingRound (( $ Л_completedRound )) ) >> 
depoolFuncs.v: 	 delete $ Л_completedRound ^^ RoundsBase_ι_Round_ι_stakes ) >> 
depoolFuncs.v: 	 return $ Л_completedRound ) >> 
depoolFuncs.v:Definition StakingContract_Ф__completeRoundAndSetCompletionStatus ( $ Л_round : ι_Round )( $ Л_completionStatus : XInteger8 ) : StakingContractT ι_Round := 
depoolFuncs.v: ( d2! Л_round ^^ RoundsBase_ι_Round_ι_completionStatus := $ Л_completionStatus ) >> 
depoolFuncs.v: 	 return StakingContract_Ф__completeRound (( $ Л_round , StakingContract_ι_MAX_MSGS_PER_TR )) ) >> 
depoolFuncs.v:Definition StakingContract_Ф_getNewStakeAndFees ( $ Л_roundRewards : XInteger64 )( $ Л_roundStake : XInteger64 )( $ Л_stake : XInteger64 ) : StakingContractT XInteger64 # XInteger64 # XInteger64 := 
depoolFuncs.v: Ift ( $ Л_stake ?== $ xInt0 ) { return (( $ xInt0 , $ xInt0 , $ xInt0 )) ) >> 
depoolFuncs.v: ( d0! Л_reward := (( $ Л_roundStake ?!= $ xInt0 )) ? uint64 (( $ Л_roundRewards * $ Л_stake / $ Л_roundStake ) : $ xInt0 ) >> 
depoolFuncs.v: 	 (( $ Л_stakeAndReward , $ Л_fee )) := StakingContract_Ф__getStakeAndFeeAndUpdateMinStakeIfNeeded (( $ Л_stake , $ Л_reward , $ Л_roundStake , $ Л_roundRewards )) ) >> 
depoolFuncs.v: 	 return (( $ Л_reward , $ Л_stakeAndReward , $ Л_fee )) ) >> 
depoolFuncs.v:Definition StakingContract_Ф__returnOrReinvestForStakeholder ( $ Л_completedRound : ι_Round )( $ Л_lastRound : ι_Round )( $ Л_addr : XAddress )( $ Л_stake : ι_StakeValue ) : StakingContractT ι_Round := 
depoolFuncs.v: ( d0! Л_roundRewards := $ Л_completedRound ^^ RoundsBase_ι_Round_ι_rewards ) >> 
depoolFuncs.v: 	 ( d0! Л_roundStake := $ Л_completedRound ^^ RoundsBase_ι_Round_ι_stake ) >> 
depoolFuncs.v: 	 ( d0! Л_stakeholder := StakeholderBase_Ф__getStakeholder (( $ Л_addr )) ) >> 
depoolFuncs.v: 	 ( d0! Л_reinvest := $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_reinvest ) >> 
depoolFuncs.v: 	 (( $ Л_stakeReward , $ Л_newStake , $ Л_stakeFee )) := StakingContract_Ф_getNewStakeAndFees (( $ Л_roundRewards , $ Л_roundStake , $ Л_stake ^^ RoundsBase_ι_StakeValue_ι_simple )) ) >> 
depoolFuncs.v: 	 (( $ Л_vestingReward , $ Л_vestingAndReward , $ Л_vestingFee )) := StakingContract_Ф_getNewStakeAndFees (( $ Л_roundRewards , $ Л_roundStake , $ Л_stake ^^ RoundsBase_ι_StakeValue_ι_vesting )) ) >> 
depoolFuncs.v: 	 ( d0! Л_pureVestingReward := $ Л_vestingAndReward ?>= $ Л_stake ^^ vesting? $ Л_vestingAndReward - $ Л_stake ^^ RoundsBase_ι_StakeValue_ι_vesting : $ xInt0 ) >> 
depoolFuncs.v: 	 ( d0! Л_newVesting := tvm_min (( $ Л_vestingAndReward - $ Л_pureVestingReward , $ Л_stake ^^ RoundsBase_ι_StakeValue_ι_vesting )) ) >> 
depoolFuncs.v: 	 ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderUpdateGrossReward (( $ Л_stakeholder , $ Л_stakeReward + $ Л_vestingReward )) ) >> 
depoolFuncs.v: 	 ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderUpdateTotalStake (( $ Л_stakeholder , $ Л_newStake + $ Л_vestingAndReward , $ Л_stake ^^ RoundsBase_ι_StakeValue_ι_simple + $ Л_stake ^^ RoundsBase_ι_StakeValue_ι_vesting )) ) >> 
depoolFuncs.v: 	 ( d0! Л_withdrawalVesting := $ xInt0 ) >> 
depoolFuncs.v: Ift ( $ Л_stake ^^ RoundsBase_ι_StakeValue_ι_vesting ?!= $ xInt0 ) { ( d0! Л_periodQty := (( uint64 (( now )) - $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_lastPaymentUnixTime )) / $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_withdrawalPeriod ) >> 
depoolFuncs.v: 	 ( d0! Л_withdrawalVesting := tvm_min (( $ Л_periodQty * $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_periodPayment , $ Л_newVesting )) ) >> 
depoolFuncs.v: 	 ( d0! Л_newVesting -= $ Л_withdrawalVesting ) >> 
depoolFuncs.v: 	 ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderUpdateLastPaymentTime (( $ Л_stakeholder , $ Л_periodQty )) ) >> 
depoolFuncs.v: Ift ( $ Л_newVesting ?< StakingContract_ι_m_minStake ) { ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderIncreaseUnusedStake (( $ Л_stakeholder , $ Л_newVesting )) ) >> 
depoolFuncs.v: 	 ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderResetVesting (( $ Л_stakeholder )) ) >> 
depoolFuncs.v: 	 ( d0! Л_newVesting := $ xInt0 ) >> 
depoolFuncs.v: ( d0! Л_newStake += $ Л_withdrawalVesting + $ Л_pureVestingReward ) >> 
depoolFuncs.v: Ife ( StakingContract_ι_m_poolClosed ) { ( d0! Л_attachedValue := $ Л_newStake + $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake ) >> 
depoolFuncs.v: 	 ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderDecreaseTotalAndUnused (( $ Л_stakeholder , $ Л_newStake + $ Л_newVesting + $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake , $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake )) ) >> 
depoolFuncs.v: Ift ( $ Л_newVesting ?!= $ xInt0 && $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_vestingOwner ?!= xInt0 ) { $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_vestingOwner . transfer (( 
depoolFuncs.v: value : $ Л_newVesting , flag : $ xInt3 
depoolFuncs.v: ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderResetVesting (( $ Л_stakeholder )) ) >> 
depoolFuncs.v: ( d0! Л_attachedValue := $ xInt1 ) >> 
depoolFuncs.v: Ife ( $ Л_reinvest ) { ( d0! Л_lastRound := RoundsBase_Ф__roundAddStakeAndVesting (( $ Л_lastRound , $ Л_addr , $ Л_newStake , $ Л_newVesting )) ) >> 
depoolFuncs.v: ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderIncreaseUnusedStake (( $ Л_stakeholder , $ Л_newStake )) ) >> 
depoolFuncs.v: 	 ( d0! Л_lastRound := RoundsBase_Ф__roundAddStakeAndVesting (( $ Л_lastRound , $ Л_addr , $ xInt0 , $ Л_newVesting )) ) >> 
depoolFuncs.v: StakeholderBase_Ф__setOrDeleteStakeholder (( $ Л_addr , $ Л_stakeholder )) ) >> 
depoolFuncs.v: 	 IParticipant (( $ Л_addr )) . _Ф_receiveRewardStake 
depoolFuncs.v: value : $ Л_attachedValue , flag : $ xInt3 
depoolFuncs.v: (( $ Л_completedRound ^^ RoundsBase_ι_Round_ι_id , $ Л_stakeReward + $ Л_vestingReward , $ Л_newStake + $ Л_newVesting , $ Л_reinvest , $ Л_stakeFee + $ Л_vestingFee , $ Л_completedRound ^^ RoundsBase_ι_Round_ι_completionStatus )) ) >> 
depoolFuncs.v: 	 return $ Л_lastRound ) >> 
depoolFuncs.v:Definition StakingContract_Ф__returnOrReinvest ( $ Л_completedRound : ι_Round )( $ Л_chunkSize : XInteger8 ) : StakingContractT ι_Round := 
depoolFuncs.v: ( d1! RoundsBase_ι_Round_ι_stakes := $ Л_completedRound ^^ RoundsBase_ι_Round_ι_stakes ) >> 
depoolFuncs.v: 	 ( d0! Л_lastRound := RoundsBase_Ф__getLastRound () ) >> 
depoolFuncs.v: 	 ( d0! Л_sentMsgs := $ xInt0 ) >> 
depoolFuncs.v: 	 while (( ! empty () && $ Л_sentMsgs ?< $ Л_chunkSize ) { $ Л_sentMsgs ++ ) >> 
depoolFuncs.v: 	 (( $ Л_addr , $ Л_stake )) := delMin () ) >> 
depoolFuncs.v: 	 ( d0! Л_lastRound := StakingContract_Ф__returnOrReinvestForStakeholder (( $ Л_completedRound , $ Л_lastRound , $ Л_addr , $ Л_stake )) ) >> 
depoolFuncs.v: Ift ( $ Л_completedRound ^^ RoundsBase_ι_Round_ι_id ?!= $ Л_lastRound ^^ RoundsBase_ι_Round_ι_id ) { RoundsBase_Ф__setLastRound (( $ Л_lastRound )) ) >> 
depoolFuncs.v: ( d2! Л_completedRound ^^ RoundsBase_ι_Round_ι_step := empty () ? RoundsBase_ι_STEP_COMPLETED : RoundsBase_ι_STEP_COMPLETING ) >> 
depoolFuncs.v: 	 ( d2! Л_completedRound ^^ RoundsBase_ι_Round_ι_stakes := RoundsBase_ι_Round_ι_stakes ) >> 
depoolFuncs.v: 	 return $ Л_completedRound ) >> 
depoolFuncs.v: 	 ( d0! Л_msgValue := uint64 (( $ msg_value )) ) >> 
depoolFuncs.v: 	 ( d0! Л_minRequiredValue := StakingContract_ι_m_minStake + StakingContract_ι_ADD_STAKE_FEE ) >> 
depoolFuncs.v: Ift ( $ Л_msgValue ?< $ Л_minRequiredValue ) { StakingContract_Ф__returnError (( StakingContract_ι_STATUS_STAKE_TOO_SMALL , $ Л_minRequiredValue )) ) >> 
depoolFuncs.v: return (( $ Л_msgValue - StakingContract_ι_ADD_STAKE_FEE , $ xBoolTrue )) ) >> 
depoolFuncs.v:Definition StakingContract_Ф_addStake ( msg_sender : XInteger ) ( $ Л_reinvest : XBool ) : StakingContractT := 
depoolFuncs.v: 	 (( $ Л_stake , $ Л_ok )) := StakingContract_Ф__getStakeAndSendErrorIfNeeded () ) >> 
depoolFuncs.v: Ift ( ! $ Л_ok ) { return ) >> 
depoolFuncs.v: Ift ( ! StakingContract_Ф__investStake (( $ msg_sender , reinvest? $ Л_MAX_MONEY_VALUE : $ xInt0 , $ Л_stake , $ Л_reinvest )) ) { ( d0! Л_round := RoundsBase_Ф__getLastRound () ) >> 
depoolFuncs.v: 	 return StakingContract_Ф__returnError (( StakingContract_ι_STATUS_ROUND_STAKE_LIMIT , StakingContract_ι_m_maxRoundStake - $ Л_round ^^ RoundsBase_ι_Round_ι_stake )) ) >> 
depoolFuncs.v:Definition StakingContract_Ф_addVesting ( msg_sender : XInteger ) ( $ Л_dest : XAddress )( $ Л_withdrawalPeriod : XInteger32 )( $ Л_totalPeriod : XInteger32 ) : StakingContractT := 
depoolFuncs.v: require (( $ Л_dest ^^ isStdAddrWithoutAnyCast () , $ xInt119 )) ) >> 
depoolFuncs.v: Ift ( $ Л_dest ?== xInt0 ) { ( d0! Л_dest := $ msg_sender ) >> 
depoolFuncs.v: (( $ Л_stake , $ Л_ok )) := StakingContract_Ф__getStakeAndSendErrorIfNeeded () ) >> 
depoolFuncs.v: Ift ( ! $ Л_ok ) { return ) >> 
depoolFuncs.v: ( d0! Л_round := RoundsBase_Ф__getLastRound () ) >> 
depoolFuncs.v: Ift ( $ Л_round ^^ RoundsBase_ι_Round_ι_stake + $ Л_stake ?> StakingContract_ι_m_maxRoundStake ) { return StakingContract_Ф__returnError (( StakingContract_ι_STATUS_ROUND_STAKE_LIMIT , StakingContract_ι_m_maxRoundStake - $ Л_round ^^ RoundsBase_ι_Round_ι_stake )) ) >> 
depoolFuncs.v: Ift ( $ Л_withdrawalPeriod ?> $ Л_totalPeriod ) { return StakingContract_Ф__returnError (( StakingContract_ι_STATUS_WITHDRAWAL_PERIOD_GREATER_TOTAL_PERIOD , $ xInt0 )) ) >> 
depoolFuncs.v: Ift ( $ Л_totalPeriod ?>= $ xInt100 * (( $ Л_days )) ) { return StakingContract_Ф__returnError (( StakingContract_ι_STATUS_TOTAL_PERIOD_MORE_100YEARS , $ xInt0 )) ) >> 
depoolFuncs.v: Ift ( $ Л_withdrawalPeriod ?== $ xInt0 ) { return StakingContract_Ф__returnError (( StakingContract_ι_STATUS_WITHDRAWAL_PERIOD_IS_ZERO , $ xInt0 )) ) >> 
depoolFuncs.v: Ift ( $ Л_totalPeriod $ Л_% $ Л_withdrawalPeriod ?!= $ xInt0 ) { return StakingContract_Ф__returnError (( StakingContract_ι_STATUS_TOTAL_PERIOD_IS_NOT_DIVED_BY_WITHDRAWAL_PERIOD , $ xInt0 )) ) >> 
depoolFuncs.v: ( d0! Л_stakeholder := StakeholderBase_Ф__getStakeholder (( $ Л_dest )) ) >> 
depoolFuncs.v: Ift ( StakeholderBase_Ф__haveVesting (( $ Л_stakeholder )) ) { return StakingContract_Ф__returnError (( StakingContract_ι_STATUS_STAKEHOLDER_HAVE_ALREADY_VESTING , $ xInt0 )) ) >> 
depoolFuncs.v: ( d0! Л_periodPayment := uint64 (( uint (( $ Л_stake )) * $ Л_withdrawalPeriod / $ Л_totalPeriod )) ) >> 
depoolFuncs.v: Ift ( $ Л_periodPayment ?== $ xInt0 ) { return StakingContract_Ф__returnError (( StakingContract_ι_STATUS_PERIOD_PAYMENT_IS_ZERO , $ xInt0 )) ) >> 
depoolFuncs.v: ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderSetVesting (( $ Л_stakeholder , $ Л_stake , $ Л_withdrawalPeriod , $ Л_periodPayment , $ msg_sender )) ) >> 
depoolFuncs.v: 	 StakeholderBase_Ф__setOrDeleteStakeholder (( $ Л_dest , $ Л_stakeholder )) ) >> 
depoolFuncs.v: 	 RoundsBase_Ф__setLastRound (( RoundsBase_Ф__roundAddStakeAndVesting (( $ Л_round , $ Л_dest , $ xInt0 , $ Л_stake )) )) ) >> 
depoolFuncs.v:Definition StakingContract_Ф_removeStake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_stake : XInteger64 ) : StakingContractT := 
depoolFuncs.v: ( d0! Л_member := StakeholderBase_Ф__getStakeholder (( $ msg_sender )) ) >> 
depoolFuncs.v: 	 ( d0! Л_removedStake := tvm_min (( $ Л_stake , $ Л_member ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake )) ) >> 
depoolFuncs.v: 	 StakeholderBase_Ф__stakeholderRemoveStake (( $ msg_sender , $ Л_removedStake , $ Л_removedStake )) ) >> 
depoolFuncs.v: 	 $ msg_sender ^^ transfer (( $ Л_removedStake , $ xBoolTrue , $ xInt3 )) ) >> 
depoolFuncs.v:Definition StakingContract_Ф_continueStake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_amount : XInteger64 )( $ Л_reinvest : XBool ) : StakingContractT := 
depoolFuncs.v: Ift ( ! StakingContract_Ф__investStake (( $ msg_sender , $ Л_amount ?== 0? $ Л_MAX_MONEY_VALUE : $ Л_amount , $ xInt0 , $ Л_reinvest )) ) { ( d0! Л_round := RoundsBase_Ф__getLastRound () ) >> 
depoolFuncs.v: 	 return StakingContract_Ф__returnError (( StakingContract_ι_STATUS_ROUND_STAKE_LIMIT , StakingContract_ι_m_maxRoundStake - $ Л_round ^^ RoundsBase_ι_Round_ι_stake )) ) >> 
depoolFuncs.v:Definition StakingContract_Ф_setReinvest ( msg_sender : XInteger ) ( $ Л_flag : XBool ) : StakingContractT := 
depoolFuncs.v: 	 ( d0! Л_sender := $ msg_sender ) >> 
depoolFuncs.v: 	 require (( StakeholderBase_Ф__stakeholderExists (( $ Л_sender )) , $ xInt101 )) ) >> 
depoolFuncs.v: 	 StakeholderBase_Ф__stakeholderSetReinvest (( $ Л_sender , $ Л_flag )) ) >> 
depoolFuncs.v:Definition StakingContract_Ф_transferStake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_destination : XAddress )( $ Л_amount : XInteger64 ) : StakingContractT := 
depoolFuncs.v: 	 ( d0! Л_sender := $ msg_sender ) >> 
depoolFuncs.v: 	 (( $ Л_exists , $ Л_donor )) := StakeholderBase_Ф__stakeholderFetch (( $ Л_sender )) ) >> 
depoolFuncs.v: 	 require (( $ Л_exists , $ xInt101 )) ) >> 
depoolFuncs.v: 	 require (( $ Л_destination ^^ isStdAddrWithoutAnyCast () && ! $ Л_destination ^^ isStdZero () , $ xInt119 )) ) >> 
depoolFuncs.v: Ift ( $ Л_amount ?== $ xInt0 ) { ( d0! Л_amount := StakingContract_ι_MAX_MONEY_VALUE ) >> 
depoolFuncs.v: ( d0! Л_receiver := StakeholderBase_Ф__getStakeholder (( $ Л_destination )) ) >> 
depoolFuncs.v: 	 ( d0! Л_transferredStake := RoundsBase_Ф__roundMoveStakes (( $ Л_sender , $ Л_destination , $ Л_amount )) ) >> 
depoolFuncs.v: 	 ( d0! Л_transferredUnused := tvm_min (( $ Л_amount - $ Л_transferredStake , $ Л_donor ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake )) ) >> 
depoolFuncs.v: 	 ( d0! Л_transferred := $ Л_transferredStake + $ Л_transferredUnused ) >> 
depoolFuncs.v: 	 ( d0! Л_donor := StakeholderBase_Ф__stakeholderDecreaseTotalAndUnused (( $ Л_donor , $ Л_transferred , $ Л_transferredUnused )) ) >> 
depoolFuncs.v: 	 ( d0! Л_receiver := StakeholderBase_Ф__stakeholderIncreaseTotalAndUnused (( $ Л_receiver , $ Л_transferred , $ Л_transferredUnused )) ) >> 
depoolFuncs.v: 	 StakeholderBase_Ф__setOrDeleteStakeholder (( $ Л_sender , $ Л_donor )) ) >> 
depoolFuncs.v: 	 StakeholderBase_Ф__setOrDeleteStakeholder (( $ Л_destination , $ Л_receiver )) ) >> 
depoolFuncs.v:Definition StakingContract_Ф_processNewStake ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_validatorKey : XInteger256 )( $ Л_stakeAt : XInteger32 )( $ Л_maxFactor : XInteger32 )( $ Л_adnlAddr : XInteger256 )( $ Л_signature : XInteger8 ) : StakingContractT := 
depoolFuncs.v: 	 ( d0! Л_request := ElectorBase_ι_Request (( $ Л_queryId , $ Л_validatorKey , $ Л_stakeAt , $ Л_maxFactor , $ Л_adnlAddr , $ Л_signature )) ) >> 
depoolFuncs.v: 	 StakingContract_Ф__addRequest (( $ Л_stakeAt , $ Л_request )) ) >> 
depoolFuncs.v: Ife ( $ Л_stakeAt ?== ElectionParams_Ф__getElectAt () ) { 
depoolFuncs.v: 	 ( d0! Л_round := RoundsBase_Ф__getPenultimateRound () ) >> 
depoolFuncs.v: 	 require (( $ Л_round ^^ RoundsBase_ι_Round_ι_step ?== RoundsBase_ι_STEP_WAITING_REQUESTS , $ xInt118 )) ) >> 
depoolFuncs.v: 	 require (( $ Л_stakeAt ?== $ Л_round ^^ RoundsBase_ι_Round_ι_id , $ xInt111 )) ) >> 
depoolFuncs.v: 	 ElectorBase_Ф__runForElection (( $ Л_request , RoundsBase_ι_Round_ι_stake )) ) >> 
depoolFuncs.v: 	 ( d2! Л_round ^^ RoundsBase_ι_Round_ι_step := RoundsBase_ι_STEP_ELECTIONS ) >> 
depoolFuncs.v: 	 RoundsBase_Ф__setPenultimateRound (( $ Л_round )) ) >> 
depoolFuncs.v: 	 ( d0! Л_electionsStarted := now ?>= ElectionParams_Ф__getElectionsStart () ) >> 
depoolFuncs.v: Ife ( $ Л_electionsStarted ) { StakingContract_Ф__addNewRoundAndUpdateRounds () ) >> 
depoolFuncs.v:Definition StakingContract_Ф_forceCompletePendingRound ( msg_sender : XInteger ) ( $ Л_doCompleteOneChunk : XBool )( $ Л_chunkSize : XInteger8 ) : StakingContractT := 
depoolFuncs.v: 	 (( _ , $ Л_round , $ Л_ok )) := RoundsBase_Ф__fetchOldestPendingRound () ) >> 
depoolFuncs.v: 	 require (( $ Л_ok , $ xInt121 )) ) >> 
depoolFuncs.v: 	 require (( $ Л_round ^^ RoundsBase_ι_Round_ι_end + $ xInt1 $ Л_hours ?< now , $ xInt122 )) ) >> 
depoolFuncs.v: Ife ( $ Л_doCompleteOneChunk ) { ( d0! Л_round := StakingContract_Ф__returnOrReinvest (( $ Л_round , $ Л_chunkSize )) ) >> 
depoolFuncs.v: ( d0! Л_round := StakingContract_Ф__completePendingRound (( $ Л_round , $ Л_chunkSize )) ) >> 
depoolFuncs.v: RoundsBase_Ф__setOrDeletePendingRound (( $ Л_round )) ) >> 
depoolFuncs.v:Definition StakingContract_Ф_completePendingRoundChunk ( msg_sender : XInteger ) ( $ Л_roundId : XInteger32 )( $ Л_chunkSize : XInteger8 ) : StakingContractT := 
depoolFuncs.v: 	 (( $ Л_exists , $ Л_round )) := RoundsBase_Ф__roundFetchPendingRound (( $ Л_roundId )) ) >> 
depoolFuncs.v: Ift ( $ Л_exists ) { tvm_accept () ) >> 
depoolFuncs.v: 	 RoundsBase_Ф__setOrDeletePendingRound (( StakingContract_Ф__returnOrReinvest (( $ Л_round , $ Л_chunkSize )) )) ) >> 
depoolFuncs.v:Definition StakingContract_Ф_receiveReturnedStake ( $ Л_queryId : XInteger64 )( $ Л_comment : XInteger32 ) : StakingContractT XInteger64 # XInteger32 := 
depoolFuncs.v: ( d0! Л_round := RoundsBase_Ф__getPenultimateRound () ) >> 
depoolFuncs.v: 	 ( d2! Л_round ^^ RoundsBase_ι_Round_ι_completionStatus := RoundsBase_ι_ROUND_STAKE_REJECTED ) >> 
depoolFuncs.v: 	 return (( $ Л_queryId , $ Л_comment )) ) >> 
depoolFuncs.v:Definition StakingContract_Ф_acceptRecoveredStake ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 ) : StakingContractT := 
depoolFuncs.v: Ife ( $ Л_queryId ?== $ xInt0 ) { StakingContract_Ф__acceptUnusedStake () ) >> 
depoolFuncs.v: Ife ( $ Л_queryId ?== $ xInt1 ) { StakingContract_Ф__acceptRewardStake () ) >> 
depoolFuncs.v: StakingContract_Ф__acceptPendingRoundStake (( uint32 (( $ Л_queryId )) )) ) >> 
depoolFuncs.v:Definition StakingContract_Ф_terminator ( $ Л_chunkSize : XInteger8 ) : StakingContractT := 
depoolFuncs.v: Ift ( RoundsBase_Ф__getRoundsCount () ?!= $ xInt0 ) { ( d0! Л_lastRound := RoundsBase_Ф__getLastRound () ) >> 
depoolFuncs.v: 	 ( d2! Л_lastRound ^^ RoundsBase_ι_Round_ι_completionStatus := RoundsBase_ι_ROUND_POOL_CLOSED ) >> 
depoolFuncs.v: 	 RoundsBase_Ф__setLastRound (( StakingContract_Ф__completeRound (( $ Л_lastRound , $ Л_chunkSize )) )) ) >> 
depoolFuncs.v: emit $ Л_stakingPoolClosed () ) >> 
depoolFuncs.v:Definition DePool_Ф_getStakeholderInfo ( $ Л_addr : XAddress ) : DePoolT XInteger64 # XInteger64 # XInteger64 # XBool # XInteger64 # ι_М_StakeInfo := 
depoolFuncs.v: require (( StakeholderBase_Ф__stakeholderExists (( $ Л_addr )) , $ xInt116 )) ) >> 
depoolFuncs.v: 	 ( d0! Л_stakeholder := StakeholderBase_Ф__getStakeholder (( $ Л_addr )) ) >> 
depoolFuncs.v: 	 ( d1! StakeholderBase_ι_Stakeholder_ι_reinvest := $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_reinvest ) >> 
depoolFuncs.v: 	 $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake ) >> 
depoolFuncs.v: 	 ( d1! OwnerBase_ι_Owner_ι_reward := $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_grossReward ) >> 
depoolFuncs.v: 	 $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake ) >> 
depoolFuncs.v: 	 ( d0! Л_invested2 := $ xInt0 ) >> 
depoolFuncs.v: 	 (( $ Л_index , $ Л_round , $ Л_ok )) := min () ) >> 
depoolFuncs.v: 	 while (( $ Л_ok ) { 
depoolFuncs.v: Ife ( $ Л_round ^^ RoundsBase_ι_Round_ι_step ?< RoundsBase_ι_STEP_COMPLETED ) { (( $ Л_presents , $ Л_value )) := $ Л_round ^^ RoundsBase_ι_Round_ι_stakes . fetch (( $ Л_addr )) ) >> 
depoolFuncs.v: Ift ( $ Л_presents ) { push (( DePool_ι_StakeInfo (( $ Л_round ^^ RoundsBase_ι_Round_ι_id , $ Л_value ^^ RoundsBase_ι_StakeValue_ι_simple , $ Л_value ^^ RoundsBase_ι_StakeValue_ι_vesting )) )) ) >> 
depoolFuncs.v: 	 ( d0! Л_invested2 += $ Л_value ^^ RoundsBase_ι_StakeValue_ι_simple + $ Л_value ^^ RoundsBase_ι_StakeValue_ι_vesting ) >> 
depoolFuncs.v: (( $ Л_presents , $ Л_value )) := $ Л_round ^^ RoundsBase_ι_Round_ι_stakes . fetch (( $ Л_addr )) ) >> 
depoolFuncs.v: Ift ( $ Л_presents ) { ( d0! Л_invested2 += $ Л_value ^^ RoundsBase_ι_StakeValue_ι_simple + $ Л_value ^^ RoundsBase_ι_StakeValue_ι_vesting ) >> 
depoolFuncs.v: (( $ Л_index , $ Л_round , $ Л_ok )) := next (( $ Л_index )) ) >> 
depoolFuncs.v: (( $ Л_index , $ Л_round , $ Л_ok )) := min () ) >> 
depoolFuncs.v: 	 while (( $ Л_ok ) { (( $ Л_presents , $ Л_value )) := $ Л_round ^^ RoundsBase_ι_Round_ι_stakes . fetch (( $ Л_addr )) ) >> 
depoolFuncs.v: Ift ( $ Л_presents ) { ( d0! Л_invested2 += $ Л_value ^^ RoundsBase_ι_StakeValue_ι_simple + $ Л_value ^^ RoundsBase_ι_StakeValue_ι_vesting ) >> 
depoolFuncs.v: (( $ Л_index , $ Л_round , $ Л_ok )) := next (( uint32 (( $ Л_index )) )) ) >> 
depoolFuncs.v:Definition StakingProxyContract_Ф_process_new_stake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_validatorKey : XInteger256 )( $ Л_stakeAt : XInteger32 )( $ Л_maxFactor : XInteger32 )( $ Л_adnlAddr : XInteger256 )( $ Л_signature : XInteger8 ) : StakingProxyContractT := 
depoolFuncs.v: 	 IElector (( ElectorBase_ι_m_elector )) . _Ф_elector_process_new_stake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId , $ Л_validatorKey , $ Л_stakeAt , $ Л_maxFactor , $ Л_adnlAddr , $ Л_signature )) ) >> 
depoolFuncs.v:Definition ElectionParams_Ф_Constructor4 ( $ Л_electionId : XInteger32 )( $ Л_beginBefore : XInteger32 )( $ Л_endBefore : XInteger32 )( $ Л_heldFor : XInteger32 )( $ Л_electedFor : XInteger32 ) : ElectionParamsT := 
depoolFuncs.v: Ife ( $ Л_electionId ?!= $ xInt0 ) { ( d1! ElectionParams_ι_m_electAt := $ Л_electionId ) >> 
depoolFuncs.v: (( ElectionParams_ι_m_electedFor , ElectionParams_ι_m_beginBefore , ElectionParams_ι_m_endBefore , ElectionParams_ι_m_heldFor , $ Л_ok )) := tvm_configParam (( $ xInt15 )) ) >> 
depoolFuncs.v: Ift ( ! $ Л_ok ) { ( d1! ElectionParams_ι_m_beginBefore := $ Л_beginBefore ) >> 
depoolFuncs.v: 	 ( d1! ElectionParams_ι_m_endBefore := $ Л_endBefore ) >> 
depoolFuncs.v: 	 ( d1! ElectionParams_ι_m_electedFor := $ Л_electedFor ) >> 
depoolFuncs.v: 	 ( d1! ElectionParams_ι_m_heldFor := $ Л_heldFor ) >> 
depoolFuncs.v:Definition StakingOwner_Ф_initTimer ( $ Л_timer : XAddress )( $ Л_period : XInteger ) : StakingOwnerT := 
depoolFuncs.v: 	 ( d1! StakingOwner_ι_m_timer := $ Л_timer ) >> 
depoolFuncs.v: 	 ( d1! StakingOwner_ι_m_timeout := $ Л_period ) >> 
depoolFuncs.v: 	 StakingOwner_Ф__settimer (( $ Л_timer , $ Л_period )) ) >> 
depoolFuncs.v:Definition StakingOwner_Ф_upgrade ( $ Л_newcode : TvmCell ) : StakingOwnerT := 
depoolFuncs.v: 	 tvm_setcode (( $ Л_newcode )) ) >> 
depoolFuncs.v: 	 tvm_setCurrentCode (( $ Л_newcode )) ) >> 
depoolFuncs.v:Definition RoundsBase_Ф__roundMoveStakes ( $ Л_source : XAddress )( $ Л_destination : XAddress )( $ Л_targetAmount : XInteger64 ) : RoundsBaseT XInteger64 := 
depoolFuncs.v: (( $ Л_roundId , $ Л_round , $ Л_ok )) := min () ) >> 
depoolFuncs.v: 	 ( d0! Л_transferred := $ xInt0 ) >> 
depoolFuncs.v: 	 while (( $ Л_ok && $ Л_targetAmount ?!= $ xInt0 ) { 
depoolFuncs.v: Ift ( $ Л_round ^^ RoundsBase_ι_Round_ι_step ?!= RoundsBase_ι_STEP_COMPLETED && $ Л_round ^^ RoundsBase_ι_Round_ι_step ?!= RoundsBase_ι_STEP_COMPLETING ) { (( RoundsBase_ι_m_rounds [ $ Л_roundId ] , $ Л_currentTransferred )) := RoundsBase_Ф__roundMoveStake (( $ Л_round , $ Л_source , $ Л_destination , $ Л_targetAmount )) ) >> 
depoolFuncs.v: 	 ( d0! Л_targetAmount -= $ Л_currentTransferred ) >> 
depoolFuncs.v: 	 ( d0! Л_transferred += $ Л_currentTransferred ) >> 
depoolFuncs.v: (( $ Л_roundId , $ Л_round , $ Л_ok )) := next (( $ Л_roundId )) ) >> 
depoolFuncs.v: return $ Л_transferred ) >> 
depoolFuncs.v:Definition StakingContract_Ф__completePendingRound ( $ Л_pendingRound : ι_Round )( $ Л_chunkSize : XInteger8 ) : StakingContractT ι_Round := 
depoolFuncs.v: Ife ( $ Л_pendingRound ^^ RoundsBase_ι_Round_ι_participantQty ?> $ Л_chunkSize ) { for (( ( d0! Л_i := $ xInt0 ) >> 
depoolFuncs.v: 	 $ Л_i ?< $ Л_pendingRound ^^ RoundsBase_ι_Round_ι_participantQty ) >> 
depoolFuncs.v: 	 ( d0! Л_i += $ Л_chunkSize ) { this ^^ StakingContract_Ф_completePendingRoundChunk . value (( 1e7 )) (( $ Л_pendingRound ^^ RoundsBase_ι_Round_ι_id , $ Л_chunkSize )) ) >> 
depoolFuncs.v: ( d0! Л_pendingRound := StakingContract_Ф__returnOrReinvest (( $ Л_pendingRound , $ Л_chunkSize )) ) >> 
depoolFuncs.v: return $ Л_pendingRound ) >> 
DePoolFunc.v:Definition Participant_Ф_receiveRewardStake ( Л_roundId : XInteger32 )( Л_reward : XInteger64 )( Л_usualStake : XInteger64 )( Л_vestingStake : XInteger64 )( Л_reinvest : XBool )( Л_fee : XInteger64 )( Л_reason : XInteger8 ) : LedgerT True 
DePoolFunc.v:Definition Participant_Ф_receiveAnswer ( $ Л_errcode : XInteger32 )( $ Л_comment : XInteger64 ) : ParticipantT True 
DePoolFunc.v:Definition Participant_Ф_receiveRewardStake ( $ Л_roundId : XInteger32 )( $ Л_reward : XInteger64 )( $ Л_usualStake : XInteger64 )( $ Л_vestingStake : XInteger64 )( $ Л_reinvest : XBool )( $ Л_fee : XInteger64 )( $ Л_reason : XInteger8 ) : ParticipantT True 
DePoolFunc.v:Definition Participant_Ф_receiveAnswer ( $ Л_errcode : XInteger32 )( $ Л_comment : XInteger64 ) : ParticipantT True 
DePoolFunc.v:Definition StakingProxyContract_Ф_process_new_stake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_validatorKey : XInteger256 )( $ Л_stakeAt : XInteger32 )( $ Л_maxFactor : XInteger32 )( $ Л_adnlAddr : XInteger256 )( $ Л_signature : XInteger8 ) : StakingProxyContractT := 
DePoolFunc.v: 	 IElector (( ElectorBase_ι_m_elector )) . library_Ф_elector_process_new_stake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId , $ Л_validatorKey , $ Л_stakeAt , $ Л_maxFactor , $ Л_adnlAddr , $ Л_signature )) ) >> 
DePoolFunc.v:Definition StakingProxyContract_Ф_recover_stake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 ) : StakingProxyContractT := 
DePoolFunc.v: 	 IElector (( ElectorBase_ι_m_elector )) . library_Ф_elector_recover_stake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId )) ) >> 
DePoolFunc.v:Definition StakingContract_Ф_receiveConfirmation ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_comment : XInteger32 ) : StakingContractT := 
DePoolFunc.v: 	 require (( $ Л_comment ?== $ xInt0 , library_ι_INVALID_ELECTOR_CONFIRM )) ) >> 
DePoolFunc.v: 	 require (( $ Л_queryId ?>= $ xInt0 , library_ι_INVALID_ELECTOR_CONFIRM )) ) >> 
DePoolFunc.v:Definition StakingContract_Ф_receiveReturnedStake ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_comment : XInteger32 ) : StakingContractT := 
DePoolFunc.v: 	 ( d0! Л_round := RoundsBase_Ф__getPenultimateRound () ) >> 
DePoolFunc.v: 	 RoundsBase_Ф__setPenultimateRound (( StakingContract_Ф__completeRound (( $ Л_round , RoundsBase_ι_ROUND_STAKE_REJECTED )) )) ) >> 
DePoolFunc.v: 	 emit $ Л_roundStakeIsRejected (( $ Л_queryId , $ Л_comment )) ) >> 
DePoolFunc.v:Definition StakingContract_Ф_acceptRecoveredStake ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 ) : StakingContractT := 
DePoolFunc.v: Ife ( $ Л_queryId ?== $ xInt0 ) { StakingContract_Ф__acceptUnusedStake () ) >> 
DePoolFunc.v: Ife ( $ Л_queryId ?== $ xInt1 ) { StakingContract_Ф__acceptRewardStake () ) >> 
DePoolFunc.v: StakingContract_Ф__acceptPendingRoundStake (( uint32 (( $ Л_queryId )) )) ) >> 
DePoolFunc.v: 	 ( d0! Л_electionsStarted := now ?>= ElectionParams_Ф__getElectionsStart () ) >> 
DePoolFunc.v: Ife ( $ Л_electionsStarted ) { StakingContract_Ф__addNewRoundAndUpdateRounds () ) >> 
DePoolFunc.v:Definition Stakeholder_Ф_sendTransaction ( $ Л_dest : XAddress )( $ Л_value : XInteger64 )( $ Л_bounce : XBool )( $ Л_flags : XInteger16 )( $ Л_payload : TvmCell ) : StakeholderT := 
DePoolFunc.v: 	 $ Л_dest ^^ transfer (( $ Л_value , $ Л_bounce , $ Л_flags , $ Л_payload )) ) >> 
DePoolFunc.v:Definition OwnerBase_Ф_Constructor2 ( $ Л_poolOwnerAddr : XAddress ) : OwnerBaseT := 
DePoolFunc.v: ( d1! OwnerBase_ι_m_owner := OwnerBase_ι_Owner (( $ Л_poolOwnerAddr , $ xInt0 )) ) >> 
DePoolFunc.v:Definition OwnerBase_Ф_withdrawOwnerReward ( msg_sender : XInteger ) ( $ Л_amount : XInteger64 ) : OwnerBaseT := 
DePoolFunc.v: 	 require (( $ Л_amount ?<= OwnerBase_ι_Owner_ι_reward , library_ι_NOT_ENOUGH_FUNDS )) ) >> 
DePoolFunc.v: 	 ( d1! OwnerBase_ι_Owner_ι_reward -= $ Л_amount ) >> 
DePoolFunc.v: 	 OwnerBase_ι_Owner_ι_addr . transfer (( $ Л_amount , $ xBoolTrue , $ xInt3 )) ) >> 
DePoolFunc.v:Definition OwnerBase_Ф__increaseOwnerReward ( $ Л_ownerReward : XInteger64 ) : OwnerBaseT := 
DePoolFunc.v: ( d1! OwnerBase_ι_Owner_ι_reward += $ Л_ownerReward ) >> 
DePoolFunc.v:Definition ElectorBase_Ф_Constructor3 ( $ Л_electorAddr : XAddress ) : ElectorBaseT := 
DePoolFunc.v: ( d1! ElectorBase_ι_m_elector := $ Л_electorAddr ) >> 
DePoolFunc.v: (( _ , , $ Л_utime_until , _ , , _ , , $ Л_ok )) := tvm_configParam (( $ xInt34 )) ) >> 
DePoolFunc.v: Ift ( ! $ Л_ok ) { require (( now ?>= ElectionParams_ι_m_electAt - ElectionParams_ι_m_beginBefore , $ xInt228 )) ) >> 
DePoolFunc.v: 	 ( d0! Л_offset := (( (( uint32 (( now )) - (( ElectionParams_ι_m_electAt - ElectionParams_ι_m_beginBefore )) )) / ElectionParams_ι_m_electedFor + $ xInt1 )) * ElectionParams_ι_m_electedFor ) >> 
DePoolFunc.v: 	 ( d0! Л_utime_until := ElectionParams_ι_m_electAt + $ Л_offset ) >> 
DePoolFunc.v: return $ Л_utime_until ) >> 
DePoolFunc.v:Definition ElectionParams_Ф__isElectionOver ( $ Л_currentElectAt : XInteger32 ) : ElectionParamsT XBool := 
DePoolFunc.v: return now ?>= (( $ Л_currentElectAt - ElectionParams_ι_m_endBefore )) ) >> 
DePoolFunc.v:Definition StakeholderBase_Ф__haveVesting ( $ Л_stakeholder : ι_Stakeholder ) : StakeholderBaseT XBool := 
DePoolFunc.v: return $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_periodPayment ?!= $ xInt0 ) >> 
DePoolFunc.v:Definition StakeholderBase_Ф__stakeholderSetVesting ( $ Л_stakeholder : ι_Stakeholder )( $ Л_stake : XInteger64 )( $ Л_withdrawalPeriod : XInteger32 )( $ Л_periodPayment : XInteger64 )( $ Л_vestingOwner : XAddress ) : StakeholderBaseT ι_Stakeholder := 
DePoolFunc.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake += $ Л_stake ) >> 
DePoolFunc.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_lastPaymentUnixTime := uint64 (( now )) ) >> 
DePoolFunc.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_withdrawalPeriod := $ Л_withdrawalPeriod ) >> 
DePoolFunc.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_periodPayment := $ Л_periodPayment ) >> 
DePoolFunc.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_vestingOwner := $ Л_vestingOwner ) >> 
DePoolFunc.v: 	 return $ Л_stakeholder ) >> 
DePoolFunc.v:Definition StakeholderBase_Ф__getStakeholder ( $ Л_addr : XAddress ) : StakeholderBaseT ι_Stakeholder := 
DePoolFunc.v: return StakeholderBase_ι_m_stakeholders [ $ Л_addr ] ) >> 
DePoolFunc.v:Definition StakeholderBase_Ф__stakeholderFetch ( $ Л_addr : XAddress ) : StakeholderBaseT XBool # ι_Stakeholder := 
DePoolFunc.v: return fetch (( $ Л_addr )) ) >> 
DePoolFunc.v:Definition StakeholderBase_Ф__setOrDeleteStakeholder ( $ Л_addr : XAddress )( $ Л_stakeholder : ι_Stakeholder ) : StakeholderBaseT := 
DePoolFunc.v: Ift ( $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake ?== $ xInt0 )) delete StakeholderBase_ι_m_stakeholders [ $ Л_addr ] ) >> 
DePoolFunc.v: 	 else ( d4! StakeholderBase_ι_m_stakeholders [ Л_addr ] := $ Л_stakeholder ) >> 
DePoolFunc.v:Definition StakeholderBase_Ф__stakeholderAddStakeAndSetReinvest ( $ Л_stakeholder : ι_Stakeholder )( $ Л_deltaStake : XInteger64 )( $ Л_reinvest : XBool ) : StakeholderBaseT ι_Stakeholder := 
DePoolFunc.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_reinvest := $ Л_reinvest ) >> 
DePoolFunc.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake += $ Л_deltaStake ) >> 
DePoolFunc.v: 	 return $ Л_stakeholder ) >> 
DePoolFunc.v:Definition StakeholderBase_Ф__stakeholderRemoveStake ( $ Л_addr : XAddress )( $ Л_removedStake : XInteger64 )( $ Л_unusedStake : XInteger64 ) : StakeholderBaseT := 
DePoolFunc.v: ( d0! Л_stakeholder := StakeholderBase_ι_m_stakeholders [ $ Л_addr ] ) >> 
DePoolFunc.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake -= $ Л_removedStake ) >> 
DePoolFunc.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake -= $ Л_unusedStake ) >> 
DePoolFunc.v: Ife ( $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake ?== $ xInt0 ) { delete StakeholderBase_ι_m_stakeholders [ $ Л_addr ] ) >> 
DePoolFunc.v: ( d4! StakeholderBase_ι_m_stakeholders [ Л_addr ] := $ Л_stakeholder ) >> 
DePoolFunc.v:Definition StakeholderBase_Ф__stakeholderIncreaseStakeAndUnused ( $ Л_stakeholder : ι_Stakeholder )( $ Л_deltaStake : XInteger64 )( $ Л_deltaUnused : XInteger64 ) : StakeholderBaseT ι_Stakeholder := 
DePoolFunc.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake += $ Л_deltaStake + $ Л_deltaUnused ) >> 
DePoolFunc.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake += $ Л_deltaUnused ) >> 
DePoolFunc.v: 	 return $ Л_stakeholder ) >> 
DePoolFunc.v:Definition StakeholderBase_Ф_stakeholderDecreaseStakeAndUnused ( $ Л_stakeholder : ι_Stakeholder )( $ Л_deltaStake : XInteger64 )( $ Л_deltaUnused : XInteger64 ) : StakeholderBaseT ι_Stakeholder := 
DePoolFunc.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake -= $ Л_deltaStake + $ Л_deltaUnused ) >> 
DePoolFunc.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake -= $ Л_deltaUnused ) >> 
DePoolFunc.v: 	 return $ Л_stakeholder ) >> 
DePoolFunc.v:Definition StakeholderBase_Ф__stakeholderSetReinvest ( $ Л_stakeholder : ι_Stakeholder )( $ Л_flag : XBool ) : StakeholderBaseT ι_Stakeholder := 
DePoolFunc.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_reinvest := $ Л_flag ) >> 
DePoolFunc.v: 	 return $ Л_stakeholder ) >> 
DePoolFunc.v:Definition StakeholderBase_Ф__stakeholderUpdateTotalStake ( $ Л_stakeholder : ι_Stakeholder )( $ Л_newStake : XInteger64 )( $ Л_oldStake : XInteger64 ) : StakeholderBaseT ι_Stakeholder := 
DePoolFunc.v: Ift ( $ Л_newStake ?>= $ Л_oldStake )) ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake += $ Л_newStake - $ Л_oldStake ) >> 
DePoolFunc.v: 	 else ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake -= $ Л_oldStake - $ Л_newStake ) >> 
DePoolFunc.v: 	 return $ Л_stakeholder ) >> 
DePoolFunc.v:Definition StakeholderBase_Ф__stakeholderIncreaseUnusedStake ( $ Л_stakeholder : ι_Stakeholder )( $ Л_delta : XInteger64 ) : StakeholderBaseT ι_Stakeholder := 
DePoolFunc.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake += $ Л_delta ) >> 
DePoolFunc.v: 	 return $ Л_stakeholder ) >> 
DePoolFunc.v:Definition StakeholderBase_Ф__stakeholderDecreaseUnusedStake ( $ Л_stakeholder : ι_Stakeholder )( $ Л_delta : XInteger64 ) : StakeholderBaseT ι_Stakeholder := 
DePoolFunc.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake -= $ Л_delta ) >> 
DePoolFunc.v: 	 return $ Л_stakeholder ) >> 
DePoolFunc.v:Definition StakeholderBase_Ф__stakeholderResetVesting ( $ Л_stakeholder : ι_Stakeholder ) : StakeholderBaseT ι_Stakeholder := 
DePoolFunc.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_lastPaymentUnixTime := $ xInt0 ) >> 
DePoolFunc.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_withdrawalPeriod := $ xInt0 ) >> 
DePoolFunc.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_periodPayment := $ xInt0 ) >> 
DePoolFunc.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_vestingOwner := xInt0 ) >> 
DePoolFunc.v: 	 return $ Л_stakeholder ) >> 
DePoolFunc.v:Definition StakeholderBase_Ф__stakeholderUpdateLastPaymentTime ( $ Л_stakeholder : ι_Stakeholder )( $ Л_periodQty : XInteger64 ) : StakeholderBaseT ι_Stakeholder := 
DePoolFunc.v: ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_lastPaymentUnixTime += $ Л_periodQty * $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_withdrawalPeriod ) >> 
DePoolFunc.v: 	 return $ Л_stakeholder ) >> 
DePoolFunc.v:Definition StakingOwner_Ф_Constructor5 ( $ Л_pool : XAddress ) : StakingOwnerT := 
DePoolFunc.v: 	 ( d1! StakingOwner_ι_m_stakingPool := $ Л_pool ) >> 
DePoolFunc.v:Definition StakingOwner_Ф_updateStakingPoolAddress ( $ Л_addr : XAddress ) : StakingOwnerT := 
DePoolFunc.v: 	 ( d1! StakingOwner_ι_m_stakingPool := $ Л_addr ) >> 
DePoolFunc.v:Definition StakingProxyContract_Ф_Constructor6 ( $ Л_staking : XAddress )( $ Л_elector : XAddress ) : StakingProxyContractT := 
DePoolFunc.v: 	 ( d1! StakingProxyContract_ι_m_staking := $ Л_staking ) >> 
DePoolFunc.v: 	 ( d1! ElectorBase_ι_m_elector := $ Л_elector ) >> 
DePoolFunc.v:Definition RoundsBase_Ф__addNewPoolingRound ( $ Л_validationStart : XInteger32 )( $ Л_validationPeriod : XInteger32 ) : RoundsBaseT := 
DePoolFunc.v: RoundsBase_ι_Round_ι_id : $ Л_validationStart , RoundsBase_ι_Round_ι_step : RoundsBase_ι_STEP_POOLING , RoundsBase_ι_Round_ι_participantQty : $ xInt0 , RoundsBase_ι_Round_ι_stake : $ xInt0 , RoundsBase_ι_Round_ι_rewards : $ xInt0 , RoundsBase_ι_Round_ι_unused : $ xInt0 , RoundsBase_ι_Round_ι_completionStatus : RoundsBase_ι_ROUND_UNDEFINED , RoundsBase_ι_Round_ι_start : uint32 (( now )) , RoundsBase_ι_Round_ι_end : $ Л_validationStart + $ Л_validationPeriod 
DePoolFunc.v: (( _ , $ Л_round )) := delMin () ) >> 
DePoolFunc.v: 	 return $ Л_round ) >> 
DePoolFunc.v:Definition RoundsBase_Ф__setOldestRound ( $ Л_round : ι_Round ) : RoundsBaseT := 
DePoolFunc.v: ( d4! RoundsBase_ι_m_rounds [ RoundsBase_ι_m_startIdx ] := $ Л_round ) >> 
DePoolFunc.v:Definition RoundsBase_Ф__roundAddStakeAndVesting ( $ Л_round : ι_Round )( $ Л_addr : XAddress )( $ Л_stake : XInteger64 )( $ Л_vestingStake : XInteger64 ) : RoundsBaseT ι_Round := 
DePoolFunc.v: ( d0! Л_totalStake := $ Л_stake + $ Л_vestingStake ) >> 
DePoolFunc.v: Ift ( $ Л_totalStake ?== $ xInt0 )) return $ Л_round ) >> 
DePoolFunc.v: Ift ( ! $ Л_round ^^ RoundsBase_ι_Round_ι_stakes . exists (( $ Л_addr )) ) { $ Л_round ^^ RoundsBase_ι_Round_ι_participantQty ++ ) >> 
DePoolFunc.v: ( d2! Л_round ^^ RoundsBase_ι_Round_ι_stake += $ Л_totalStake ) >> 
DePoolFunc.v: 	 ( d0! Л_sv := $ Л_round ^^ RoundsBase_ι_Round_ι_stakes [ $ Л_addr ] ) >> 
DePoolFunc.v: 	 ( d2! Л_sv ^^ RoundsBase_ι_StakeValue_ι_simple += $ Л_stake ) >> 
DePoolFunc.v: 	 ( d2! Л_sv ^^ RoundsBase_ι_StakeValue_ι_vesting += $ Л_vestingStake ) >> 
DePoolFunc.v: 	 ( d3! Л_round ^^ RoundsBase_ι_Round_ι_stakes [ Л_addr ] := $ Л_sv ) >> 
DePoolFunc.v: 	 return $ Л_round ) >> 
DePoolFunc.v:Definition RoundsBase_Ф__roundMoveStake ( $ Л_round : ι_Round )( $ Л_source : XAddress )( $ Л_destination : XAddress )( $ Л_amount : XInteger64 ) : RoundsBaseT ι_Round # XInteger64 := 
DePoolFunc.v: (( $ Л_exists , $ Л_sourceStake )) := $ Л_round ^^ RoundsBase_ι_Round_ι_stakes . fetch (( $ Л_source )) ) >> 
DePoolFunc.v: Ife ( ! $ Л_exists )) return (( $ Л_round , $ xInt0 )) ) >> 
DePoolFunc.v: Ife ( $ Л_sourceStake ^^ RoundsBase_ι_StakeValue_ι_simple ?>= $ Л_amount ) { ( d0! Л_newSourceStake := $ Л_sourceStake ^^ RoundsBase_ι_StakeValue_ι_simple - $ Л_amount ) >> 
DePoolFunc.v: 	 ( d0! Л_deltaDestinationStake := $ Л_amount ) >> 
DePoolFunc.v: ( d0! Л_newSourceStake := $ xInt0 ) >> 
DePoolFunc.v: 	 ( d0! Л_deltaDestinationStake := $ Л_sourceStake ^^ RoundsBase_ι_StakeValue_ι_simple ) >> 
DePoolFunc.v: Ife ( $ Л_newSourceStake ?== $ xInt0 && $ Л_round ^^ RoundsBase_ι_Round_ι_stakes [ $ Л_source ] ^^ RoundsBase_ι_StakeValue_ι_vesting ?== $ xInt0 ) { -- $ Л_round ^^ RoundsBase_ι_Round_ι_participantQty ) >> 
DePoolFunc.v: 	 delete $ Л_round ^^ RoundsBase_ι_Round_ι_stakes [ $ Л_source ] ) >> 
DePoolFunc.v: $ Л_round ^^ RoundsBase_ι_Round_ι_stakes [ $ Л_source ( d2! ] ^^ RoundsBase_ι_StakeValue_ι_simple := $ Л_newSourceStake ) >> 
DePoolFunc.v: Ift ( ! $ Л_round ^^ RoundsBase_ι_Round_ι_stakes . exists (( $ Л_destination )) )) $ Л_round ^^ RoundsBase_ι_Round_ι_participantQty ++ ) >> 
DePoolFunc.v: 	 $ Л_round ^^ RoundsBase_ι_Round_ι_stakes [ $ Л_destination ( d2! ] ^^ RoundsBase_ι_StakeValue_ι_simple += $ Л_deltaDestinationStake ) >> 
DePoolFunc.v: 	 return (( $ Л_round , $ Л_deltaDestinationStake )) ) >> 
DePoolFunc.v:Definition RoundsBase_Ф__addPendingRound ( $ Л_round : ι_Round ) : RoundsBaseT := 
DePoolFunc.v: RoundsBase_ι_m_pendingRounds [ $ Л_round ^^ RoundsBase_ι_Round_ι_id $ Л_round ) >> 
DePoolFunc.v:Definition RoundsBase_Ф__removePendingRound ( $ Л_pendingId : XInteger32 ) : RoundsBaseT XBool # ι_Round := 
DePoolFunc.v: (( exists , round )) := fetch (( $ Л_pendingId )) ) >> 
DePoolFunc.v: Ift ( exists ) { delete RoundsBase_ι_m_pendingRounds [ $ Л_pendingId ] ) >> 
DePoolFunc.v:Definition RoundsBase_Ф__roundFetchPendingRound ( $ Л_pendingId : XInteger32 ) : RoundsBaseT XBool # ι_Round := 
DePoolFunc.v: return fetch (( $ Л_pendingId )) ) >> 
DePoolFunc.v:Definition RoundsBase_Ф__setOrDeletePendingRound ( $ Л_round : ι_Round ) : RoundsBaseT := 
DePoolFunc.v: Ife ( $ Л_round ^^ RoundsBase_ι_Round_ι_step ?== RoundsBase_ι_STEP_COMPLETED ) { delete RoundsBase_ι_m_pendingRounds [ $ Л_round ^^ RoundsBase_ι_Round_ι_id ] ) >> 
DePoolFunc.v: RoundsBase_ι_m_pendingRounds [ $ Л_round ^^ RoundsBase_ι_Round_ι_id $ Л_round ) >> 
DePoolFunc.v:Definition RoundsBase_Ф__deletePendingRound ( $ Л_id : XInteger32 ) : RoundsBaseT := 
DePoolFunc.v: delete RoundsBase_ι_m_pendingRounds [ $ Л_id ] ) >> 
DePoolFunc.v:Definition RoundsBase_Ф_sumOfStakes ( $ Л_stakes : ι_StakeValue ) : RoundsBaseT XInteger64 := 
DePoolFunc.v: return $ Л_stakes ^^ RoundsBase_ι_StakeValue_ι_simple + $ Л_stakes ^^ RoundsBase_ι_StakeValue_ι_vesting ) >> 
DePoolFunc.v: (( $ Л_index , $ Л_round , $ Л_ok )) := min () ) >> 
DePoolFunc.v: 	 while (( $ Л_ok ) { infos ^^ push (( RoundsBase_ι_RoundInfo (( $ Л_round ^^ RoundsBase_ι_Round_ι_id , $ Л_round ^^ RoundsBase_ι_Round_ι_start , $ Л_round ^^ RoundsBase_ι_Round_ι_end , $ Л_round ^^ RoundsBase_ι_Round_ι_step , $ Л_round ^^ RoundsBase_ι_Round_ι_completionStatus , $ Л_round ^^ RoundsBase_ι_Round_ι_stake , $ Л_round ^^ RoundsBase_ι_Round_ι_participantQty , $ Л_round ^^ RoundsBase_ι_Round_ι_rewards )) )) ) >> 
DePoolFunc.v: 	 (( $ Л_index , $ Л_round , $ Л_ok )) := next (( $ Л_index )) ) >> 
DePoolFunc.v: (( $ Л_key , $ Л_round , $ Л_ok )) := min () ) >> 
DePoolFunc.v: 	 while (( $ Л_ok ) { infos ^^ push (( RoundsBase_ι_RoundInfo (( $ Л_round ^^ RoundsBase_ι_Round_ι_id , $ Л_round ^^ RoundsBase_ι_Round_ι_start , $ Л_round ^^ RoundsBase_ι_Round_ι_end , $ Л_round ^^ RoundsBase_ι_Round_ι_step , $ Л_round ^^ RoundsBase_ι_Round_ι_completionStatus , $ Л_round ^^ RoundsBase_ι_Round_ι_stake , $ Л_round ^^ RoundsBase_ι_Round_ι_participantQty , $ Л_round ^^ RoundsBase_ι_Round_ι_rewards )) )) ) >> 
DePoolFunc.v: 	 (( $ Л_key , $ Л_round , $ Л_ok )) := next (( $ Л_key )) ) >> 
DePoolFunc.v:Definition StakingContract_Ф__calcLastRoundInterest ( $ Л_totalStake : XInteger64 )( $ Л_rewards : XInteger64 ) : StakingContractT XInteger64 := 
DePoolFunc.v: return (( $ Л_totalStake ?!= $ xInt0 )) ? uint64 (( (( uint (( $ Л_rewards )) * $ xInt100 * 1e9 )) / $ Л_totalStake ) : $ xInt0 ) >> 
DePoolFunc.v:Definition StakingContract_Ф__addRequest ( $ Л_stakeAt : XInteger32 )( $ Л_request : ι_Request ) : StakingContractT := 
DePoolFunc.v: require (( ! exists (( $ Л_stakeAt )) , library_ι_REPEATED_REQUEST )) ) >> 
DePoolFunc.v: 	 ( d4! StakingContract_ι_m_requests [ Л_stakeAt ] := $ Л_request ) >> 
DePoolFunc.v:Definition StakingContract_Ф_Constructor7 ( $ Л_electorAddr : XAddress )( $ Л_poolOwnerAddr : XAddress )( $ Л_electionId : XInteger32 )( $ Л_nodeWallet : XAddress )( $ Л_beginBefore : XInteger32 )( $ Л_endBefore : XInteger32 )( $ Л_heldFor : XInteger32 )( $ Л_electedFor : XInteger32 )( $ Л_minStake : XInteger64 )( $ Л_minRoundStake : XInteger64 )( $ Л_maxRoundStake : XInteger64 ) : StakingContractT := 
DePoolFunc.v: ( d1! StakingContract_ι_m_minStake := $ Л_minStake ) >> 
DePoolFunc.v: 	 ( d1! StakingContract_ι_m_minRoundStake := $ Л_minRoundStake ) >> 
DePoolFunc.v: 	 ( d1! StakingContract_ι_m_maxRoundStake := $ Л_maxRoundStake ) >> 
DePoolFunc.v: 	 ( d1! StakingContract_ι_m_nodeWallet := $ Л_nodeWallet ) >> 
DePoolFunc.v:Definition StakingContract_Ф_receiveConfirmation ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_comment : XInteger32 ) : StakingContractT := 
DePoolFunc.v: 	 require (( $ Л_comment ?== $ xInt0 , library_ι_INVALID_ELECTOR_CONFIRM )) ) >> 
DePoolFunc.v: 	 require (( $ Л_queryId ?>= $ xInt0 , library_ι_INVALID_ELECTOR_CONFIRM )) ) >> 
DePoolFunc.v:Definition DePool_Ф_Constructor8 ( $ Л_electorAddr : XAddress )( $ Л_poolOwnerAddr : XAddress )( $ Л_electionId : XInteger32 )( $ Л_nodeWallet : XAddress )( $ Л_beginBefore : XInteger32 )( $ Л_endBefore : XInteger32 )( $ Л_heldFor : XInteger32 )( $ Л_electedFor : XInteger32 )( $ Л_minStake : XInteger64 )( $ Л_minRoundStake : XInteger64 )( $ Л_maxRoundStake : XInteger64 ) : DePoolT True 
DePoolFunc.v:Definition StakingContract_Ф_receiveConfirmation ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_comment : XInteger32 ) : StakingContractT := 
DePoolFunc.v: 	 require (( $ Л_comment ?== $ xInt0 , library_ι_INVALID_ELECTOR_CONFIRM )) ) >> 
DePoolFunc.v: 	 require (( $ Л_queryId ?>= $ xInt0 , library_ι_INVALID_ELECTOR_CONFIRM )) ) >> 
DePoolFunc.v:Definition StakingContract_Ф_acceptRecoveredStake ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 ) : StakingContractT := 
DePoolFunc.v: Ife ( $ Л_queryId ?== $ xInt0 ) { StakingContract_Ф__acceptUnusedStake () ) >> 
DePoolFunc.v: Ife ( $ Л_queryId ?== $ xInt1 ) { StakingContract_Ф__acceptRewardStake () ) >> 
DePoolFunc.v: StakingContract_Ф__acceptPendingRoundStake (( uint32 (( $ Л_queryId )) )) ) >> 
DePoolFunc.v:Definition TestElector_Ф_Constructor9 ( $ Л_offset : XInteger32 ) : TestElectorT := 
DePoolFunc.v: ( d1! TestElector_ι_electAt := uint32 (( now )) + $ Л_offset ) >> 
DePoolFunc.v:Definition ElectorBase_Ф__recoverPendingRoundStakes ( $ Л_pendingId : XInteger32 ) : ElectorBaseT := 
DePoolFunc.v: IProxy (( ElectorBase_ι_m_elector )) . Participant_Ф_recover_stake ^^ value (( ElectorBase_ι_RECOVER_STAKE_MSG_VALUE )) (( $ Л_pendingId )) ) >> 
DePoolFunc.v:Definition ElectorBase_Ф__sendRequestToElector ( $ Л_req : ι_Request )( $ Л_nodeStake : XInteger64 ) : ElectorBaseT := 
DePoolFunc.v: value : $ Л_nodeStake + 1e9 + 2*1e7 
DePoolFunc.v: (( $ Л_req ^^ ElectorBase_ι_Request_ι_queryId , $ Л_req ^^ ElectorBase_ι_Request_ι_validatorKey , $ Л_req ^^ ElectorBase_ι_Request_ι_stakeAt , $ Л_req ^^ ElectorBase_ι_Request_ι_maxFactor , $ Л_req ^^ ElectorBase_ι_Request_ι_adnlAddr , $ Л_req ^^ ElectorBase_ι_Request_ι_signature )) ) >> 
DePoolFunc.v:Definition ElectionParams_Ф__isRoundUnfrozen ( $ Л_electAt : XInteger32 ) : ElectionParamsT XBool := 
DePoolFunc.v: return now ?> (( $ Л_electAt + ElectionParams_Ф__getFreezingPeriod () )) ) >> 
DePoolFunc.v: ( d0! Л_nextElectAt := ElectionParams_Ф__getNextElectionId () ) >> 
DePoolFunc.v: Ift ( now ?>= $ Л_nextElectAt - ElectionParams_ι_m_beginBefore ) { ( d0! Л_nextElectAt += ElectionParams_ι_m_electedFor ) >> 
DePoolFunc.v: ( d1! ElectionParams_ι_m_electAt := $ Л_nextElectAt ) >> 
DePoolFunc.v: 	 return $ Л_nextElectAt ) >> 
DePoolFunc.v:Definition StakingOwner_Ф__settimer ( $ Л_timer : XAddress )( $ Л_period : XInteger ) : StakingOwnerT := 
DePoolFunc.v: ITimer (( $ Л_timer )) . StakeholderBase_Ф_setTimer ^^ value (( StakingOwner_ι_TIMER_FEE )) (( $ Л_period )) ) >> 
DePoolFunc.v: ( d0! Л_timer := StakingOwner_ι_m_timer ) >> 
DePoolFunc.v: 	 ( d0! Л_period := StakingOwner_ι_m_timeout ) >> 
DePoolFunc.v: Ift ( $ msg_sender ?== $ Л_timer && $ Л_period ?> $ xInt0 ) { IStaking (( StakingOwner_ι_m_stakingPool )) . Participant_Ф_ticktock ^^ value (( StakingOwner_ι_TICKTOCK_FEE )) () ) >> 
DePoolFunc.v: 	 StakingOwner_Ф__settimer (( $ Л_timer , $ Л_period )) ) >> 
DePoolFunc.v:Definition StakingProxyContract_Ф_process_new_stake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_validatorKey : XInteger256 )( $ Л_stakeAt : XInteger32 )( $ Л_maxFactor : XInteger32 )( $ Л_adnlAddr : XInteger256 )( $ Л_signature : XInteger8 ) : StakingProxyContractT := 
DePoolFunc.v: 	 IElector (( ElectorBase_ι_m_elector )) . library_Ф_elector_process_new_stake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId , $ Л_validatorKey , $ Л_stakeAt , $ Л_maxFactor , $ Л_adnlAddr , $ Л_signature )) ) >> 
DePoolFunc.v:Definition StakingProxyContract_Ф_recover_stake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 ) : StakingProxyContractT := 
DePoolFunc.v: 	 IElector (( ElectorBase_ι_m_elector )) . library_Ф_elector_recover_stake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId )) ) >> 
DePoolFunc.v:Definition StakingProxyContract_Ф_receive_confirmation ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_comment : XInteger32 ) : StakingProxyContractT := 
DePoolFunc.v: 	 IStaking (( StakingProxyContract_ι_m_staking )) . Participant_Ф_receiveConfirmation ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId , $ Л_comment )) ) >> 
DePoolFunc.v:Definition StakingProxyContract_Ф_receive_returned_stake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_comment : XInteger32 ) : StakingProxyContractT := 
DePoolFunc.v: 	 IStaking (( StakingProxyContract_ι_m_staking )) . Participant_Ф_receiveReturnedStake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId , $ Л_comment )) ) >> 
DePoolFunc.v:Definition StakingProxyContract_Ф_accept_recovered_stake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 ) : StakingProxyContractT := 
DePoolFunc.v: 	 IStaking (( StakingProxyContract_ι_m_staking )) . Participant_Ф_acceptRecoveredStake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId )) ) >> 
DePoolFunc.v: (( $ Л_exists , $ Л_round )) := fetch (( RoundsBase_Ф__getLastRoundIdx () )) ) >> 
DePoolFunc.v: 	 require (( $ Л_exists , $ xInt200 )) ) >> 
DePoolFunc.v: 	 return $ Л_round ) >> 
DePoolFunc.v:Definition RoundsBase_Ф__setLastRound ( $ Л_round : ι_Round ) : RoundsBaseT := 
DePoolFunc.v: RoundsBase_ι_m_rounds [ RoundsBase_Ф__getLastRoundIdx () $ Л_round ) >> 
DePoolFunc.v:Definition RoundsBase_Ф__setPenultimateRound ( $ Л_round : ι_Round ) : RoundsBaseT := 
DePoolFunc.v: RoundsBase_ι_m_rounds [ RoundsBase_Ф__getLastRoundIdx () - $ xInt1 $ Л_round ) >> 
DePoolFunc.v:Definition RoundsBase_Ф__roundRemoveStakeInLastRound ( $ Л_participant : XAddress )( $ Л_targetAmount : XInteger64 )( $ Л_minStake : XInteger64 ) : RoundsBaseT XInteger64 # XInteger64 := 
DePoolFunc.v: ( d0! Л_round := RoundsBase_Ф__getLastRound () ) >> 
DePoolFunc.v: 	 (( $ Л_exists , $ Л_sv )) := $ Л_round ^^ RoundsBase_ι_Round_ι_stakes . fetch (( $ Л_participant )) ) >> 
DePoolFunc.v: Ift ( ! $ Л_exists ) { return (( $ xInt0 , $ xInt0 )) ) >> 
DePoolFunc.v: ( d0! Л_targetAmount := tvm_min (( $ Л_targetAmount , $ Л_sv ^^ RoundsBase_ι_StakeValue_ι_simple )) ) >> 
DePoolFunc.v: 	 ( d2! Л_sv ^^ RoundsBase_ι_StakeValue_ι_simple -= $ Л_targetAmount ) >> 
DePoolFunc.v: 	 ( d2! Л_round ^^ RoundsBase_ι_Round_ι_stake -= $ Л_targetAmount ) >> 
DePoolFunc.v: Ift ( $ Л_sv ^^ RoundsBase_ι_StakeValue_ι_simple ?< $ Л_minStake ) { ( d0! Л_unused := $ Л_sv ^^ RoundsBase_ι_StakeValue_ι_simple ) >> 
DePoolFunc.v: 	 ( d2! Л_round ^^ RoundsBase_ι_Round_ι_stake -= $ Л_sv ^^ RoundsBase_ι_StakeValue_ι_simple ) >> 
DePoolFunc.v: 	 ( d2! Л_sv ^^ RoundsBase_ι_StakeValue_ι_simple := $ xInt0 ) >> 
DePoolFunc.v: Ife ( RoundsBase_Ф_sumOfStakes (( $ Л_sv )) ?== $ xInt0 ) { -- $ Л_round ^^ RoundsBase_ι_Round_ι_participantQty ) >> 
DePoolFunc.v: 	 delete $ Л_round ^^ RoundsBase_ι_Round_ι_stakes [ $ Л_participant ] ) >> 
DePoolFunc.v: ( d3! Л_round ^^ RoundsBase_ι_Round_ι_stakes [ Л_participant ] := $ Л_sv ) >> 
DePoolFunc.v: RoundsBase_Ф__setLastRound (( $ Л_round )) ) >> 
DePoolFunc.v: 	 return (( $ Л_targetAmount , $ Л_unused )) ) >> 
DePoolFunc.v: Ift ( RoundsBase_Ф__getRoundsCount () ?> $ xInt4 ) { ( d0! Л_removingRound := RoundsBase_Ф__removeOldestRound () ) >> 
DePoolFunc.v: 	 delete StakingContract_ι_m_requests [ $ Л_removingRound ^^ RoundsBase_ι_Round_ι_id ] ) >> 
DePoolFunc.v: Ift ( $ Л_removingRound ^^ RoundsBase_ι_Round_ι_step ?== RoundsBase_ι_STEP_WAITING_ELECTION_RESULTS ) { RoundsBase_Ф__addPendingRound (( $ Л_removingRound )) ) >> 
DePoolFunc.v: 	 ElectorBase_Ф__recoverPendingRoundStakes (( $ Л_removingRound ^^ RoundsBase_ι_Round_ι_id )) ) >> 
DePoolFunc.v: ( d0! Л_lb1Round := RoundsBase_Ф__getPenultimateRound () ) >> 
DePoolFunc.v: Ift ( now ?> $ Л_lb1Round ^^ RoundsBase_ι_Round_ι_id ) { 
DePoolFunc.v: Ift ( $ Л_lb1Round ^^ RoundsBase_ι_Round_ι_step ?< RoundsBase_ι_STEP_ELECTIONS ) { RoundsBase_Ф__setPenultimateRound (( StakingContract_Ф__completeRound (( $ Л_lb1Round , RoundsBase_ι_ROUND_MISSED_ELECTIONS )) )) ) >> 
DePoolFunc.v: Ift ( $ Л_lb1Round ^^ RoundsBase_ι_Round_ι_step ?< RoundsBase_ι_STEP_WAITING_ELECTION_RESULTS ) { ElectorBase_Ф__recoverStakes () ) >> 
DePoolFunc.v: 	 ( d2! Л_lb1Round ^^ RoundsBase_ι_Round_ι_step := RoundsBase_ι_STEP_WAITING_ELECTION_RESULTS ) >> 
DePoolFunc.v: 	 RoundsBase_Ф__setPenultimateRound (( $ Л_lb1Round )) ) >> 
DePoolFunc.v: ( d0! Л_oldestRound := RoundsBase_Ф__getOldestRound () ) >> 
DePoolFunc.v: Ift ( ElectionParams_Ф__isRoundUnfrozen (( $ Л_oldestRound ^^ RoundsBase_ι_Round_ι_id )) ) { 
DePoolFunc.v: Ift ( $ Л_oldestRound ^^ RoundsBase_ι_Round_ι_step ?== RoundsBase_ι_STEP_WAITING_ELECTION_RESULTS ) { ElectorBase_Ф__recoverStakeRewards () ) >> 
DePoolFunc.v: 	 ( d2! Л_oldestRound ^^ RoundsBase_ι_Round_ι_step := RoundsBase_ι_STEP_WAITING_UNFREEZE ) >> 
DePoolFunc.v: 	 RoundsBase_Ф__setOldestRound (( $ Л_oldestRound )) ) >> 
DePoolFunc.v:Definition StakingContract_Ф__sendError ( msg_sender : XInteger ) ( $ Л_errcode : XInteger32 )( $ Л_comment : XInteger64 ) : StakingContractT := 
DePoolFunc.v: (( $ Л_errcode , $ Л_comment )) ) >> 
DePoolFunc.v:Definition StakingContract_Ф__sendAccept ( msg_sender : XInteger ) ( $ Л_fee : XInteger64 ) : StakingContractT := 
DePoolFunc.v: (( StakingContract_ι_STATUS_SUCCESS , $ Л_fee )) ) >> 
DePoolFunc.v:Definition StakingContract_Ф__requestStakesSigning ( $ Л_round : ι_Round ) : StakingContractT ι_Round := 
DePoolFunc.v: ( d0! Л_roundStake := $ Л_round ^^ RoundsBase_ι_Round_ι_stake ) >> 
DePoolFunc.v: 	 ( d0! Л_currentElectAt := $ Л_round ^^ RoundsBase_ι_Round_ι_id ) >> 
DePoolFunc.v: 	 ( d0! Л_roundStakeCheck := $ Л_roundStake ?>= StakingContract_ι_m_minRoundStake ) >> 
DePoolFunc.v: 	 ( d0! Л_nodeStakeCheck := RoundsBase_Ф_sumOfStakes (( $ Л_round ^^ RoundsBase_ι_Round_ι_stakes [ StakingContract_ι_m_nodeWallet ] )) ?>= (( StakingContract_ι_m_minRoundStake * StakingContract_ι_NODE_WALLET_MIN_STAKE )) / $ xInt100 ) >> 
DePoolFunc.v: 	 ( d0! Л_canParticipate := ! ElectionParams_Ф__isElectionOver (( $ Л_currentElectAt )) && $ Л_roundStakeCheck && $ Л_nodeStakeCheck ) >> 
DePoolFunc.v: Ife ( $ Л_canParticipate ) { emit $ Л_stakeSigningRequested (( $ Л_currentElectAt )) ) >> 
DePoolFunc.v: 	 (( $ Л_exists , $ Л_request )) := fetch (( $ Л_currentElectAt )) ) >> 
DePoolFunc.v: Ife ( $ Л_exists ) { ( d2! Л_round ^^ RoundsBase_ι_Round_ι_step := RoundsBase_ι_STEP_ELECTIONS ) >> 
DePoolFunc.v: 	 ElectorBase_Ф__sendRequestToElector (( $ Л_request , $ Л_roundStake )) ) >> 
DePoolFunc.v: ( d2! Л_round ^^ RoundsBase_ι_Round_ι_step := RoundsBase_ι_STEP_WAITING_REQUESTS ) >> 
DePoolFunc.v: ( d0! Л_completionStatus := ! $ Л_roundStakeCheck ? RoundsBase_ι_ROUND_NOT_ENOUGH_TOTAL_STAKE : RoundsBase_ι_ROUND_NODE_STAKE_TOO_SMALL ) >> 
DePoolFunc.v: 	 ( d0! Л_round := StakingContract_Ф__completeRound (( $ Л_round , $ Л_completionStatus )) ) >> 
DePoolFunc.v: return $ Л_round ) >> 
DePoolFunc.v:Definition StakingContract_Ф__acceptPendingRoundStake ( $ Л_pendingId : XInteger32 ) : StakingContractT := 
DePoolFunc.v: (( $ Л_exists , $ Л_round )) := RoundsBase_Ф__removePendingRound (( $ Л_pendingId )) ) >> 
DePoolFunc.v: Ift ( $ Л_exists ) { StakingContract_Ф__completeRound (( $ Л_round , RoundsBase_ι_ROUND_RECEIVED_REWARD )) ) >> 
DePoolFunc.v: ( d0! Л_lb1round := RoundsBase_Ф__getPenultimateRound () ) >> 
DePoolFunc.v: Ife ( $ msg_value ?>= $ Л_lb1round ^^ RoundsBase_ι_Round_ι_stake ) { RoundsBase_Ф__setPenultimateRound (( StakingContract_Ф__completeRound (( $ Л_lb1round , RoundsBase_ι_ROUND_LOST_ELECTIONS )) )) ) >> 
DePoolFunc.v: ( d2! Л_lb1round ^^ RoundsBase_ι_Round_ι_unused := uint64 (( $ msg_value )) ) >> 
DePoolFunc.v: 	 RoundsBase_Ф__setPenultimateRound (( $ Л_lb1round )) ) >> 
DePoolFunc.v: 	 ( d1! StakingContract_ι_m_minRoundStake := $ Л_lb1round ^^ RoundsBase_ι_Round_ι_stake - $ Л_lb1round ^^ RoundsBase_ι_Round_ι_unused + StakingContract_ι_ROUND_UP_VALUE ) >> 
DePoolFunc.v: ( d0! Л_oldestRound := RoundsBase_Ф__getOldestRound () ) >> 
DePoolFunc.v: 	 ( d0! Л_roundStake := $ Л_oldestRound ^^ RoundsBase_ι_Round_ι_stake - $ Л_oldestRound ^^ RoundsBase_ι_Round_ι_unused ) >> 
DePoolFunc.v: 	 ( d0! Л_totalReward := $ xInt0 ) >> 
DePoolFunc.v: Ift ( uint64 (( $ msg_value )) ?>= $ Л_roundStake ) { ( d0! Л_totalReward := uint64 (( $ msg_value )) - $ Л_roundStake ) >> 
DePoolFunc.v: ( d0! Л_roundReward := uint64 (( uint (( $ Л_totalReward )) * StakingContract_ι_NOM_FRACTION / $ xInt100 )) ) >> 
DePoolFunc.v: 	 ( d0! Л_ownerReward := uint64 (( uint (( $ Л_totalReward )) * StakingContract_ι_NODE_FRACTION / $ xInt100 )) ) >> 
DePoolFunc.v: 	 OwnerBase_Ф__increaseOwnerReward (( $ Л_ownerReward )) ) >> 
DePoolFunc.v: 	 ( d2! Л_oldestRound ^^ RoundsBase_ι_Round_ι_rewards := $ Л_roundReward ) >> 
DePoolFunc.v: 	 ( d1! StakingContract_ι_m_lastRoundInterest := StakingContract_Ф__calcLastRoundInterest (( $ Л_roundStake , $ Л_roundReward )) ) >> 
DePoolFunc.v: 	 RoundsBase_Ф__setOldestRound (( StakingContract_Ф__completeRound (( $ Л_oldestRound , RoundsBase_ι_ROUND_RECEIVED_REWARD )) )) ) >> 
DePoolFunc.v:Definition StakingContract_Ф__completeRoundWithSpecialChunkSize ( $ Л_completedRound : ι_Round )( $ Л_completionStatus : XInteger8 )( $ Л_chunkSize : XInteger8 ) : StakingContractT ι_Round := 
DePoolFunc.v: ( d2! Л_completedRound ^^ RoundsBase_ι_Round_ι_completionStatus := $ Л_completionStatus ) >> 
DePoolFunc.v: 	 ( d2! Л_completedRound ^^ RoundsBase_ι_Round_ι_step := RoundsBase_ι_STEP_COMPLETING ) >> 
DePoolFunc.v: 	 ( d2! Л_completedRound ^^ RoundsBase_ι_Round_ι_end := uint32 (( now )) ) >> 
DePoolFunc.v: 	 RoundsBase_Ф__setOrDeletePendingRound (( $ Л_completedRound )) ) >> 
DePoolFunc.v: 	 ( d0! Л_completedRound := StakingContract_Ф__completePendingRound (( $ Л_completedRound , $ Л_chunkSize )) ) >> 
DePoolFunc.v: 	 RoundsBase_Ф__setOrDeletePendingRound (( $ Л_completedRound )) ) >> 
DePoolFunc.v: 	 delete $ Л_completedRound ^^ RoundsBase_ι_Round_ι_stakes ) >> 
DePoolFunc.v: 	 return $ Л_completedRound ) >> 
DePoolFunc.v:Definition StakingContract_Ф__completeRound ( $ Л_completedRound : ι_Round )( $ Л_completionStatus : XInteger8 ) : StakingContractT ι_Round := 
DePoolFunc.v: return StakingContract_Ф__completeRoundWithSpecialChunkSize (( $ Л_completedRound , $ Л_completionStatus , StakingContract_ι_MAX_MSGS_PER_TR )) ) >> 
DePoolFunc.v:Definition StakingContract_Ф__returnOrReinvestForStakeholder ( $ Л_completedRound : ι_Round )( $ Л_lastRound : ι_Round )( $ Л_addr : XAddress )( $ Л_stakes : ι_StakeValue ) : StakingContractT ι_Round := 
DePoolFunc.v: ( d0! Л_newStake := $ Л_stakes ^^ RoundsBase_ι_StakeValue_ι_simple ) >> 
DePoolFunc.v: 	 ( d0! Л_newVesting := $ Л_stakes ^^ RoundsBase_ι_StakeValue_ι_vesting ) >> 
DePoolFunc.v: 	 ( d0! Л_stakeSum := RoundsBase_Ф_sumOfStakes (( $ Л_stakes )) ) >> 
DePoolFunc.v: 	 ( d0! Л_reward := tvm_max (( int64 (( int (( $ Л_stakeSum )) * $ Л_completedRound ^^ RoundsBase_ι_Round_ι_rewards / $ Л_completedRound ^^ RoundsBase_ι_Round_ι_stake - int (( StakingContract_ι_NOTIFY_FEE )) )) , - int64 (( $ Л_stakeSum )) )) ) >> 
DePoolFunc.v: 	 ( d0! Л_stakeholder := StakeholderBase_Ф__getStakeholder (( $ Л_addr )) ) >> 
DePoolFunc.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake := uint64 (( int64 (( $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake )) + $ Л_reward )) ) >> 
DePoolFunc.v: 	 ( d2! Л_stakeholder ^^ OwnerBase_ι_Owner_ι_reward += $ Л_reward ) >> 
DePoolFunc.v: 	 ( d0! Л_notificationFee := StakingContract_ι_NOTIFY_FEE ) >> 
DePoolFunc.v: Ift ( $ Л_reward ?< $ xInt0 ) { ( d0! Л_notificationFee := uint64 (( - $ Л_reward )) ) >> 
DePoolFunc.v: 	 ( d0! Л_targetDecrease := uint64 (( - $ Л_reward )) ) >> 
DePoolFunc.v: 	 ( d0! Л_deltaSimple := tvm_min (( $ Л_newStake , $ Л_targetDecrease )) ) >> 
DePoolFunc.v: 	 ( d0! Л_newStake -= $ Л_deltaSimple ) >> 
DePoolFunc.v: 	 ( d0! Л_newVesting -= $ Л_targetDecrease - $ Л_deltaSimple ) >> 
DePoolFunc.v: Ift ( $ Л_reward ?> $ xInt0 ) { ( d0! Л_newStake += uint64 (( $ Л_reward )) ) >> 
DePoolFunc.v: Ift ( $ Л_newVesting ?!= $ xInt0 ) { ( d0! Л_periodQty := (( uint64 (( now )) - $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_lastPaymentUnixTime )) / $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_withdrawalPeriod ) >> 
DePoolFunc.v: 	 ( d0! Л_withdrawalVesting := tvm_min (( $ Л_periodQty * $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_periodPayment , $ Л_newVesting )) ) >> 
DePoolFunc.v: 	 ( d0! Л_newVesting -= $ Л_withdrawalVesting ) >> 
DePoolFunc.v: 	 ( d0! Л_newStake += $ Л_withdrawalVesting ) >> 
DePoolFunc.v: 	 ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderUpdateLastPaymentTime (( $ Л_stakeholder , $ Л_periodQty )) ) >> 
DePoolFunc.v: Ift ( $ Л_newVesting ?< StakingContract_ι_m_minStake ) { ( d0! Л_newStake += $ Л_newVesting ) >> 
DePoolFunc.v: 	 ( d0! Л_newVesting := $ xInt0 ) >> 
DePoolFunc.v: Ift ( $ Л_newStake ?< StakingContract_ι_m_minStake ) { ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderIncreaseUnusedStake (( $ Л_stakeholder , $ Л_newStake )) ) >> 
DePoolFunc.v: 	 ( d0! Л_newStake := $ xInt0 ) >> 
DePoolFunc.v: Ife ( StakingContract_ι_m_poolClosed ) { ( d0! Л_attachedValue := $ Л_newStake + $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake ) >> 
DePoolFunc.v: 	 ( d0! Л_stakeholder := StakeholderBase_Ф_stakeholderDecreaseStakeAndUnused (( $ Л_stakeholder , $ Л_newStake + $ Л_newVesting , $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake )) ) >> 
DePoolFunc.v: Ift ( $ Л_newVesting ?!= $ xInt0 && $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_vestingOwner ?!= xInt0 ) { $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_vestingOwner . transfer (( 
DePoolFunc.v: value : $ Л_newVesting , flag : $ xInt3 
DePoolFunc.v: ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderResetVesting (( $ Л_stakeholder )) ) >> 
DePoolFunc.v: ( d0! Л_attachedValue := $ xInt1 ) >> 
DePoolFunc.v: Ife ( $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_reinvest ) { ( d0! Л_lastRound := RoundsBase_Ф__roundAddStakeAndVesting (( $ Л_lastRound , $ Л_addr , $ Л_newStake , $ Л_newVesting )) ) >> 
DePoolFunc.v: ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderIncreaseUnusedStake (( $ Л_stakeholder , $ Л_newStake )) ) >> 
DePoolFunc.v: 	 ( d0! Л_lastRound := RoundsBase_Ф__roundAddStakeAndVesting (( $ Л_lastRound , $ Л_addr , $ xInt0 , $ Л_newVesting )) ) >> 
DePoolFunc.v: StakeholderBase_Ф__setOrDeleteStakeholder (( $ Л_addr , $ Л_stakeholder )) ) >> 
DePoolFunc.v: 	 IParticipant (( $ Л_addr )) . library_Ф_receiveRewardStake 
DePoolFunc.v: value : $ Л_attachedValue , flag : $ xInt3 
DePoolFunc.v: (( $ Л_completedRound ^^ RoundsBase_ι_Round_ι_id , $ Л_reward , $ Л_newStake , $ Л_newVesting , $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_reinvest , $ Л_notificationFee , $ Л_completedRound ^^ RoundsBase_ι_Round_ι_completionStatus )) ) >> 
DePoolFunc.v: 	 return $ Л_lastRound ) >> 
DePoolFunc.v:Definition StakingContract_Ф__returnOrReinvest ( $ Л_completedRound : ι_Round )( $ Л_chunkSize : XInteger8 ) : StakingContractT ι_Round := 
DePoolFunc.v: ( d1! RoundsBase_ι_Round_ι_stakes := $ Л_completedRound ^^ RoundsBase_ι_Round_ι_stakes ) >> 
DePoolFunc.v: 	 ( d0! Л_lastRound := RoundsBase_Ф__getLastRound () ) >> 
DePoolFunc.v: 	 ( d0! Л_sentMsgs := $ xInt0 ) >> 
DePoolFunc.v: 	 while (( ! empty () && $ Л_sentMsgs ?< $ Л_chunkSize ) { $ Л_sentMsgs ++ ) >> 
DePoolFunc.v: 	 (( $ Л_addr , $ Л_stake )) := delMin () ) >> 
DePoolFunc.v: 	 ( d0! Л_lastRound := StakingContract_Ф__returnOrReinvestForStakeholder (( $ Л_completedRound , $ Л_lastRound , $ Л_addr , $ Л_stake )) ) >> 
DePoolFunc.v: Ift ( $ Л_completedRound ^^ RoundsBase_ι_Round_ι_id ?!= $ Л_lastRound ^^ RoundsBase_ι_Round_ι_id ) { RoundsBase_Ф__setLastRound (( $ Л_lastRound )) ) >> 
DePoolFunc.v: ( d2! Л_completedRound ^^ RoundsBase_ι_Round_ι_step := empty () ? RoundsBase_ι_STEP_COMPLETED : RoundsBase_ι_STEP_COMPLETING ) >> 
DePoolFunc.v: 	 ( d2! Л_completedRound ^^ RoundsBase_ι_Round_ι_stakes := RoundsBase_ι_Round_ι_stakes ) >> 
DePoolFunc.v: 	 return $ Л_completedRound ) >> 
DePoolFunc.v:Definition StakingContract_Ф__getMsgValueAndSendErrorIfNeeded ( msg_value : XInteger ) ( $ Л_unused : XInteger64 ) : StakingContractT XInteger64 # XBool := 
DePoolFunc.v: 	 ( d0! Л_msgValue := uint64 (( $ msg_value )) ) >> 
DePoolFunc.v: 	 ( d0! Л_minRequiredValue := StakingContract_ι_m_minStake + StakingContract_ι_ADD_STAKE_FEE ) >> 
DePoolFunc.v: Ift ( $ Л_msgValue + $ Л_unused ?< $ Л_minRequiredValue ) { StakingContract_Ф__sendError (( StakingContract_ι_STATUS_STAKE_TOO_SMALL , $ Л_minRequiredValue )) ) >> 
DePoolFunc.v: return (( $ Л_msgValue - StakingContract_ι_ADD_STAKE_FEE , $ xBoolTrue )) ) >> 
DePoolFunc.v:Definition StakingContract_Ф_investStake ( msg_sender : XInteger ) ( $ Л_unusedStake : XInteger64 )( $ Л_reinvest : XBool ) : StakingContractT := 
DePoolFunc.v: 	 ( d0! Л_stakeholder := StakeholderBase_Ф__getStakeholder (( $ msg_sender )) ) >> 
DePoolFunc.v: 	 ( d0! Л_unusedStake := tvm_min (( $ Л_unusedStake , $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake )) ) >> 
DePoolFunc.v: 	 (( $ Л_msgValue , $ Л_ok )) := StakingContract_Ф__getMsgValueAndSendErrorIfNeeded (( $ Л_unusedStake )) ) >> 
DePoolFunc.v: Ift ( ! $ Л_ok ) { return ) >> 
DePoolFunc.v: ( d0! Л_stake := $ Л_unusedStake + $ Л_msgValue ) >> 
DePoolFunc.v: 	 ( d0! Л_round := RoundsBase_Ф__getLastRound () ) >> 
DePoolFunc.v: Ift ( $ Л_round ^^ RoundsBase_ι_Round_ι_stake + $ Л_stake ?> StakingContract_ι_m_maxRoundStake ) { return StakingContract_Ф__sendError (( StakingContract_ι_STATUS_ROUND_STAKE_LIMIT , StakingContract_ι_m_maxRoundStake - $ Л_round ^^ RoundsBase_ι_Round_ι_stake )) ) >> 
DePoolFunc.v: RoundsBase_Ф__setLastRound (( RoundsBase_Ф__roundAddStakeAndVesting (( $ Л_round , $ msg_sender , $ Л_stake , $ xInt0 )) )) ) >> 
DePoolFunc.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake -= $ Л_unusedStake ) >> 
DePoolFunc.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake += $ Л_msgValue ) >> 
DePoolFunc.v: 	 ( d2! Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_reinvest := $ Л_reinvest ) >> 
DePoolFunc.v: 	 StakeholderBase_Ф__setOrDeleteStakeholder (( $ msg_sender , $ Л_stakeholder )) ) >> 
DePoolFunc.v:Definition StakingContract_Ф_addVesting ( msg_sender : XInteger ) ( $ Л_dest : XAddress )( $ Л_withdrawalPeriod : XInteger32 )( $ Л_totalPeriod : XInteger32 ) : StakingContractT := 
DePoolFunc.v: require (( $ Л_dest ^^ isStdAddrWithoutAnyCast () , library_ι_INVALID_ADDRESS )) ) >> 
DePoolFunc.v: Ift ( $ Л_dest ?== xInt0 ) { ( d0! Л_dest := $ msg_sender ) >> 
DePoolFunc.v: (( $ Л_stake , $ Л_ok )) := StakingContract_Ф__getMsgValueAndSendErrorIfNeeded (( $ xInt0 )) ) >> 
DePoolFunc.v: Ift ( ! $ Л_ok ) { return ) >> 
DePoolFunc.v: ( d0! Л_round := RoundsBase_Ф__getLastRound () ) >> 
DePoolFunc.v: Ift ( $ Л_round ^^ RoundsBase_ι_Round_ι_stake + $ Л_stake ?> StakingContract_ι_m_maxRoundStake ) { return StakingContract_Ф__sendError (( StakingContract_ι_STATUS_ROUND_STAKE_LIMIT , StakingContract_ι_m_maxRoundStake - $ Л_round ^^ RoundsBase_ι_Round_ι_stake )) ) >> 
DePoolFunc.v: Ift ( $ Л_withdrawalPeriod ?> $ Л_totalPeriod ) { return StakingContract_Ф__sendError (( StakingContract_ι_STATUS_WITHDRAWAL_PERIOD_GREATER_TOTAL_PERIOD , $ xInt0 )) ) >> 
DePoolFunc.v: Ift ( $ Л_totalPeriod ?>= $ xInt100 * (( $ Л_days )) ) { return StakingContract_Ф__sendError (( StakingContract_ι_STATUS_TOTAL_PERIOD_MORE_100YEARS , $ xInt0 )) ) >> 
DePoolFunc.v: Ift ( $ Л_withdrawalPeriod ?== $ xInt0 ) { return StakingContract_Ф__sendError (( StakingContract_ι_STATUS_WITHDRAWAL_PERIOD_IS_ZERO , $ xInt0 )) ) >> 
DePoolFunc.v: Ift ( $ Л_totalPeriod $ Л_% $ Л_withdrawalPeriod ?!= $ xInt0 ) { return StakingContract_Ф__sendError (( StakingContract_ι_STATUS_TOTAL_PERIOD_IS_NOT_DIVED_BY_WITHDRAWAL_PERIOD , $ xInt0 )) ) >> 
DePoolFunc.v: ( d0! Л_stakeholder := StakeholderBase_Ф__getStakeholder (( $ Л_dest )) ) >> 
DePoolFunc.v: Ift ( StakeholderBase_Ф__haveVesting (( $ Л_stakeholder )) ) { return StakingContract_Ф__sendError (( StakingContract_ι_STATUS_STAKEHOLDER_HAVE_ALREADY_VESTING , $ xInt0 )) ) >> 
DePoolFunc.v: ( d0! Л_periodPayment := uint64 (( uint (( $ Л_stake )) * $ Л_withdrawalPeriod / $ Л_totalPeriod )) ) >> 
DePoolFunc.v: Ift ( $ Л_periodPayment ?== $ xInt0 ) { return StakingContract_Ф__sendError (( StakingContract_ι_STATUS_PERIOD_PAYMENT_IS_ZERO , $ xInt0 )) ) >> 
DePoolFunc.v: ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderSetVesting (( $ Л_stakeholder , $ Л_stake , $ Л_withdrawalPeriod , $ Л_periodPayment , $ msg_sender )) ) >> 
DePoolFunc.v: 	 StakeholderBase_Ф__setOrDeleteStakeholder (( $ Л_dest , $ Л_stakeholder )) ) >> 
DePoolFunc.v: 	 RoundsBase_Ф__setLastRound (( RoundsBase_Ф__roundAddStakeAndVesting (( $ Л_round , $ Л_dest , $ xInt0 , $ Л_stake )) )) ) >> 
DePoolFunc.v:Definition StakingContract_Ф_removeStake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_doRemoveFromCurrentRound : XBool )( $ Л_targetValue : XInteger64 ) : StakingContractT := 
DePoolFunc.v: (( $ Л_exists , $ Л_participant )) := StakeholderBase_Ф__stakeholderFetch (( $ msg_sender )) ) >> 
DePoolFunc.v: Ift ( ! $ Л_exists ) { return StakingContract_Ф__sendError (( StakingContract_ι_STATUS_NO_STAKEHOLDER , $ xInt0 )) ) >> 
DePoolFunc.v: Ift ( $ Л_targetValue ?== $ xInt0 ) { ( d0! Л_targetValue := StakingContract_ι_MAX_MONEY_VALUE ) >> 
DePoolFunc.v: ( d0! Л_removedStake := $ xInt0 ) >> 
DePoolFunc.v: Ift ( $ Л_doRemoveFromCurrentRound && RoundsBase_Ф__getRoundsCount () ?> $ xInt0 ) { (( $ Л_removedStake , $ Л_unused )) := RoundsBase_Ф__roundRemoveStakeInLastRound (( $ msg_sender , $ Л_targetValue , StakingContract_ι_m_minStake )) ) >> 
DePoolFunc.v: 	 ( d0! Л_participant := StakeholderBase_Ф__stakeholderIncreaseUnusedStake (( $ Л_participant , $ Л_unused )) ) >> 
DePoolFunc.v: ( d0! Л_removedUnused := tvm_min (( $ Л_targetValue - $ Л_removedStake , $ Л_participant ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake )) ) >> 
DePoolFunc.v: 	 ( d0! Л_participant := StakeholderBase_Ф_stakeholderDecreaseStakeAndUnused (( $ Л_participant , $ Л_removedStake , $ Л_removedUnused )) ) >> 
DePoolFunc.v: 	 StakeholderBase_Ф__setOrDeleteStakeholder (( $ msg_sender , $ Л_participant )) ) >> 
DePoolFunc.v: Ift ( $ Л_removedStake + $ Л_removedUnused ?== $ xInt0 ) { return StakingContract_Ф__sendError (( StakingContract_ι_STATUS_NO_AVAILABLE_TOKENS , $ xInt0 )) ) >> 
DePoolFunc.v: $ msg_sender ^^ transfer (( $ Л_removedStake + $ Л_removedUnused , $ xBoolTrue , $ xInt3 )) ) >> 
DePoolFunc.v:Definition StakingContract_Ф_setReinvest ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_flag : XBool ) : StakingContractT := 
DePoolFunc.v: (( $ Л_exists , $ Л_stakeholder )) := StakeholderBase_Ф__stakeholderFetch (( $ msg_sender )) ) >> 
DePoolFunc.v: Ift ( ! $ Л_exists ) { return StakingContract_Ф__sendError (( StakingContract_ι_STATUS_NO_STAKEHOLDER , $ xInt0 )) ) >> 
DePoolFunc.v: ( d0! Л_stakeholder := StakeholderBase_Ф__stakeholderSetReinvest (( $ Л_stakeholder , $ Л_flag )) ) >> 
DePoolFunc.v: 	 StakeholderBase_Ф__setOrDeleteStakeholder (( $ msg_sender , $ Л_stakeholder )) ) >> 
DePoolFunc.v:Definition StakingContract_Ф_transferStake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_destination : XAddress )( $ Л_amount : XInteger64 ) : StakingContractT := 
DePoolFunc.v: 	 ( d0! Л_sender := $ msg_sender ) >> 
DePoolFunc.v: 	 (( $ Л_exists , $ Л_donor )) := StakeholderBase_Ф__stakeholderFetch (( $ Л_sender )) ) >> 
DePoolFunc.v: Ift ( ! $ Л_exists ) { return StakingContract_Ф__sendError (( StakingContract_ι_STATUS_NO_STAKEHOLDER , $ xInt0 )) ) >> 
DePoolFunc.v: require (( $ Л_destination ^^ isStdAddrWithoutAnyCast () && ! $ Л_destination ^^ isStdZero () , library_ι_INVALID_ADDRESS )) ) >> 
DePoolFunc.v: Ift ( $ Л_amount ?== $ xInt0 ) { ( d0! Л_amount := StakingContract_ι_MAX_MONEY_VALUE ) >> 
DePoolFunc.v: ( d0! Л_receiver := StakeholderBase_Ф__getStakeholder (( $ Л_destination )) ) >> 
DePoolFunc.v: 	 ( d0! Л_transferredStake := RoundsBase_Ф__roundMoveStakes (( $ Л_sender , $ Л_destination , $ Л_amount )) ) >> 
DePoolFunc.v: 	 ( d0! Л_transferredUnused := tvm_min (( $ Л_amount - $ Л_transferredStake , $ Л_donor ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake )) ) >> 
DePoolFunc.v: 	 ( d0! Л_donor := StakeholderBase_Ф_stakeholderDecreaseStakeAndUnused (( $ Л_donor , $ Л_transferredStake , $ Л_transferredUnused )) ) >> 
DePoolFunc.v: 	 ( d0! Л_receiver := StakeholderBase_Ф__stakeholderIncreaseStakeAndUnused (( $ Л_receiver , $ Л_transferredStake , $ Л_transferredUnused )) ) >> 
DePoolFunc.v: 	 StakeholderBase_Ф__setOrDeleteStakeholder (( $ Л_sender , $ Л_donor )) ) >> 
DePoolFunc.v: 	 StakeholderBase_Ф__setOrDeleteStakeholder (( $ Л_destination , $ Л_receiver )) ) >> 
DePoolFunc.v:Definition StakingContract_Ф_processNewStake ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_validatorKey : XInteger256 )( $ Л_stakeAt : XInteger32 )( $ Л_maxFactor : XInteger32 )( $ Л_adnlAddr : XInteger256 )( $ Л_signature : XInteger8 ) : StakingContractT := 
DePoolFunc.v: 	 ( d0! Л_request := ElectorBase_ι_Request (( $ Л_queryId , $ Л_validatorKey , $ Л_stakeAt , $ Л_maxFactor , $ Л_adnlAddr , $ Л_signature )) ) >> 
DePoolFunc.v: 	 StakingContract_Ф__addRequest (( $ Л_stakeAt , $ Л_request )) ) >> 
DePoolFunc.v: Ife ( $ Л_stakeAt ?== ElectionParams_Ф__getElectAt () ) { 
DePoolFunc.v: 	 ( d0! Л_round := RoundsBase_Ф__getPenultimateRound () ) >> 
DePoolFunc.v: 	 require (( $ Л_round ^^ RoundsBase_ι_Round_ι_step ?== RoundsBase_ι_STEP_WAITING_REQUESTS , library_ι_WRONG_ROUND_STATE )) ) >> 
DePoolFunc.v: 	 require (( $ Л_stakeAt ?== $ Л_round ^^ RoundsBase_ι_Round_ι_id , library_ι_INVALID_ELECTION_ID )) ) >> 
DePoolFunc.v: 	 ( d2! Л_round ^^ RoundsBase_ι_Round_ι_step := RoundsBase_ι_STEP_ELECTIONS ) >> 
DePoolFunc.v: 	 ElectorBase_Ф__sendRequestToElector (( $ Л_request , $ Л_round ^^ RoundsBase_ι_Round_ι_stake )) ) >> 
DePoolFunc.v: 	 RoundsBase_Ф__setPenultimateRound (( $ Л_round )) ) >> 
DePoolFunc.v: 	 ( d0! Л_electionsStarted := now ?>= ElectionParams_Ф__getElectionsStart () ) >> 
DePoolFunc.v: Ife ( $ Л_electionsStarted ) { StakingContract_Ф__addNewRoundAndUpdateRounds () ) >> 
DePoolFunc.v:Definition StakingContract_Ф_forceCompletePendingRound ( msg_sender : XInteger ) ( $ Л_doCompleteOneChunk : XBool )( $ Л_chunkSize : XInteger8 ) : StakingContractT := 
DePoolFunc.v: 	 (( _ , $ Л_round , $ Л_ok )) := RoundsBase_Ф__fetchOldestPendingRound () ) >> 
DePoolFunc.v: 	 require (( $ Л_ok , library_ι_NO_PENDING_ROUNDS )) ) >> 
DePoolFunc.v: 	 require (( $ Л_round ^^ RoundsBase_ι_Round_ι_end + $ xInt1 $ Л_hours ?< now , library_ι_PENDING_ROUND_IS_TOO_YOUNG )) ) >> 
DePoolFunc.v: Ife ( $ Л_doCompleteOneChunk ) { ( d0! Л_round := StakingContract_Ф__returnOrReinvest (( $ Л_round , $ Л_chunkSize )) ) >> 
DePoolFunc.v: ( d0! Л_round := StakingContract_Ф__completePendingRound (( $ Л_round , $ Л_chunkSize )) ) >> 
DePoolFunc.v: RoundsBase_Ф__setOrDeletePendingRound (( $ Л_round )) ) >> 
DePoolFunc.v:Definition StakingContract_Ф_completePendingRoundChunk ( msg_sender : XInteger ) ( $ Л_roundId : XInteger32 )( $ Л_chunkSize : XInteger8 ) : StakingContractT := 
DePoolFunc.v: 	 (( $ Л_exists , $ Л_round )) := RoundsBase_Ф__roundFetchPendingRound (( $ Л_roundId )) ) >> 
DePoolFunc.v: Ift ( $ Л_exists ) { tvm_accept () ) >> 
DePoolFunc.v: 	 RoundsBase_Ф__setOrDeletePendingRound (( StakingContract_Ф__returnOrReinvest (( $ Л_round , $ Л_chunkSize )) )) ) >> 
DePoolFunc.v:Definition StakingContract_Ф_receiveReturnedStake ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_comment : XInteger32 ) : StakingContractT := 
DePoolFunc.v: 	 ( d0! Л_round := RoundsBase_Ф__getPenultimateRound () ) >> 
DePoolFunc.v: 	 RoundsBase_Ф__setPenultimateRound (( StakingContract_Ф__completeRound (( $ Л_round , RoundsBase_ι_ROUND_STAKE_REJECTED )) )) ) >> 
DePoolFunc.v: 	 emit $ Л_roundStakeIsRejected (( $ Л_queryId , $ Л_comment )) ) >> 
DePoolFunc.v:Definition StakingContract_Ф_acceptRecoveredStake ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 ) : StakingContractT := 
DePoolFunc.v: Ife ( $ Л_queryId ?== $ xInt0 ) { StakingContract_Ф__acceptUnusedStake () ) >> 
DePoolFunc.v: Ife ( $ Л_queryId ?== $ xInt1 ) { StakingContract_Ф__acceptRewardStake () ) >> 
DePoolFunc.v: StakingContract_Ф__acceptPendingRoundStake (( uint32 (( $ Л_queryId )) )) ) >> 
DePoolFunc.v:Definition StakingContract_Ф_terminator ( $ Л_chunkSize : XInteger8 ) : StakingContractT := 
DePoolFunc.v: Ift ( RoundsBase_Ф__getRoundsCount () ?!= $ xInt0 ) { ( d0! Л_lastRound := RoundsBase_Ф__getLastRound () ) >> 
DePoolFunc.v: 	 RoundsBase_Ф__setLastRound (( StakingContract_Ф__completeRoundWithSpecialChunkSize (( $ Л_lastRound , RoundsBase_ι_ROUND_POOL_CLOSED , $ Л_chunkSize )) )) ) >> 
DePoolFunc.v: emit $ Л_stakingPoolClosed () ) >> 
DePoolFunc.v:Definition DePool_Ф_getStakeholderInfo ( $ Л_addr : XAddress ) : DePoolT XInteger64 # XInteger64 # XInteger64 # XBool # XInteger64 # ι_М_StakeInfo := 
DePoolFunc.v: (( $ Л_exists , $ Л_stakeholder )) := StakeholderBase_Ф__stakeholderFetch (( $ Л_addr )) ) >> 
DePoolFunc.v: 	 require (( $ Л_exists , library_ι_NO_SUCH_STAKEHOLDER )) ) >> 
DePoolFunc.v: 	 ( d1! StakeholderBase_ι_Stakeholder_ι_reinvest := $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_reinvest ) >> 
DePoolFunc.v: 	 $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_totalStake ) >> 
DePoolFunc.v: 	 ( d1! OwnerBase_ι_Owner_ι_reward := $ Л_stakeholder ^^ OwnerBase_ι_Owner_ι_reward ) >> 
DePoolFunc.v: 	 $ Л_stakeholder ^^ StakeholderBase_ι_Stakeholder_ι_unusedStake ) >> 
DePoolFunc.v: 	 ( d0! Л_invested2 := $ xInt0 ) >> 
DePoolFunc.v: 	 (( $ Л_index , $ Л_round , $ Л_ok )) := min () ) >> 
DePoolFunc.v: 	 while (( $ Л_ok ) { 
DePoolFunc.v: Ife ( $ Л_round ^^ RoundsBase_ι_Round_ι_step ?< RoundsBase_ι_STEP_COMPLETED ) { (( $ Л_presents , $ Л_value )) := $ Л_round ^^ RoundsBase_ι_Round_ι_stakes . fetch (( $ Л_addr )) ) >> 
DePoolFunc.v: Ift ( $ Л_presents ) { push (( DePool_ι_StakeInfo (( $ Л_round ^^ RoundsBase_ι_Round_ι_id , $ Л_value ^^ RoundsBase_ι_StakeValue_ι_simple , $ Л_value ^^ RoundsBase_ι_StakeValue_ι_vesting )) )) ) >> 
DePoolFunc.v: 	 ( d0! Л_invested2 += $ Л_value ^^ RoundsBase_ι_StakeValue_ι_simple + $ Л_value ^^ RoundsBase_ι_StakeValue_ι_vesting ) >> 
DePoolFunc.v: (( $ Л_presents , $ Л_value )) := $ Л_round ^^ RoundsBase_ι_Round_ι_stakes . fetch (( $ Л_addr )) ) >> 
DePoolFunc.v: Ift ( $ Л_presents ) { ( d0! Л_invested2 += $ Л_value ^^ RoundsBase_ι_StakeValue_ι_simple + $ Л_value ^^ RoundsBase_ι_StakeValue_ι_vesting ) >> 
DePoolFunc.v: (( $ Л_index , $ Л_round , $ Л_ok )) := next (( $ Л_index )) ) >> 
DePoolFunc.v: (( $ Л_index , $ Л_round , $ Л_ok )) := min () ) >> 
DePoolFunc.v: 	 while (( $ Л_ok ) { (( $ Л_presents , $ Л_value )) := $ Л_round ^^ RoundsBase_ι_Round_ι_stakes . fetch (( $ Л_addr )) ) >> 
DePoolFunc.v: Ift ( $ Л_presents ) { ( d0! Л_invested2 += $ Л_value ^^ RoundsBase_ι_StakeValue_ι_simple + $ Л_value ^^ RoundsBase_ι_StakeValue_ι_vesting ) >> 
DePoolFunc.v: (( $ Л_index , $ Л_round , $ Л_ok )) := next (( uint32 (( $ Л_index )) )) ) >> 
DePoolFunc.v:Definition StakingProxyContract_Ф_process_new_stake ( msg_value : XInteger ) ( msg_sender : XInteger ) ( $ Л_queryId : XInteger64 )( $ Л_validatorKey : XInteger256 )( $ Л_stakeAt : XInteger32 )( $ Л_maxFactor : XInteger32 )( $ Л_adnlAddr : XInteger256 )( $ Л_signature : XInteger8 ) : StakingProxyContractT := 
DePoolFunc.v: 	 IElector (( ElectorBase_ι_m_elector )) . library_Ф_elector_process_new_stake ^^ value (( $ msg_value - StakingProxyContract_ι_PROXY_FEE )) (( $ Л_queryId , $ Л_validatorKey , $ Л_stakeAt , $ Л_maxFactor , $ Л_adnlAddr , $ Л_signature )) ) >> 
DePoolFunc.v:Definition ElectionParams_Ф_Constructor4 ( $ Л_electionId : XInteger32 )( $ Л_beginBefore : XInteger32 )( $ Л_endBefore : XInteger32 )( $ Л_heldFor : XInteger32 )( $ Л_electedFor : XInteger32 ) : ElectionParamsT := 
DePoolFunc.v: Ife ( $ Л_electionId ?!= $ xInt0 ) { ( d1! ElectionParams_ι_m_electAt := $ Л_electionId ) >> 
DePoolFunc.v: (( ElectionParams_ι_m_electedFor , ElectionParams_ι_m_beginBefore , ElectionParams_ι_m_endBefore , ElectionParams_ι_m_heldFor , $ Л_ok )) := tvm_configParam (( $ xInt15 )) ) >> 
DePoolFunc.v: Ift ( ! $ Л_ok ) { ( d1! ElectionParams_ι_m_beginBefore := $ Л_beginBefore ) >> 
DePoolFunc.v: 	 ( d1! ElectionParams_ι_m_endBefore := $ Л_endBefore ) >> 
DePoolFunc.v: 	 ( d1! ElectionParams_ι_m_electedFor := $ Л_electedFor ) >> 
DePoolFunc.v: 	 ( d1! ElectionParams_ι_m_heldFor := $ Л_heldFor ) >> 
DePoolFunc.v:Definition StakingOwner_Ф_initTimer ( $ Л_timer : XAddress )( $ Л_period : XInteger ) : StakingOwnerT := 
DePoolFunc.v: 	 ( d1! StakingOwner_ι_m_timer := $ Л_timer ) >> 
DePoolFunc.v: 	 ( d1! StakingOwner_ι_m_timeout := $ Л_period ) >> 
DePoolFunc.v: 	 StakingOwner_Ф__settimer (( $ Л_timer , $ Л_period )) ) >> 
DePoolFunc.v:Definition StakingOwner_Ф_upgrade ( $ Л_newcode : TvmCell ) : StakingOwnerT := 
DePoolFunc.v: 	 tvm_setcode (( $ Л_newcode )) ) >> 
DePoolFunc.v: 	 tvm_setCurrentCode (( $ Л_newcode )) ) >> 
DePoolFunc.v:Definition RoundsBase_Ф__roundMoveStakes ( $ Л_source : XAddress )( $ Л_destination : XAddress )( $ Л_targetAmount : XInteger64 ) : RoundsBaseT XInteger64 := 
DePoolFunc.v: (( $ Л_roundId , $ Л_round , $ Л_ok )) := min () ) >> 
DePoolFunc.v: 	 ( d0! Л_transferred := $ xInt0 ) >> 
DePoolFunc.v: 	 while (( $ Л_ok && $ Л_targetAmount ?!= $ xInt0 ) { 
DePoolFunc.v: Ift ( $ Л_round ^^ RoundsBase_ι_Round_ι_step ?!= RoundsBase_ι_STEP_COMPLETED && $ Л_round ^^ RoundsBase_ι_Round_ι_step ?!= RoundsBase_ι_STEP_COMPLETING ) { (( RoundsBase_ι_m_rounds [ $ Л_roundId ] , $ Л_currentTransferred )) := RoundsBase_Ф__roundMoveStake (( $ Л_round , $ Л_source , $ Л_destination , $ Л_targetAmount )) ) >> 
DePoolFunc.v: 	 ( d0! Л_targetAmount -= $ Л_currentTransferred ) >> 
DePoolFunc.v: 	 ( d0! Л_transferred += $ Л_currentTransferred ) >> 
DePoolFunc.v: (( $ Л_roundId , $ Л_round , $ Л_ok )) := next (( $ Л_roundId )) ) >> 
DePoolFunc.v: return $ Л_transferred ) >> 
DePoolFunc.v:Definition StakingContract_Ф__completePendingRound ( $ Л_pendingRound : ι_Round )( $ Л_chunkSize : XInteger8 ) : StakingContractT ι_Round := 
DePoolFunc.v: Ife ( $ Л_pendingRound ^^ RoundsBase_ι_Round_ι_participantQty ?> $ Л_chunkSize ) { for (( ( d0! Л_i := $ xInt0 ) >> 
DePoolFunc.v: 	 $ Л_i ?< $ Л_pendingRound ^^ RoundsBase_ι_Round_ι_participantQty ) >> 
DePoolFunc.v: 	 ( d0! Л_i += $ Л_chunkSize ) { this ^^ StakingContract_Ф_completePendingRoundChunk . value (( 1e7 )) (( $ Л_pendingRound ^^ RoundsBase_ι_Round_ι_id , $ Л_chunkSize )) ) >> 
DePoolFunc.v: ( d0! Л_pendingRound := StakingContract_Ф__returnOrReinvest (( $ Л_pendingRound , $ Л_chunkSize )) ) >> 
DePoolFunc.v: return $ Л_pendingRound ) >> 
fuctionsFileGenerator3.v:Compute (del_lead_2_symbolsι_ "Л_1234567").
fuctionsFileGenerator3.v:            then ("Л_"++h)%string :: (renaming_local_vars' llv t)
fuctionsFileGenerator3.v:Compute (first2 "Л_234567").
fuctionsFileGenerator44.v:            then ("Л_"++h)%string :: (renaming_local_vars' llv t)
fuctionsFileGenerator44.v:Compute (first2 "Л_234567").
fuctionsFileGenerator45.v:            then ("Л_"++h)%string :: (renaming_local_vars' llv t)
fuctionsFileGenerator45.v:Compute (first2 "Л_234567").
fuctionsFileGenerator4.v:Compute (let q := "Definition OwnerBase_Ф_withdrawOwnerReward ( Л_amount : XInteger64 )  :=  { 
fuctionsFileGenerator4.v:         require ( Л_amount <= OwnerBase_ι_m_owner . OwnerBase_ι_Owner_ι_reward , xInt105 ) ; 
fuctionsFileGenerator4.v:         OwnerBase_ι_m_owner . OwnerBase_ι_Owner_ι_reward -= Л_amount ; 
fuctionsFileGenerator4.v:         OwnerBase_ι_m_owner . OwnerBase_ι_Owner_ι_addr . transfer ( Л_amount , true , xInt3 ) ; 
fuctionsFileGenerator4.v:            then ("Л_"++h)%string :: (renaming_local_vars' llv t)
fuctionsFileGenerator4.v:Compute (first2 "Л_234567").
fuctionsFileGenerator5.v:Compute (let q := "Definition OwnerBase_Ф_withdrawOwnerReward ( Л_amount : XInteger64 )  :=  { 
fuctionsFileGenerator5.v:         require ( Л_amount <= OwnerBase_ι_m_owner . OwnerBase_ι_Owner_ι_reward , xInt105 ) ; 
fuctionsFileGenerator5.v:         OwnerBase_ι_m_owner . OwnerBase_ι_Owner_ι_reward -= Л_amount ; 
fuctionsFileGenerator5.v:         OwnerBase_ι_m_owner . OwnerBase_ι_Owner_ι_addr . transfer ( Л_amount , true , xInt3 ) ; 
fuctionsFileGenerator5.v:            then ("Л_"++h)%string :: (renaming_local_vars' llv t)
fuctionsFileGenerator5.v:Compute (first2 "Л_234567").
functions_exchange.v:Compute (del_lead_2_symbolsι_ "Л_1234567").
